import jsPDF from 'jspdf';
import complexityEngine from './complexityEngine.js';

interface ExportData {
  title: string;
  code?: string;
  language?: string;
  timeComplexity?: string;
  timeComplexityReason?: string;
  spaceComplexity?: string;
  spaceComplexityReason?: string;
  revisionNotes?: string[];
  edgeCases?: string[];
  approach?: string;
  explanation?: string;
  pattern?: string;
  dsaCategory?: string;
  problemOverview?: string;
  testCases?: string[];
  patternName?: string;
  trick?: string;
  approachSteps?: string;
  whyItWorks?: string;
  highYieldEdgeCases?: string[];
  syntaxNotes?: string[];
  coreLogic?: string | Record<string, any>;
}

/**
 * Export notes as Markdown format
 */
export const exportAsMarkdown = (data: ExportData): void => {
  let markdown = `# ${data.title}\n\n`;

  // Metadata
  if (data.pattern || data.dsaCategory || data.language) {
    markdown += `**Metadata:**\n`;
    if (data.dsaCategory) markdown += `- Category: ${data.dsaCategory}\n`;
    if (data.pattern) markdown += `- Pattern: ${data.pattern}\n`;
    if (data.language) markdown += `- Language: ${data.language}\n`;
    markdown += `\n`;
  }

  // Problem Overview
  if (data.problemOverview) {
    markdown += `## Problem Overview\n${data.problemOverview}\n\n`;
  }

  // Test Cases
  if (data.testCases && data.testCases.length > 0) {
    markdown += `## Test Cases\n`;
    data.testCases.forEach((testCase) => {
      markdown += `- ${testCase}\n`;
    });
    markdown += `\n`;
  }

  // Complexity - use engine if reasons not provided
  if (data.timeComplexity || data.spaceComplexity) {
    markdown += `## Complexity Analysis\n\n`;

    // Try to get explanations from engine if code is available and reasons are missing
    let tcReason = data.timeComplexityReason;
    let scReason = data.spaceComplexityReason;

    if (data.code && (!tcReason || !scReason)) {
      try {
        const analysis = complexityEngine.analyze(
          data.code,
          data.language?.toLowerCase() || 'java'
        );
        if (!tcReason && analysis?.timeComplexityReason) {
          tcReason = analysis.timeComplexityReason;
        }
        if (!scReason && analysis?.spaceComplexityReason) {
          scReason = analysis.spaceComplexityReason;
        }
      } catch (e) {
        console.log('[EXPORT] Could not analyze complexity:', e);
      }
    }

    if (data.timeComplexity) {
      markdown += `**Time Complexity:** ${data.timeComplexity}\n`;
      if (tcReason) markdown += `> ${tcReason}\n\n`;
      else markdown += `\n`;
    }
    if (data.spaceComplexity) {
      markdown += `**Space Complexity:** ${data.spaceComplexity}\n`;
      if (scReason) markdown += `> ${scReason}\n\n`;
      else markdown += `\n`;
    }
  }

  // Core Logic & Approach
  const coreData =
    data.coreLogic ||
    (typeof data.approach === 'object' ? data.approach : null);
  if (coreData && typeof coreData === 'object') {
    markdown += `## Core Logic & Approach\n\n`;
    Object.entries(coreData).forEach(([key, val]) => {
      markdown += `### ${key.charAt(0).toUpperCase() + key.slice(1)}\n`;
      if (Array.isArray(val)) {
        val.forEach((item: any) => (markdown += `- ${item}\n`));
      } else {
        markdown += `${val}\n`;
      }
      markdown += `\n`;
    });
  } else if (typeof data.coreLogic === 'string') {
    markdown += `## Core Logic\n${data.coreLogic}\n\n`;
  }

  // Simple approach string
  if (
    data.approach &&
    typeof data.approach === 'string' &&
    data.approach.trim()
  ) {
    markdown += `## Approach\n${data.approach}\n\n`;
  }

  if (data.code) {
    markdown += `## Code (${data.language || 'Code'})\n\`\`\`${(data.language || 'javascript').toLowerCase()}\n${data.code}\n\`\`\`\n\n`;
  }

  // Fast Recall
  if (data.revisionNotes && data.revisionNotes.length > 0) {
    markdown += `## Fast Recall Checklist\n`;
    data.revisionNotes.forEach((note, idx) => {
      markdown += `${idx + 1}. ${note}\n`;
    });
    markdown += `\n`;
  }

  // Edge Cases
  if (data.highYieldEdgeCases && data.highYieldEdgeCases.length > 0) {
    markdown += `## High Yield Edge Cases\n`;
    data.highYieldEdgeCases.forEach((edge, idx) => {
      markdown += `${idx + 1}. ${edge}\n`;
    });
    markdown += `\n`;
  }

  if (data.edgeCases && data.edgeCases.length > 0) {
    markdown += `## Edge Cases\n`;
    data.edgeCases.forEach((edge, idx) => {
      markdown += `${idx + 1}. ${edge}\n`;
    });
    markdown += `\n`;
  }

  // Language Syntax
  if (data.syntaxNotes && data.syntaxNotes.length > 0) {
    markdown += `## Language Syntax to Remember\n`;
    data.syntaxNotes.forEach((syntax) => {
      markdown += `- ${syntax}\n`;
    });
    markdown += `\n`;
  }

  if (data.explanation) {
    markdown += `## Explanation\n${data.explanation}\n\n`;
  }

  markdown += `\n---\n*Generated by ReCode*\n`;

  // Download
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${data.title.replace(/[^a-zA-Z0-9]/g, '_')}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Export notes as PDF format (Pro Feature)
 * Premium dark-themed PDF matching ReCode app design
 */
export const exportAsPDF = (data: ExportData): void => {
  try {
    console.log('[EXPORT] Starting premium PDF generation...', data.title);
    const pdf = new jsPDF();
    let yPos = 20;
    const lineHeight = 6.5; // Slightly increased for better readability
    const pageHeight = pdf.internal.pageSize.height;
    const pageWidth = pdf.internal.pageSize.width;
    const margin = 15;
    const contentWidth = pageWidth - margin * 2;

    // Color Palette
    const colors = {
      bgBase: [11, 15, 25],
      bgCard: [17, 19, 24],
      bgCode: [13, 17, 23],
      textPrimary: [229, 231, 235],
      textSecondary: [156, 163, 175],
      textMuted: [107, 114, 128],
      gold: [230, 200, 136],
      borderDefault: [31, 41, 55],
    };

    const setTextColor = (c: number[]) => pdf.setTextColor(c[0], c[1], c[2]);
    const setFillColor = (c: number[]) => pdf.setFillColor(c[0], c[1], c[2]);
    const setDrawColor = (c: number[]) => pdf.setDrawColor(c[0], c[1], c[2]);

    const addPageWithBackground = () => {
      pdf.addPage();
      setFillColor(colors.bgBase);
      pdf.rect(0, 0, pageWidth, pageHeight, 'F');
      yPos = 20;
    };

    const checkPageBreak = (height: number = lineHeight) => {
      if (yPos + height > pageHeight - 25) {
        addPageWithBackground();
        return true;
      }
      return false;
    };

    const addSectionHeader = (text: string) => {
      // Add extra top margin if not at start of page
      if (yPos > 30) yPos += 12;

      checkPageBreak(25);
      yPos += 8;
      setFillColor(colors.gold);
      pdf.rect(margin, yPos - 4, 3, 12, 'F');
      setTextColor(colors.textPrimary);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text(text.toUpperCase(), margin + 8, yPos + 4);
      setDrawColor(colors.borderDefault);
      pdf.line(margin + 8, yPos + 8, margin + contentWidth, yPos + 8);
      yPos += 18; // More breathing room after header
    };

    const addSubsectionHeader = (text: string) => {
      checkPageBreak(14);
      setTextColor(colors.textPrimary);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      pdf.text(text, margin + 5, yPos);
      yPos += lineHeight + 3;
    };

    const addBodyText = (text: string, indent = 0) => {
      pdf.setFontSize(9.5); // Slightly larger
      pdf.setFont('helvetica', 'normal');
      setTextColor(colors.textSecondary);
      // Narrower content width for better scan-ability
      const lines = pdf.splitTextToSize(text, contentWidth - indent - 15);
      lines.forEach((line: string) => {
        checkPageBreak();
        pdf.text(line, margin + indent + 5, yPos);
        yPos += lineHeight + 0.5; // More line height
      });
    };

    const addMutedText = (text: string, indent = 0) => {
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      setTextColor(colors.textMuted);
      const lines = pdf.splitTextToSize(text, contentWidth - indent - 10);
      lines.forEach((line: string) => {
        checkPageBreak();
        pdf.text(line, margin + indent + 8, yPos);
        yPos += lineHeight - 1;
      });
    };

    const addBullet = (text: string, number?: number) => {
      checkPageBreak(lineHeight * 2.5);
      pdf.setFontSize(9.5);
      pdf.setFont('helvetica', 'normal');
      const prefix = number !== undefined ? `${number}.` : '•';
      const lines = pdf.splitTextToSize(`${text}`, contentWidth - 20); // More indent
      setTextColor(colors.gold);
      pdf.text(prefix, margin + 5, yPos);
      setTextColor(colors.textSecondary);
      lines.forEach((line: string, idx: number) => {
        checkPageBreak();
        pdf.text(line, margin + 15, yPos);
        yPos += lineHeight;
      });
      yPos += 2.5; // Spacing between bullet items
    };

    const addComplexityLine = (label: string, value: string) => {
      checkPageBreak(lineHeight + 2);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      setTextColor(colors.textSecondary);
      pdf.text(label + ': ', margin + 5, yPos);
      const labelWidth = pdf.getTextWidth(label + ': ');
      setTextColor(colors.gold);
      pdf.setFont('helvetica', 'bold');
      pdf.text(value, margin + 5 + labelWidth, yPos);
      yPos += lineHeight + 2;
    };

    // Start Page 1
    setFillColor(colors.bgBase);
    pdf.rect(0, 0, pageWidth, pageHeight, 'F');

    // Title Block
    setFillColor(colors.bgCard);
    pdf.rect(margin, 10, contentWidth, 30, 'F');
    setDrawColor(colors.borderDefault);
    pdf.rect(margin, 10, contentWidth, 30, 'S');
    setTextColor(colors.gold);
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    const titleLines = pdf.splitTextToSize(data.title, contentWidth - 10);
    titleLines.forEach((line: string, idx: number) => {
      pdf.text(line, margin + 5, 22 + idx * 7);
    });
    yPos = 48;

    // Metadata
    if (data.pattern || data.dsaCategory || data.language) {
      pdf.setFontSize(8);
      setTextColor(colors.textMuted);
      const metaParts = [];
      if (data.dsaCategory) metaParts.push(`Category: ${data.dsaCategory}`);
      if (data.pattern) metaParts.push(`Pattern: ${data.pattern}`);
      if (data.language) metaParts.push(`Language: ${data.language}`);
      pdf.text(metaParts.join('   •   '), margin + 5, yPos);
      yPos += 12;
    }

    // Complexity
    if (data.timeComplexity || data.spaceComplexity) {
      addSectionHeader('Complexity Analysis');
      let tcReason = data.timeComplexityReason;
      let scReason = data.spaceComplexityReason;
      if (data.code && (!tcReason || !scReason)) {
        try {
          const analysis = complexityEngine.analyze(
            data.code,
            data.language?.toLowerCase() || 'java'
          );
          if (!tcReason && analysis?.timeComplexityReason)
            tcReason = analysis.timeComplexityReason;
          if (!scReason && analysis?.spaceComplexityReason)
            scReason = analysis.spaceComplexityReason;
        } catch (e) {}
      }
      if (data.timeComplexity) {
        addComplexityLine('Time Complexity', data.timeComplexity);
        if (tcReason) {
          addMutedText(tcReason, 5);
          yPos += 4;
        }
      }
      if (data.spaceComplexity) {
        addComplexityLine('Space Complexity', data.spaceComplexity);
        if (scReason) {
          addMutedText(scReason, 5);
        }
      }
      yPos += 5;
    }

    // Core Logic
    const coreData =
      data.coreLogic ||
      (typeof data.approach === 'object' ? data.approach : null);
    if (coreData && typeof coreData === 'object') {
      addSectionHeader('Core Logic & Approach');
      Object.entries(coreData).forEach(([key, val]) => {
        addSubsectionHeader(key.charAt(0).toUpperCase() + key.slice(1));
        if (Array.isArray(val)) {
          val.forEach((item: any) => addBullet(String(item)));
        } else {
          addBodyText(String(val), 0);
        }
        yPos += 4;
      });
    }

    // Code
    if (data.code) {
      addSectionHeader(`Code (${data.language || 'Code'})`);
      const codeLines = data.code.split('\n');
      // Increased code spacing
      const codeLineHeight = 4.8;
      const codeBlockHeight = Math.min(
        codeLines.length * codeLineHeight + 10,
        pageHeight - yPos - 30
      );

      setFillColor(colors.bgCode);
      pdf.rect(margin + 2, yPos - 2, contentWidth - 4, codeBlockHeight, 'F');
      setDrawColor(colors.borderDefault);
      pdf.rect(margin + 2, yPos - 2, contentWidth - 4, codeBlockHeight, 'S');

      pdf.setFont('courier', 'normal');
      pdf.setFontSize(8);
      setTextColor(colors.textPrimary);

      yPos += 4; // Padding inside code block
      codeLines.forEach((line, idx) => {
        if (yPos > pageHeight - 35) {
          addPageWithBackground();
          setFillColor(colors.bgCode);
          const remainingLines = codeLines.length - idx;
          const remainingHeight = Math.min(
            remainingLines * codeLineHeight + 10,
            pageHeight - 50
          );
          pdf.rect(
            margin + 2,
            yPos - 2,
            contentWidth - 4,
            remainingHeight,
            'F'
          );
          setDrawColor(colors.borderDefault);
          pdf.rect(
            margin + 2,
            yPos - 2,
            contentWidth - 4,
            remainingHeight,
            'S'
          );
          yPos += 4;
        }
        pdf.text(line.substring(0, 95), margin + 6, yPos);
        yPos += codeLineHeight;
      });
      pdf.setFont('helvetica', 'normal');
      yPos += 12;
    }

    // Fast Recall
    if (data.revisionNotes && data.revisionNotes.length > 0) {
      // Smart page break for checklist - if less than 40% page left, start on new page
      if (yPos > pageHeight * 0.6) {
        addPageWithBackground();
      }

      addSectionHeader('Fast Recall Checklist');
      data.revisionNotes.forEach((note, idx) => {
        addBullet(String(note), idx + 1);
      });
    }

    // Edge Cases
    if (data.edgeCases && data.edgeCases.length > 0) {
      addSectionHeader('Edge Cases');
      data.edgeCases.forEach((edge, idx) => {
        addBullet(String(edge), idx + 1);
      });
    }

    // Footer
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      setDrawColor(colors.borderDefault);
      pdf.line(margin, pageHeight - 15, margin + contentWidth, pageHeight - 15);
      pdf.setFontSize(7);
      setTextColor(colors.textMuted);
      pdf.text('Generated by ReCode', margin, pageHeight - 8);
      const pageText = `Page ${i} of ${totalPages}`;
      pdf.text(
        pageText,
        pageWidth - margin - pdf.getTextWidth(pageText),
        pageHeight - 8
      );
    }

    const filename = `${data.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
    pdf.save(filename);
  } catch (error) {
    console.error('[EXPORT] PDF generation failed:', error);
    alert('Failed to generate PDF. Please try again.');
  }
};

/**
 * Export notes as plain text format
 */
export const exportAsText = (data: ExportData): void => {
  let text = `${data.title}\n${'='.repeat(data.title.length)}\n\n`;

  // Metadata
  if (data.pattern || data.dsaCategory || data.language) {
    text += `METADATA:\n`;
    if (data.dsaCategory) text += `- Category: ${data.dsaCategory}\n`;
    if (data.pattern) text += `- Pattern: ${data.pattern}\n`;
    if (data.language) text += `- Language: ${data.language}\n`;
    text += `\n`;
  }

  // Problem Overview
  if (data.problemOverview) {
    text += `PROBLEM OVERVIEW:\n${data.problemOverview}\n\n`;
  }

  // Test Cases
  if (data.testCases && data.testCases.length > 0) {
    text += `TEST CASES:\n`;
    data.testCases.forEach((testCase) => {
      text += `- ${testCase}\n`;
    });
    text += `\n`;
  }

  // Complexity - use engine if reasons not provided
  if (data.timeComplexity || data.spaceComplexity) {
    text += `COMPLEXITY ANALYSIS:\n\n`;
    let tcReason = data.timeComplexityReason;
    let scReason = data.spaceComplexityReason;
    if (data.code && (!tcReason || !scReason)) {
      try {
        const analysis = complexityEngine.analyze(
          data.code,
          data.language?.toLowerCase() || 'java'
        );
        if (!tcReason && analysis?.timeComplexityReason)
          tcReason = analysis.timeComplexityReason;
        if (!scReason && analysis?.spaceComplexityReason)
          scReason = analysis.spaceComplexityReason;
      } catch (e) {}
    }
    if (data.timeComplexity) {
      text += `Time Complexity: ${data.timeComplexity}\n`;
      if (tcReason) text += `${tcReason}\n\n`;
    }
    if (data.spaceComplexity) {
      text += `Space Complexity: ${data.spaceComplexity}\n`;
      if (scReason) text += `${scReason}\n\n`;
    }
  }

  // Core Logic & Approach
  const coreData =
    data.coreLogic ||
    (typeof data.approach === 'object' ? data.approach : null);
  if (coreData && typeof coreData === 'object') {
    text += `CORE LOGIC & APPROACH:\n\n`;
    Object.entries(coreData).forEach(([key, val]) => {
      text += `${key.toUpperCase()}:\n`;
      if (Array.isArray(val)) {
        val.forEach((item: any) => (text += `- ${item}\n`));
      } else {
        text += `${val}\n`;
      }
      text += `\n`;
    });
  } else if (typeof data.coreLogic === 'string') {
    text += `CORE LOGIC:\n${data.coreLogic}\n\n`;
  }

  if (
    data.approach &&
    typeof data.approach === 'string' &&
    data.approach.trim()
  ) {
    text += `APPROACH:\n${data.approach}\n\n`;
  }

  if (data.code) {
    text += `CODE (${data.language || 'Code'}):\n`;
    text += `----------------------------------------\n`;
    text += `${data.code}\n`;
    text += `----------------------------------------\n\n`;
  }

  // Fast Recall
  if (data.revisionNotes && data.revisionNotes.length > 0) {
    text += `FAST RECALL CHECKLIST:\n`;
    data.revisionNotes.forEach((note, idx) => {
      text += `${idx + 1}. ${note}\n`;
    });
    text += `\n`;
  }

  // Edge Cases
  if (data.highYieldEdgeCases && data.highYieldEdgeCases.length > 0) {
    text += `HIGH YIELD EDGE CASES:\n`;
    data.highYieldEdgeCases.forEach((edge, idx) => {
      text += `${idx + 1}. ${edge}\n`;
    });
    text += `\n`;
  }

  if (data.edgeCases && data.edgeCases.length > 0) {
    text += `EDGE CASES:\n`;
    data.edgeCases.forEach((edge, idx) => {
      text += `${idx + 1}. ${edge}\n`;
    });
    text += `\n`;
  }

  if (data.explanation) {
    text += `EXPLANATION:\n${data.explanation}\n\n`;
  }

  text += `\n---\nGenerated by ReCode\n`;

  // Download
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${data.title.replace(/[^a-zA-Z0-9]/g, '_')}.txt`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
