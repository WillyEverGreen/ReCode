{
  "version": "2.0",
  "generated": "2025-12-31T06:40:53.866Z",
  "source": "Striver's A2Z DSA Sheet",
  "statistics": {
    "total": 369,
    "byCategory": {
      "arrays": 39,
      "binary-search": 31,
      "strings": 14,
      "linked-list": 29,
      "recursion": 21,
      "bit-manipulation": 16,
      "stack-queue": 27,
      "sliding-window": 11,
      "heaps": 16,
      "greedy": 12,
      "binary-trees": 35,
      "bst": 15,
      "graphs": 42,
      "dynamic-programming": 50,
      "tries": 6,
      "strings-hard": 5
    },
    "byDifficulty": {
      "easy": 24,
      "medium": 71,
      "hard": 44,
      "unknown": 230
    },
    "byPattern": {
      "two-pointers": 89,
      "sliding-window": 12,
      "hash-map": 39,
      "binary-search": 34,
      "hash-set": 70,
      "backtracking": 26,
      "sorting": 19,
      "recursion": 69,
      "divide-conquer": 3,
      "heap": 21,
      "trie": 12,
      "monotonic-stack": 6,
      "union-find": 7,
      "bfs": 21,
      "dfs": 9,
      "dynamic-programming": 50
    },
    "needsReview": 347
  },
  "problems": {
    "quicksort": {
      "id": "quicksort",
      "title": "QuickSort",
      "category": "sorting",
      "difficulty": "medium",
      "problemStatement": "Implement the QuickSort algorithm to sort an array of integers in ascending order.",
      "approach": "QuickSort uses divide and conquer. Pick a pivot, partition around it, recursively sort subarrays.",
      "complexity": {
        "time": {
          "average": "O(n log n)",
          "worst": "O(n²)"
        },
        "space": {
          "average": "O(log n)",
          "worst": "O(n)"
        }
      },
      "patterns": ["divide-conquer", "recursion"],
      "verified": true,
      "needsReview": false
    },
    "mergesort": {
      "id": "mergesort",
      "title": "MergeSort",
      "category": "sorting",
      "difficulty": "medium",
      "problemStatement": "Implement the MergeSort algorithm to sort an array of integers in ascending order.",
      "approach": "MergeSort uses divide and conquer. Split array in half, recursively sort, merge sorted halves.",
      "complexity": {
        "time": {
          "average": "O(n log n)",
          "worst": "O(n log n)"
        },
        "space": {
          "average": "O(n)",
          "worst": "O(n)"
        }
      },
      "patterns": ["divide-conquer", "recursion"],
      "verified": true,
      "needsReview": false
    },
    "heapsort": {
      "id": "heapsort",
      "title": "HeapSort",
      "category": "sorting",
      "difficulty": "medium",
      "problemStatement": "Implement the HeapSort algorithm to sort an array of integers in ascending order.",
      "approach": "HeapSort builds a max heap, then repeatedly extracts the maximum element.",
      "complexity": {
        "time": {
          "average": "O(n log n)",
          "worst": "O(n log n)"
        },
        "space": {
          "average": "O(1)",
          "worst": "O(1)"
        }
      },
      "patterns": ["heap"],
      "verified": true,
      "needsReview": false
    },
    "largest-element-in-array": {
      "id": "largest-element-in-array",
      "title": "Largest element in array",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an array A[] of size n. The task is to find the largest element in it.\r\n\r\nExample:\r\n\r\nInput:\r\nn = 5\r\nA[] = {1, 8, 7, 56, 90}\r\nOutput:\r\n90\r\nExplanation:\r\nThe largest element of given array is 90",
      "approach": "-\r\n-> Intialize the ans with starting element\r\n-> Traverse the entire array and update the ans if the element is greater then ans\r\n-> Finally, return the ans",
      "code": "int largest(int arr[], int n)\r\n{\r\n    int ans = arr[0];\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        if (arr[i] > ans)\r\n            ans = arr[i];\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (int i = 1; i < n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\01.Largest_element_in_array.cpp",
      "verified": false,
      "needsReview": false
    },
    "second-largest-element-in-array": {
      "id": "second-largest-element-in-array",
      "title": "Second largest element in array",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an array Arr of size N, print second largest distinct element from an array.\r\n\r\nExample:\r\n\r\nInput:\r\nN = 6\r\nArr[] = {12, 35, 1, 10, 34, 1}\r\nOutput: 34\r\nExplanation: The largest element of the\r\narray is 35 and the second largest element\r\nis 34.",
      "approach": "-> If the current element is larger than ‘large’ then update second_large and large variables\r\n-> Else if the current element is larger than ‘second_large’ then we update the variable second_large.\r\n-> Once we traverse the entire array, we would find the second largest element in the variable second_large.",
      "code": "int print2largest(int arr[], int n)\r\n{\r\n    int prev = -1, curr = arr[0];\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        if (arr[i] > curr)\r\n        {\r\n            prev = curr;\r\n            curr = arr[i];\r\n        }\r\n        else if (arr[i] > prev && arr[i] != curr)\r\n            prev = arr[i];\r\n    }\r\n    return prev;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (int i = 1; i < n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\02.Second_largest_element_in_array.cpp",
      "verified": false,
      "needsReview": false
    },
    "check-if-array-is-sorted-and-rotated": {
      "id": "check-if-array-is-sorted-and-rotated",
      "title": "Check if array is sorted and rotated",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\r\nThere may be duplicates in the original array.\r\nExample 1:\r\n\r\nInput: nums = [3,4,5,1,2]\r\nOutput: true\r\nExplanation: [1,2,3,4,5] is the original sorted array.\r\nYou can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].\r\nExample 2:\r\n\r\nInput: nums = [2,1,3,4]\r\nOutput: false\r\nExplanation: There is no sorted array once rotated that can make nums.",
      "approach": "-\r\nCompare all neignbour elements (a,b) in A,\r\nthe case of a > b can happen at most once.\r\n\r\nNote that the first element and the last element are also connected.\r\n\r\nIf all a <= b, A is already sorted so answer is true.\r\nIf all a <= b but only one a > b, and the first element is greater than equal to last element\r\nwe can rotate and make b the first element so answer is true.\r\nOther case, return false.",
      "code": "bool check(vector<int> &nums)\r\n{\r\n    int cnt = 0;\r\n    int n = nums.size();\r\n    for (int i = 0; i < n - 1; i++)\r\n    {\r\n        if (nums[i] > nums[i + 1])\r\n            cnt++;\r\n    }\r\n    if (cnt == 0)\r\n        return true;\r\n    else if (cnt == 1 && nums[0] >= nums[n - 1])\r\n        return true;\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < n - 1; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\03.Check_if_array_is_sorted_and_rotated.cpp",
      "verified": false,
      "needsReview": false
    },
    "remove-duplicates-from-sorted-array": {
      "id": "remove-duplicates-from-sorted-array",
      "title": "Remove duplicates from sorted array",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\r\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\r\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\r\nReturn k.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,2]\r\nOutput: 2, nums = [1,2,_]\r\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).\r\nExample 2:\r\n\r\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\r\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\r\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
      "approach": "-\r\n-> The idea, is to use keep a pointer k which signifies that upto here the array is sorted\r\n-> Now travese the entire array and if arr[k]!=arr[j] that is arr[j] is a unique value hence it should be included\r\n   so increment the k and swap arr[k] with arr[j]\r\n-> Return k+1, +1 is because of 0 based indexing",
      "code": "int removeDuplicates(vector<int> &nums)\r\n{\r\n    int k = 0; // upto k array contains unique elements\r\n    for (int j = 1; j < nums.size(); j++)\r\n    {\r\n        if (nums[k] != nums[j])\r\n        {\r\n            k++;\r\n            swap(nums[k], nums[j]);\r\n        }\r\n    }\r\n    return k + 1;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int j = 1; j < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\04.Remove_duplicates_from_sorted_array.cpp",
      "verified": false,
      "needsReview": false
    },
    "rotate-array-left-by-1place": {
      "id": "rotate-array-left-by-1place",
      "title": "Rotate array left by 1place",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an array \"ARR' containing 'N' elements, rotate this array Left by once means to shift all elements by one place to the left and move the first element to the last position in the array.\r\n\r\nExample:\r\nInput: 'N' 5, 'ARR' = [1, 2, 3, 4, 5]\r\nOutput: [2, 3, 4, 5, 1]\r\n\r\nExplanation:\r\nWe moved the 2nd element to the 1st position and 3rd element to the 2nd position and 4th element to the 3rd position and 5th element to the 4th position and move oth element to the 5th position.",
      "approach": "-\r\n-> By observing we can the ans is the arr where arr[i] = arr[i+1] and at last place we will have arr[0]\r\n-> Before traversing store the arr[0] in temp and then traverse the array and make arr[i] = arr[i+1]\r\n-> Make arr[n-1] = arr[0], where n is the size of the array",
      "code": "vector<int> rotateArray(vector<int> &arr, int n)\r\n{\r\n    int temp = arr[0];\r\n    for (int i = 0; i < n - 1; i++)\r\n    {\r\n        arr[i] = arr[i + 1];\r\n    }\r\n    arr[n - 1] = temp;\r\n\r\n    return arr;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n - 1; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\05.Rotate_array_left_by_1place.cpp",
      "verified": false,
      "needsReview": false
    },
    "rotate-array-left-right-by-k-places": {
      "id": "rotate-array-left-right-by-k-places",
      "title": "Rotate array left&right by k places",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4,5,6,7], k = 3\r\nOutput: [5,6,7,1,2,3,4]\r\nExplanation:\r\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\r\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\r\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\r\nExample 2:\r\n\r\nInput: nums = [-1,-100,3,99], k = 2\r\nOutput: [3,99,-1,-100]\r\nExplanation:\r\nrotate 1 steps to the right: [99,-1,-100,3]\r\nrotate 2 steps to the right: [3,99,-1,-100]",
      "approach": "-\r\nTo rotate the array k places to right follow below steps\r\n-> Reverse first n-k elements\r\n-> Reverse last k elements\r\n-> Reverse the entire array\r\n\r\nTo rotate the array k places to left follow below steps\r\n-> Reverse first k elements\r\n-> Reverse last n-k elements\r\n-> Reverse the entire array",
      "code": "// RIGHT ROATATE:-\r\nvoid rightRotate(int arr[], int n, int k)\r\n{\r\n    k = k % n; // to keep k within the range\r\n    reverse(arr, arr + (n - k));\r\n    reverse(arr + (n - k), arr + n);\r\n    reverse(arr, arr + n);\r\n}\r\n\r\n// LEFT ROATATE:-\r\nvoid leftRotate(int arr[], int n, int k)\r\n{\r\n    k = k % n; // to keep k within the range\r\n    reverse(arr, arr + k);\r\n    reverse(arr + k, arr + n);\r\n    reverse(arr, arr + n);\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\06.Rotate_array_left&right_by_k_places.cpp",
      "verified": false,
      "needsReview": false
    },
    "move-0-s-to-end": {
      "id": "move-0-s-to-end",
      "title": "Move 0's to end",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\nNote that you must do this in-place without making a copy of the array.\r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1,0,3,12]\r\nOutput: [1,3,12,0,0]\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [0]",
      "approach": "-\r\n-> The idea is while traversing the array if we found any zero then we have to swap it with next non-zero",
      "code": "// function to find the next non-zero element\r\nint next_nonzero(vector<int> &a, int &j)\r\n{\r\n    while (j < a.size())\r\n    {\r\n        if (a[j] != 0)\r\n            return j;\r\n        j++;\r\n    }\r\n    return -1;\r\n}\r\nvoid moveZeroes(vector<int> &nums)\r\n{\r\n    int j = -1; // is to find the next non zero element\r\n    // i signifies that upto here all elements are non-zero\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        if (nums[i] != 0)\r\n            continue;\r\n        if (j == -1)\r\n            j = i + 1;\r\n        int nxt_non0 = next_nonzero(nums, j);\r\n        if (nxt_non0 == -1)\r\n            return;\r\n        swap(nums[i], nums[nxt_non0]);\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) (",
          "worst": "O(n) ("
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < nums.size()",
        "while (j < a.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\07.Move_0's_to_end.cpp",
      "verified": false,
      "needsReview": false
    },
    "linear-search": {
      "id": "linear-search",
      "title": "Linear search",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\08.Linear_search.cpp",
      "verified": false,
      "needsReview": true
    },
    "union-of-2-sorted-arrays": {
      "id": "union-of-2-sorted-arrays",
      "title": "Union of 2 sorted arrays",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Union of two arrays can be defined as the common and distinct elements in the two arrays.\r\nGiven two sorted arrays of size n and m respectively, find their union.\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\nn = 5, arr1[] = {1, 2, 3, 4, 5}\r\nm = 3, arr2 [] = {1, 2, 3}\r\nOutput: 1 2 3 4 5\r\nExplanation: Distinct elements including\r\nboth the arrays are: 1 2 3 4 5.\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\nn = 5, arr1[] = {2, 2, 3, 4, 5}\r\nm = 5, arr2[] = {1, 1, 2, 3, 4}\r\nOutput: 1 2 3 4 5\r\nExplanation: Distinct elements including\r\nboth the arrays are: 1 2 3 4 5.",
      "approach": "-\r\n-> Take two pointer i and j where i is for arr1 and j is for arr2 and traverse\r\n-> While travsersing 3 cases arises\r\n    -> arr1[ i ] == arr2[ j ]\r\n        Here we found a common element, so insert only one element in the union.\r\n        Let’s insert arr[i] in union and whenever we insert element we increment pointer while pointer is not equal to the inserted element\r\n    -> arr1[i]<arr2[j]\r\n        Here insert arr[i]\r\n    -> arr1[i]>arr2[j]\r\n        Here insert arr2[j]\r\n-> Now check if elements of any array is left to traverse then traverse that array",
      "code": "vector<int> findUnion(int arr1[], int arr2[], int n, int m)\r\n{\r\n    int i = 0; // i to keep track in arr1\r\n    int j = 0; // j to keep track in arr2\r\n    vector<int> ans;\r\n\r\n    while (i < n && j < m)\r\n    {\r\n\r\n        if (arr1[i] < arr2[j])\r\n        {\r\n            ans.push_back(arr1[i++]);\r\n            while (i < n && arr1[i] == arr1[i - 1])\r\n                i++;\r\n        }\r\n        else if (arr2[j] < arr1[i])\r\n        {\r\n            ans.push_back(arr2[j++]);\r\n            while (j < m && arr2[j] == arr2[j - 1])\r\n                j++;\r\n        }\r\n        // means arr1[i] = arr2[j] in that case we can insert anyone\r\n        else\r\n        {\r\n            ans.push_back(arr1[i++]);\r\n            j++;\r\n            while (i < n && arr1[i] == arr1[i - 1])\r\n                i++;\r\n            while (j < m && arr2[j] == arr2[j - 1])\r\n                j++;\r\n        }\r\n    }\r\n\r\n    while (i < n)\r\n    {\r\n        ans.push_back(arr1[i++]);\r\n        while (i < n && arr1[i] == arr1[i - 1])\r\n            i++;\r\n    }\r\n    while (j < m)\r\n    {\r\n        ans.push_back(arr2[j++]);\r\n        while (j < m && arr2[j] == arr2[j - 1])\r\n            j++;\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(N+M) //",
          "worst": "O(N+M) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "while (i < n && j < m)",
        "while (i < n && arr1[i] == arr1[i - 1])",
        "while (j < m && arr2[j] == arr2[j - 1])",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\09.Union_of_2_sorted_arrays.cpp",
      "verified": false,
      "needsReview": false
    },
    "missing-number": {
      "id": "missing-number",
      "title": "Missing number",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,0,1]\r\nOutput: 2\r\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\r\nExample 2:\r\n\r\nInput: nums = [0,1]\r\nOutput: 2\r\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.",
      "approach": "-\r\n-> Calculate the optimum sum i.e. sum when all elements were present\r\n-> Calculate the actual array's sum\r\n-> Return the optimum sum - actual sum",
      "code": "int missingNumber(vector<int> &nums)\r\n{\r\n    int n = nums.size();\r\n    long long optimum_sum = (n * (n + 1)) / 2; // the sum if no number is absent\r\n    long long actual_sum = 0;\r\n    for (auto it : nums)\r\n    {\r\n        actual_sum += it;\r\n    }\r\n    return optimum_sum - actual_sum;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (auto it : nums)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\10.Missing_number.cpp",
      "verified": false,
      "needsReview": false
    },
    "max-consecutive-1-s": {
      "id": "max-consecutive-1-s",
      "title": "Max Consecutive 1's",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\r\n\r\nExample 1:\r\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\r\nOutput: 6\r\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\r\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.",
      "approach": "1. Initialize variables zeroCnt, start, and ans.\r\n2. Iterate through the array nums:\r\n   - If the current element is 0, increment zeroCnt.\r\n   - Enter a while loop to adjust the start index until zeroCnt becomes less than or equal to k.\r\n   - During the adjustment, decrement zeroCnt if the element at the start index is 0.\r\n   - Update ans by taking the maximum of the current ans and the length of the current subarray if zeroCnt is less than or equal to k.\r\n3. Return the maximum length of consecutive 1's (ans).\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint longestOnes(vector<int>& nums, int k) {\r\n    int zeroCnt = 0, start = 0, ans = 0;\r\n    for(int i = 0; i < nums.size(); i++) {\r\n        if(nums[i] == 0)\r\n            zeroCnt++;\r\n        while(zeroCnt > k) {\r\n            if(nums[start] == 0)\r\n                zeroCnt--;\r\n            start++;\r\n        }\r\n        if(zeroCnt <= k)\r\n            ans = max(ans, i - start + 1);\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(N), where N is the length of the input array nums. We iterate through the array once.\r\n- Space complexity: O(1), as we are using a constant amount of additional space to store variables.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for(int i = 0; i < nums.size()",
        "while(zeroCnt > k)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\02. Max Consecutive 1's.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-subarray-with-given-sum": {
      "id": "longest-subarray-with-given-sum",
      "title": "Longest subarray with given sum",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "You are given an array 'A' of size 'N' and an integer 'K'. You need to print the length of the longest subarray of array 'A' whose sum = 'K'.\r\nExample:\r\nInput: 'N' = 7 'K' = 3\r\n'A' = [1, 2, 3, 1, 1, 1, 1]\r\nOutput: 3\r\nExplanation: Subarrays whose sum = '3' are:\r\n[1, 2], [3], [1, 1, 1], [1, 1, 1]\r\nHere, the length of the longest subarray is 3, which is our final answer.",
      "approach": "-\r\n-> Use sliding window approach using two pointers start and end\r\n-> Run a loop to traverse the entire array add from end and subtract from start when sum>k\r\n-> If sum==k then, update the ans now, window size = end-start+1",
      "code": "int longestSubarrayWithSumK(vector<int> a, long long k)\r\n{\r\n    int start = 0;\r\n    int ans = 0;\r\n    long long sum = 0;\r\n    int n = a.size();\r\n\r\n    for (int end = 0; end < n; end++)\r\n    {\r\n        sum += a[end];\r\n        while (sum > k)\r\n        {\r\n            sum -= a[start];\r\n            start++;\r\n        }\r\n        if (sum == k)\r\n        {\r\n            ans = max(ans, end - start + 1);\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int end = 0; end < n; end++)",
        "while (sum > k)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\12.Longest_subarray_with_given_sum.cpp",
      "verified": false,
      "needsReview": false
    },
    "find-element-present-only-once": {
      "id": "find-element-present-only-once",
      "title": "Find element present only once",
      "category": "arrays",
      "difficulty": "easy",
      "problemStatement": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\r\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\r\n\r\n\r\nExample 1:\r\nInput: nums = [2,2,1]\r\nOutput: 1\r\n\r\nExample 2:\r\nInput: nums = [4,1,2,1,2]\r\nOutput: 4",
      "approach": "-\r\n-> We can use XOR operation as we know xor cancles out the same elements\r\n-> Intial xr=0 then traverse the entire array and xor each element with xr\r\n-> Since only one element is present once and all other are present twice so the remaining element would be the\r\n    one which is present only once cause all other gets cancels out",
      "code": "int singleNumber(vector<int> &nums)\r\n{\r\n    int xr = 0;\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        xr = nums[i] ^ xr;\r\n    }\r\n    return xr;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\1.Easy\\13.Find_element_present_only_once.cpp",
      "verified": false,
      "needsReview": false
    },
    "2-sum-problem": {
      "id": "2-sum-problem",
      "title": "2 sum problem",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "",
      "approach": "-> Create an empty map to store the elements and their corresponding indices.\r\n>  Iterate through the input array, nums, and for each element:\r\n    Calculate the complement by subtracting the current element from the target value.\r\n    Check if the complement exists in the map.\r\n    If the complement exists, return the indices of the current element and the complement.\r\n    If the complement does not exist, add the current element and its index to the map.\r\n-> If no solution is found, return an empty vector or a message indicating no solution exists.",
      "code": "vector<int> twoSum(vector<int> &nums, int target)\r\n{\r\n    unordered_map<int, int> mp;\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        int remain = target - nums[i];\r\n        if (mp.find(remain) != mp.end() && mp[remain] != i)\r\n            return {i, mp[remain]};\r\n        mp[nums[i]] = i;\r\n    }\r\n    return {-1, -1};\r\n    // If the question asks to just return whether pair exists or not, not the indexes in that case we can sort and easily find the pair sum without extra space\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(n)",
          "worst": "O(n)"
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < nums.size()",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\01.2_sum_problem.cpp",
      "verified": false,
      "needsReview": false
    },
    "sort-0-1-2": {
      "id": "sort-0-1-2",
      "title": "Sort 0 1 2",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\r\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\r\nYou must solve this problem without using the library's sort function.\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,0,2,1,1,0]\r\nOutput: [0,0,1,1,2,2]\r\n\r\nExample 2:\r\n\r\nInput: nums = [2,0,1]\r\nOutput: [0,1,2]",
      "approach": "-\r\n-> Initialize three pointers: low at the beginning of the array, mid at the beginning of the array, and high at the end of the array.\r\n-> Iterate through the array while the mid pointer is less than or equal to the high pointer:\r\n1. If the current element at the mid pointer is 0 (red), we swap it with the element at the low pointer and increment both low and mid pointers. This ensures that red elements are moved to the left side of the array.\r\n2. If the current element at the mid pointer is 1 (white), we simply increment the mid pointer. This keeps white elements in the middle of the array.\r\n3. If the current element at the mid pointer is 2 (blue), we swap it with the element at the high pointer and decrement the high pointer. This ensures that blue elements are moved to the right side of the array.\r\n\r\nRepeat step 2 until the mid pointer crosses the high pointer.\r\nAt the end of the algorithm, the array will be sorted in the desired order.",
      "code": "void sortColors(vector<int> &nums)\r\n{\r\n    int low = 0, mid = 0, high = nums.size() - 1;\r\n    while (mid <= high)\r\n    {\r\n        if (nums[mid] == 0)\r\n            swap(nums[mid++], nums[low++]);\r\n        else if (nums[mid] == 1)\r\n            mid++;\r\n        else\r\n            swap(nums[mid], nums[high--]);\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while (mid <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\02.Sort_0_1_2.cpp",
      "verified": false,
      "needsReview": false
    },
    "majority-element": {
      "id": "majority-element",
      "title": "Majority element",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an array nums of size n, return the majority element.\r\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,2,3]\r\nOutput: 3\r\n\r\nExample 2:\r\n\r\nInput: nums = [2,2,1,1,1,2,2]\r\nOutput: 2",
      "approach": "",
      "code": "int majorityElement(vector<int> &nums)\r\n{\r\n    int candidate = nums[0];\r\n    int vote = 1;\r\n    for (int i = 1; i < nums.size(); i++)\r\n    {\r\n        if (vote <= 0)\r\n            candidate = nums[i];\r\n        if (nums[i] == candidate)\r\n            vote++;\r\n        else\r\n            vote--;\r\n    }\r\n    return candidate;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int i = 1; i < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\03.Majority_element.cpp",
      "verified": false,
      "needsReview": false
    },
    "kadane-s-algorithm": {
      "id": "kadane-s-algorithm",
      "title": "Kadane's algorithm",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\r\nOutput: 6\r\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\r\n\r\nExample 2:\r\n\r\nInput: nums = [1]\r\nOutput: 1\r\nExplanation: The subarray [1] has the largest sum 1.",
      "approach": "-\r\n-> Initialize two variables: maxSum and currentSum. Set both variables to the first element of the array.\r\n-> Iterate through the array starting from the second element:\r\n    Update currentSum by adding the current element to it.\r\n    If currentSum becomes negative, reset it to 0. This step ensures that we consider only the subarrays with positive sums.\r\n    Update maxSum by taking the maximum value between maxSum and currentSum. This keeps track of the maximum subarray sum encountered so far.\r\n-> After the iteration, the maxSum variable will hold the largest sum of any subarray.\r\n-> Return the maxSum as the result.",
      "code": "int maxSubArray(vector<int> &nums)\r\n{\r\n    int curr_sum = 0;\r\n    int ans = INT_MIN;\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        curr_sum += nums[i];\r\n        ans = max(ans, curr_sum);\r\n        if (curr_sum < 0)\r\n            curr_sum = 0;\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\04.Kadane's_algorithm.cpp",
      "verified": false,
      "needsReview": false
    },
    "number-of-subarray-sum-equal-k": {
      "id": "number-of-subarray-sum-equal-k",
      "title": "Number of subarray sum equal k",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\r\n\r\nExample:\r\nInput: nums = [1,1,1], k = 2\r\nOutput: 2",
      "approach": "To find the total number of subarrays with sum equal to k, we can use the technique of prefix sum along with a hashmap.\r\n1. Initialize a variable `count` to keep track of the count of subarrays with sum equal to k.\r\n2. Initialize a variable `prefixSum` to keep track of the prefix sum while iterating through the array.\r\n3. Initialize a hashmap `sumCount` to store the frequency of prefix sums encountered so far.\r\n4. Set the initial prefix sum to 0 and set its count to 1 in the `sumCount` hashmap.\r\n5. Iterate through the array and update the prefix sum by adding each element.\r\n6. Check if the current prefix sum minus k exists in the `sumCount` hashmap. If it does, add the count of that prefix sum to the `count` variable.\r\n7. Increment the count of the current prefix sum in the `sumCount` hashmap.\r\n8. Finally, return the `count` variable as the total number of subarrays with sum equal to k.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint subarraySum(vector<int> &nums, int k)\r\n{\r\n    int pref_sum = 0;\r\n    unordered_map<int, int> mp;\r\n    int ans = 0;\r\n\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        pref_sum += nums[i];\r\n\r\n        if (pref_sum == k)\r\n            ans++;\r\n\r\n        if (mp.find(pref_sum - k) != mp.end())\r\n        {\r\n            ans += mp[pref_sum - k];\r\n        }\r\n\r\n        mp[pref_sum]++;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(n), where n is the size of the input array nums.\r\nSPACE COMPLEXITY: O(n), as we are using a hashmap to store the prefix sums and their corresponding counts.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for (int i = 0; i < nums.size()",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\05.Number_of_subarray_sum_equal_k.cpp",
      "verified": false,
      "needsReview": true
    },
    "stock-buy-sell": {
      "id": "stock-buy-sell",
      "title": "Stock buy sell",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\r\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\r\n\r\nExample 1:\r\n\r\nInput: prices = [7,1,5,3,6,4]\r\nOutput: 5\r\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\r\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\r\n\r\nExample 2:\r\n\r\nInput: prices = [7,6,4,3,1]\r\nOutput: 0\r\nExplanation: In this case, no transactions are done and the max profit = 0.",
      "approach": "-\r\nInitialize two variables: min_price and max_profit.\r\n\r\n-> min_price = minimum price in the array.\r\n-> max_profit = 0.\r\n\r\nIterate through the array, and for each price:\r\n\r\n-> Update min_price to the minimum price seen so far.\r\n-> Update max_profit to the maximum profit seen so far, or the current price minus min_price, whichever is greater.\r\n\r\nReturn max_profit.",
      "code": "int maxProfit(vector<int> &prices)\r\n{\r\n    int minprice = prices[0];\r\n    int ans = 0;\r\n    for (int i = 1; i < prices.size(); i++)\r\n    {\r\n        ans = max(ans, prices[i] - minprice);\r\n        minprice = min(minprice, prices[i]);\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int i = 1; i < prices.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\06.Stock_buy_sell.cpp",
      "verified": false,
      "needsReview": false
    },
    "rearange-elements-by-sign": {
      "id": "rearange-elements-by-sign",
      "title": "Rearange elements by sign",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\r\nYou should rearrange the elements of nums such that the modified array follows the given conditions:\r\nEvery consecutive pair of integers have opposite signs.\r\nFor all integers with the same sign, the order in which they were present in nums is preserved.\r\nThe rearranged array begins with a positive integer.\r\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.\r\n\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,1,-2,-5,2,-4]\r\nOutput: [3,-2,1,-5,2,-4]\r\nExplanation:\r\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\r\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\r\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.",
      "approach": "-\r\nInitialize two pointers, pos_ptr and neg_ptr. pos_ptr will point to the first positive integer in the array, and neg_ptr will point to the first negative integer in the array.\r\nIterate over the array.\r\nIf the current integer is positive, swap it with the element at neg_ptr.\r\nIncrement pos_ptr by 1.\r\nIncrement neg_ptr by 1.\r\nRepeat steps 3-5 until the end of the array is reached.\r\nThe array will now be rearranged such that every consecutive pair of integers have opposite signs.",
      "code": "vector<int> rearrangeArray(vector<int> &nums)\r\n{\r\n    int i = 0; // for +ve integers\r\n    int j = 1; // for -ve integers\r\n    vector<int> ans(nums.size());\r\n    for (int k = 0; k < nums.size(); k++)\r\n    {\r\n        if (nums[k] >= 0)\r\n        {\r\n            ans[i] = nums[k];\r\n            i += 2;\r\n        }\r\n        else\r\n        {\r\n            ans[j] = nums[k];\r\n            j += 2;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(n) //",
          "worst": "O(n) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int k = 0; k < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\07.Rearange_elements_by_sign.cpp",
      "verified": false,
      "needsReview": false
    },
    "next-permutation": {
      "id": "next-permutation",
      "title": "Next permutation",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\r\n\r\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\r\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\r\n\r\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\r\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\r\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\r\n\r\nGiven an array of integers nums, find the next permutation of nums.\r\n\r\nThe replacement must be in place and use only constant extra memory.\r\n\r\nExample 1:\r\nInput: nums = [1,2,3]\r\nOutput: [1,3,2]",
      "approach": "-\r\n\r\nTo find the next permutation of an array, we can follow these steps:\r\n\r\n1. Find the first index `i` from the right such that `nums[i] < nums[i+1]`. This is the first element that needs to be swapped.\r\n2. Find the first index `j` from the right such that `nums[j] > nums[i]`. This is the element that will replace `nums[i]`.\r\n3. Swap `nums[i]` and `nums[j]`.\r\n4. Reverse the subarray starting from `i+1` till the end of the array.\r\n5. If step 1 does not find any index `i`, it means the array is in descending order. In that case, reverse the entire array to get the lowest possible order.",
      "code": "void nextPermutation(vector<int> &nums)\r\n{\r\n\r\n    int bp = -1;\r\n    // finding the break point\r\n    for (int i = nums.size() - 2; i >= 0; i--)\r\n    {\r\n        if (nums[i] < nums[i + 1])\r\n        {\r\n            bp = i;\r\n            break;\r\n        }\r\n    }\r\n    // first greater element from back\r\n    if (bp != -1)\r\n    {\r\n        for (int i = nums.size() - 1; i >= 0; i--)\r\n        {\r\n            if (nums[i] > nums[bp])\r\n            {\r\n                swap(nums[i], nums[bp]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // reverse the array from bp+1 to end\r\n    reverse(nums.begin() + bp + 1, nums.end());\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = nums.size()",
        "for (int i = nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\08.Next_permutation.cpp",
      "verified": false,
      "needsReview": true
    },
    "leaders-in-array": {
      "id": "leaders-in-array",
      "title": "Leaders in array",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an array A of positive integers. Your task is to find the leaders in the array. An element of the array is a leader if it is greater than or equal to all the elements to its right side. The rightmost element is always a leader.\r\n\r\nExample 1:\r\nInput:\r\nn = 6\r\nA[] = {16,17,4,3,5,2}\r\nOutput: 17 5 2\r\nExplanation: The first leader is 17 as it is greater than all the elements to its right. Similarly, the next leader is 5. The rightmost element is always a leader, so it is also included.",
      "approach": "-\r\n\r\nTo find the leaders in the array, we can follow these steps:\r\n\r\n1. Initialize a variable `maxRight` with the rightmost element of the array.\r\n2. Iterate the array from right to left:\r\n   - If the current element is greater than or equal to `maxRight`, it is a leader. Print the current element and update `maxRight` to the current element.\r\n3. Finally, print `maxRight` as it is always a leader.",
      "code": "vector<int> leaders(int a[], int n)\r\n{\r\n    vector<int> ans;\r\n    ans.push_back(a[n - 1]);\r\n    int maxi = a[n - 1]; // represent maximum encountered till now\r\n\r\n    for (int i = n - 2; i >= 0; i--)\r\n    {\r\n        if (a[i] >= maxi)\r\n        {\r\n            ans.push_back(a[i]);\r\n            maxi = a[i];\r\n        }\r\n    }\r\n\r\n    reverse(ans.begin(), ans.end());\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int i = n - 2; i >= 0; i--)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\09.Leaders_in_array.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-consecutive-subsequence": {
      "id": "longest-consecutive-subsequence",
      "title": "Longest consecutive subsequence",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\r\n\r\nExample 1:\r\nInput: nums = [100,4,200,1,3,2]\r\nOutput: 4\r\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\r\n\r\nExample 2:\r\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\r\nOutput: 9",
      "approach": "-\r\n\r\nTo find the length of the longest consecutive elements sequence, we can follow these steps:\r\n\r\n1. Create a set to store all the elements of the array.\r\n2. Iterate through the array and insert each element into the set.\r\n3. For each element, check if its previous consecutive element (num-1) exists in the set. If it does not exist, it means the current element is the starting element of a sequence.\r\n4. For each starting element, keep incrementing the current element (num+1) and checking if it exists in the set. This will help find the consecutive elements in the sequence.\r\n5. Keep track of the maximum length of consecutive elements encountered.\r\n6. Return the maximum length as the result.",
      "code": "int longestConsecutive(vector<int> &nums)\r\n{\r\n    unordered_map<int, int> mp;\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        mp[nums[i]]++;\r\n    }\r\n    int ans = 0;\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        int start = nums[i];\r\n        // check whehter this can be the start of the subsequence\r\n        if (mp.find(nums[i] - 1) == mp.end())\r\n        {\r\n            int temp = 1;\r\n            int nxt = nums[i];\r\n            while (mp.find(nxt + 1) != mp.end())\r\n            {\r\n                temp++;\r\n                nxt++;\r\n            }\r\n            ans = max(ans, temp);\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for (int i = 0; i < nums.size()",
        "for (int i = 0; i < nums.size()",
        "while (mp.find(nxt + 1)",
        ".find(",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\10.Longest_consecutive_subsequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "set-matrix-0-s": {
      "id": "set-matrix-0-s",
      "title": "Set matrix 0's",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\r\n\r\nExample 1:\r\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\r\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\r\n\r\nExample 2:\r\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\r\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
      "approach": "To solve this problem in-place, we can follow these steps:\r\n1. Use two boolean variables, firstRowZero and firstColZero, to check if the first row and first column contain zeros initially.\r\n2. Iterate through the matrix and if an element is zero, set the corresponding element in the first row and first column to zero.\r\n3. Iterate through the matrix again, excluding the first row and first column. If an element in the first row or first column is zero, set the current element to zero.\r\n4. Finally, based on the values in firstRowZero and firstColZero, set the first row and first column to zero if needed.\r\n\r\nTIME COMPLEXITY: O(m * n), where m and n are the dimensions of the matrix.\r\nSPACE COMPLEXITY: O(1), as we are using constant extra space.",
      "code": "void setZeroes(vector<vector<int>>& matrix) {\r\n    int m = matrix.size();\r\n    int n = matrix[0].size();\r\n    bool firstRowZero = false;\r\n    bool firstColZero = false;\r\n\r\n    // Check if the first row contains zero\r\n    for (int j = 0; j < n; j++) {\r\n        if (matrix[0][j] == 0) {\r\n            firstRowZero = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Check if the first column contains zero\r\n    for (int i = 0; i < m; i++) {\r\n        if (matrix[i][0] == 0) {\r\n            firstColZero = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Mark zeros in the first row and column\r\n    for (int i = 1; i < m; i++) {\r\n        for (int j = 1; j < n; j++) {\r\n            if (matrix[i][j] == 0) {\r\n                matrix[i][0] = 0;\r\n                matrix[0][j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set rows to zero\r\n    for (int i = 1; i < m; i++) {\r\n        if (matrix[i][0] == 0) {\r\n            for (int j = 1; j < n; j++) {\r\n                matrix[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set columns to zero\r\n    for (int j = 1; j < n; j++) {\r\n        if (matrix[0][j] == 0) {\r\n            for (int i = 1; i < m; i++) {\r\n                matrix[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set first row to zero\r\n    if (firstRowZero) {\r\n        for (int j = 0; j < n; j++) {\r\n            matrix[0][j] = 0;\r\n        }\r\n    }\r\n\r\n    // Set first column to zero\r\n    if (firstColZero) {\r\n        for (int i = 0; i < m; i++) {\r\n            matrix[i][0] = 0;\r\n        }\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "for (int j = 0; j < n; j++)",
        "for (int i = 0; i < m; i++)",
        "for (int i = 1; i < m; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\11.Set_matrix_0's.cpp",
      "verified": false,
      "needsReview": true
    },
    "rotate-matrix": {
      "id": "rotate-matrix",
      "title": "Rotate matrix",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\r\n\r\nExample 1:\r\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\r\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\r\n\r\nExample 2:\r\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\r\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
      "approach": "-\r\n\r\nTo rotate the image by 90 degrees clockwise in-place, we can follow these steps:\r\n\r\n1. Transpose the matrix: Iterate over the matrix and swap each element (i, j) with its corresponding element (j, i). This step transforms rows into columns.\r\n\r\n2. Reverse each row: Iterate over each row in the transposed matrix and reverse the elements. This step ensures the rotation in a clockwise direction.",
      "code": "void rotate(vector<vector<int>>& matrix) {\r\n    // Transpose the matrix\r\n    int n = matrix.size();\r\n    int m = matrix[0].size();\r\n    for(int i=0; i<n; i++){\r\n        // note here we move \r\n        for(int j=0; j<i; j++){\r\n            swap(matrix[i][j],matrix[j][i]);\r\n        }\r\n    }\r\n\r\n    // Reverse each row\r\n    for(int i=0; i<n; i++){\r\n        reverse(matrix[i].begin(),matrix[i].end());\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": "O(N",
          "worst": "O(N"
        },
        "space": {
          "average": "O(1)",
          "worst": "O(1)"
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int j=0; j<i; j++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\12.Rotate_matrix.cpp",
      "verified": false,
      "needsReview": false
    },
    "spiral-traversal": {
      "id": "spiral-traversal",
      "title": "Spiral traversal",
      "category": "arrays",
      "difficulty": "medium",
      "problemStatement": "Given an m x n matrix, return all elements of the matrix in spiral order.\r\n\r\nExample 1:\r\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\r\nOutput: [1,2,3,6,9,8,7,4,5]\r\n\r\nExample 2:\r\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\r\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
      "approach": "-\r\n\r\nTo traverse the matrix in a spiral order, we can use the following steps:\r\n\r\n1. Initialize four variables: top, bottom, left, and right to keep track of the boundaries of the current spiral.\r\n2. Create an empty vector called 'ans' to store the elements in spiral order.\r\n3. While the top boundary is less than or equal to the bottom boundary and the left boundary is less than or equal to the right boundary:\r\n   - Traverse the top row from left to right and add each element to 'ans'.\r\n   - Increment the top boundary.\r\n   - Traverse the right column from top to bottom and add each element to 'ans'.\r\n   - Decrement the right boundary.\r\n   - Check if the top boundary is still less than or equal to the bottom boundary:\r\n     - Traverse the bottom row from right to left and add each element to 'ans'.\r\n     - Decrement the bottom boundary.\r\n   - Check if the left boundary is still less than or equal to the right boundary:\r\n     - Traverse the left column from bottom to top and add each element to 'ans'.\r\n     - Increment the left boundary.\r\n4. Return the 'ans' vector containing all the elements in spiral order.",
      "code": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n    int n = matrix.size(); \r\n    int m = matrix[0].size();\r\n    int top = 0, bottom = n - 1;\r\n    int left = 0, right = m - 1;\r\n    vector<int> ans;\r\n\r\n    while (top <= bottom && left <= right) {\r\n        // Traverse top row\r\n        for (int i = left; i <= right; i++) {\r\n            ans.push_back(matrix[top][i]);\r\n        }\r\n        top++;\r\n\r\n        // Traverse right column\r\n        for (int i = top; i <= bottom; i++) {\r\n            ans.push_back(matrix[i][right]);\r\n        }\r\n        right--;\r\n\r\n        // Traverse bottom row\r\n        if (top <= bottom) {\r\n            for (int i = right; i >= left; i--) {\r\n                ans.push_back(matrix[bottom][i]);\r\n            }\r\n            bottom--;\r\n        }\r\n\r\n        // Traverse left column\r\n        if (left <= right) {\r\n            for (int i = bottom; i >= top; i--) {\r\n                ans.push_back(matrix[i][left]);\r\n            }\r\n            left++;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for (int i = left; i <= right; i++)",
        "for (int i = top; i <= bottom; i++)",
        "for (int i = right; i >= left; i--)",
        "while (top <= bottom && left <= right)",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\2.Medium\\13.Spiral_traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "pascal-triangle": {
      "id": "pascal-triangle",
      "title": "Pascal triangle",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "**\r\n\r\nGiven an integer `rowIndex`, return the `rowIndex`th (0-indexed) row of Pascal's triangle.\r\n\r\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\r\n\r\nExample:\r\n\r\nInput: `rowIndex = 3`\r\n\r\nOutput: `[1, 3, 3, 1]`",
      "approach": "**\r\nTo generate the `rowIndex`th row of Pascal's triangle, we can use the property that each number is the sum of the two numbers directly above it. We start with the base case of the first row, which is `[1]`. Then, for each subsequent row, we calculate the elements using the formula `C(n, k) = C(n-1, k-1) * (n-k+1) / k`, where `C(n, k)` represents the binomial coefficient.\r\n\r\n**CODE:**",
      "code": "**\r\n*/\r\n\r\nvector<int> getRow(int rowIndex) {\r\n    vector<int> row(rowIndex + 1, 1); // Initialize the row with 1s\r\n    long long coefficient = 1;\r\n    \r\n    for (int col = 1; col <= rowIndex; col++) {\r\n        coefficient = coefficient * (rowIndex - col + 1) / col;\r\n        row[col] = coefficient;\r\n    }\r\n    \r\n    return row;\r\n}\r\n\r\n/*\r\n**COMPLEXITY ANALYSIS:**\r\n- Time Complexity: O(rowIndex)\r\n  - We iterate over each element in the row and calculate its value using the binomial coefficient formula.\r\n- Space Complexity: O(rowIndex)\r\n  - We use additional space to store the row of Pascal's triangle.\r\n\r\nOverall, the algorithm has a linear time complexity and linear space complexity.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int col = 1; col <= rowIndex; col++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\01.Pascal_triangle.cpp",
      "verified": false,
      "needsReview": true
    },
    "majority-element-2": {
      "id": "majority-element-2",
      "title": "Majority element 2",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\r\n\r\nExample 1:\r\nInput: nums = [3,2,3]\r\nOutput: [3]\r\n\r\nExample 2:\r\nInput: nums = [1]\r\nOutput: [1]",
      "approach": "To find all elements that appear more than ⌊ n/3 ⌋ times, we can use the Boyer-Moore Majority Vote algorithm. This algorithm helps us find potential candidates that could appear more than ⌊ n/3 ⌋ times in a single pass. After finding the candidates, we count their occurrences and return the elements that meet the criteria.\r\n\r\n1. Initialize two candidate variables, c1 and c2, and their corresponding vote counters, vote1 and vote2.\r\n2. Iterate through the array:\r\n   - If the current element matches c1, increment vote1.\r\n   - Else if the current element matches c2, increment vote2.\r\n   - Else if vote1 is 0, assign the current element to c1 and set vote1 to 1.\r\n   - Else if vote2 is 0, assign the current element to c2 and set vote2 to 1.\r\n   - Else, decrement both vote1 and vote2.\r\n3. After finding the potential candidates, count the occurrences of each candidate using cnt1 and cnt2.\r\n4. If cnt1 is greater than ⌊ n/3 ⌋, add c1 to the result vector.\r\n5. If cnt2 is greater than ⌊ n/3 ⌋ and c2 is different from c1, add c2 to the result vector.\r\n6. Return the result vector containing the elements that appear more than ⌊ n/3 ⌋ times.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\02.Majority_element_2.cpp",
      "verified": false,
      "needsReview": true
    },
    "3-sum": {
      "id": "3-sum",
      "title": "3 sum",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\r\n\r\nExample:\r\nInput: nums = [-1,0,1,2,-1,-4]\r\nOutput: [[-1,-1,2],[-1,0,1]]\r\nExplanation:\r\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\r\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\r\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\r\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\r\nNotice that the order of the output and the order of the triplets does not matter.",
      "approach": "To find all triplets that sum up to zero, we can follow these steps:\r\n1. Sort the input array in non-decreasing order.\r\n2. Iterate through the array and fix the first element as nums[k] (where k = 0 to n-1).\r\n3. Use two pointers (i and j) to find the other two elements such that nums[i] + nums[j] = -nums[k].\r\n4. Move the pointers accordingly to find all possible triplets.\r\n5. Skip duplicate elements to avoid duplicate triplets.\r\n6. Return the resulting triplets.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\03.3_sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "4-sum": {
      "id": "4-sum",
      "title": "4 sum",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\r\n- 0 <= a, b, c, d < n\r\n- a, b, c, and d are distinct.\r\n- nums[a] + nums[b] + nums[c] + nums[d] == target\r\n\r\nExample:\r\nInput: nums = [1,0,-1,0,-2,2], target = 0\r\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
      "approach": "To find the unique quadruplets that sum up to the target, we can use a similar approach as the threeSum problem. We will fix two elements (nums[a] and nums[b]) and use two pointers to find the remaining two elements (nums[c] and nums[d]) that sum up to the target.\r\n\r\n1. Sort the input array nums in ascending order.\r\n2. Iterate through the array with two pointers: a and b.\r\n3. For each pair of elements nums[a] and nums[b], use two pointers c and d to find the remaining two elements that sum up to the target.\r\n   - Initialize c as b + 1 and d as the last index of the array.\r\n   - Calculate the target sum as trgt = target - (nums[a] + nums[b]).\r\n   - While c < d, compare the sum of nums[c] and nums[d] with the target sum.\r\n     - If the sum is equal to the target sum, we found a quadruplet. Add it to the answer and move the pointers c and d.\r\n       - Important: Skip any duplicate elements while moving c and d.\r\n     - If the sum is greater than the target sum, decrement d.\r\n     - If the sum is less than the target sum, increment c.\r\n4. Skip any duplicate elements for pointers a and b to avoid duplicate quadruplets.\r\n5. Return the answer array containing unique quadruplets.\r\n\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<vector<int>> fourSum(vector<int> &nums, int target)\r\n{\r\n    vector<vector<int>> ans;\r\n    long long trgt = (long long)(target); // to handle overflow\r\n    sort(nums.begin(), nums.end());\r\n\r\n    for (int a = 0; a < nums.size(); a++)\r\n    {\r\n        for (int b = a + 1; b < nums.size(); b++)\r\n        {\r\n            if (a == b)\r\n                continue;\r\n\r\n            int c = b + 1;\r\n            int d = nums.size() - 1;\r\n            long long tar = trgt - (nums[a] + nums[b]);\r\n\r\n            while (c < d)\r\n            {\r\n                long long sum = nums[c] + nums[d];\r\n\r\n                if (sum == tar)\r\n                {\r\n                    ans.push_back({nums[a], nums[b], nums[c], nums[d]});\r\n                    c++;\r\n                    d--;\r\n\r\n                    // Skip duplicate elements\r\n                    while (c < d && nums[c] == nums[c - 1])\r\n                        c++;\r\n                    while (c < d && nums[d] == nums[d + 1])\r\n                        d--;\r\n                }\r\n                else if (sum > tar)\r\n                {\r\n                    d--;\r\n                }\r\n                else\r\n                {\r\n                    c++;\r\n                }\r\n            }\r\n\r\n            // Skip duplicate elements\r\n            while (b + 1 < nums.size() && nums[b + 1] == nums[b])\r\n                b++;\r\n        }\r\n\r\n        // Skip duplicate elements\r\n        while (a + 1 < nums.size() && nums[a + 1] == nums[a])\r\n            a++;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(n^3), where n is the size of the input array nums.\r\nSPACE COMPLEXITY: O(1), as we are using a constant amount of extra space.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "for (int a = 0; a < nums.size()",
        "for (int b = a + 1; b < nums.size()",
        "while (c < d)",
        "while (c < d && nums[c] == nums[c - 1])",
        "while (c < d && nums[d] == nums[d + 1])",
        "sort(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\04.4_sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "largest-subarray-with-0sum": {
      "id": "largest-subarray-with-0sum",
      "title": "Largest subarray with 0sum",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array with both positive and negative integers, we need to compute the length of the largest subarray with a sum of 0.\r\n\r\nExample:\r\nInput:\r\nN = 8\r\nA[] = {15, -2, 2, -8, 1, 7, 10, 23}\r\nOutput: 5\r\nExplanation: The largest subarray with a sum of 0 will be -2, 2, -8, 1, 7.",
      "approach": "To find the length of the largest subarray with a sum of 0, we can use a technique called prefix sum.\r\n1. Create a prefix sum array of the same size as the input array.\r\n2. Initialize a map to store the prefix sum and its corresponding index. Initialize it with an entry for prefix sum 0 and index -1.\r\n3. Iterate through the input array and calculate the prefix sum by adding each element.\r\n4. For each prefix sum encountered, check if it exists in the map. If it does, update the answer by taking the maximum of the current answer and the difference between the current index and the index stored in the map for that prefix sum.\r\n5. If the prefix sum is not found in the map, add it to the map with its corresponding index.\r\n6. Finally, return the answer as the length of the largest subarray with a sum of 0.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint maxLen(vector<int> &A, int n)\r\n{\r\n    unordered_map<int, int> mp;\r\n    mp[0] = -1;\r\n    int pref_sum = 0;\r\n    int ans = 0;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        pref_sum += A[i];\r\n        if (mp.find(pref_sum) != mp.end())\r\n        {\r\n            ans = max(ans, i - mp[pref_sum]);\r\n        }\r\n        else\r\n        {\r\n            mp[pref_sum] = i;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(n), where n is the size of the input array A.\r\nSPACE COMPLEXITY: O(n), as we are using a map to store the prefix sums and their corresponding indices.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\05.Largest_subarray_with_0sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "subarrays-with-xor-k": {
      "id": "subarrays-with-xor-k",
      "title": "Subarrays with xor k",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array 'A' consisting of 'N' integers and an integer 'B', find the number of subarrays of array 'A' whose bitwise XOR of all elements is equal to 'B'.\r\n\r\nExample:\r\nInput: 'N' = 4, 'B' = 2\r\n'A' = [1, 2, 3, 2]\r\nOutput: 3\r\nExplanation: Subarrays have bitwise xor equal to '2' are: [1, 2, 3, 2], [2], [2].",
      "approach": "To find the number of subarrays with bitwise XOR equal to B, we can use the technique of prefix XOR along with a hashmap.\r\n1. Initialize a variable `prefixXOR` to keep track of the prefix XOR while iterating through the array.\r\n2. Initialize a variable `count` to keep track of the count of subarrays with XOR equal to B.\r\n3. Initialize a hashmap `xorCount` to store the frequency of prefix XOR values encountered so far.\r\n4. Set the initial prefix XOR to 0 and set its count to 1 in the `xorCount` hashmap.\r\n5. Iterate through the array and update the prefix XOR by XOR-ing each element.\r\n6. Check if the current prefix XOR is equal to B. If it is, increment the `count` variable.\r\n7. Check if the XOR of the current prefix XOR with B exists in the `xorCount` hashmap. If it does, add the count of that XOR value to the `count` variable.\r\n8. Increment the count of the current prefix XOR in the `xorCount` hashmap.\r\n9. Finally, return the `count` variable as the number of subarrays with XOR equal to B.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint subarraysWithSumK(vector<int> a, int b) {\r\n    int pref_xr = 0;\r\n    int ans = 0;\r\n    unordered_map<int, int> mp;\r\n    \r\n    for(int i = 0; i < a.size(); i++){\r\n        pref_xr = pref_xr ^ a[i];\r\n        \r\n        if(pref_xr == b)\r\n            ans++;\r\n        \r\n        if(mp.find(pref_xr ^ b) != mp.end()){\r\n            ans += mp[pref_xr ^ b];\r\n        }\r\n        \r\n        mp[pref_xr]++;\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(n), where n is the size of the input array a.\r\nSPACE COMPLEXITY: O(n), as we are using a hashmap to store the prefix XOR values and their corresponding counts.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for(int i = 0; i < a.size()",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\06.Subarrays_with_xor_k.cpp",
      "verified": false,
      "needsReview": true
    },
    "merge-overlapping-subinterval": {
      "id": "merge-overlapping-subinterval",
      "title": "Merge overlapping subinterval",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals and return an array of non-overlapping intervals that cover all the intervals in the input.\r\n\r\nExample 1:\r\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\r\nOutput: [[1,6],[8,10],[15,18]]\r\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
      "approach": "To merge overlapping intervals, we can follow these steps:\r\n1. Sort the intervals based on the start time.\r\n2. Initialize a vector `ans` to store the merged intervals.\r\n3. Add the first interval from the sorted intervals to the `ans` vector.\r\n4. Iterate through the remaining intervals:\r\n   - If the start time of the current interval is less than or equal to the end time of the last interval in the `ans` vector, it means they overlap. Update the end time of the last interval in the `ans` vector if necessary.\r\n   - If the start time of the current interval is greater than the end time of the last interval in the `ans` vector, it means they don't overlap. Add the current interval to the `ans` vector.\r\n5. Return the `ans` vector as the merged non-overlapping intervals.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n    sort(intervals.begin(), intervals.end());\r\n    vector<vector<int>> ans;\r\n    ans.push_back(intervals[0]);\r\n    \r\n    for(int i = 1; i < intervals.size(); i++){\r\n        if(ans.back()[1] >= intervals[i][0]){\r\n            ans.back()[1] = max(ans.back()[1], intervals[i][1]);\r\n        }\r\n        else{\r\n            ans.push_back(intervals[i]);\r\n        }\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(nlogn), where n is the number of intervals in the input.\r\nThe sorting step takes O(nlogn) time, and the merging step takes O(n) time.\r\nOverall, the time complexity is dominated by the sorting step.\r\nSPACE COMPLEXITY: O(n), where n is the number of intervals in the input.\r\nWe are using additional space to store the merged intervals in the `ans` vector.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "sorting"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<vector<int>",
        "for(int i = 1; i < intervals.size()",
        "sort(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\07.Merge_overlapping_subinterval.cpp",
      "verified": false,
      "needsReview": true
    },
    "merge-2-sorted-array-without-space": {
      "id": "merge-2-sorted-array-without-space",
      "title": "Merge 2 sorted array without space",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\r\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\r\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\r\n\r\nExample 1:\r\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\r\nOutput: [1,2,2,3,5,6]\r\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\r\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
      "approach": "To merge two sorted arrays, nums1 and nums2, into nums1, we can use a two-pointer approach.\r\n1. Initialize three pointers: i, j, and k, where i points to the last valid element of nums1, j points to the last element of nums2, and k points to the last index of the merged array nums1.\r\n2. Start from the end of the arrays and compare the elements at i and j.\r\n3. If the element at nums1[i] is greater than the element at nums2[j], swap it with the element at nums1[k], decrement i and k.\r\n4. Otherwise, swap the element at nums2[j] with the element at nums1[k], decrement j and k.\r\n5. Repeat steps 3 and 4 until all elements in nums1 and nums2 have been merged.\r\n6. If there are still elements remaining in nums2 after merging, copy them to the remaining positions in nums1.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int i = m - 1; // Pointer for nums1\r\n    int j = n - 1; // Pointer for nums2\r\n    int k = m + n - 1; // Pointer for merged array nums1\r\n    \r\n    while (i >= 0 && j >= 0) {\r\n        if (nums1[i] > nums2[j]) {\r\n            swap(nums1[i], nums1[k]);\r\n            i--;\r\n            k--;\r\n        } else {\r\n            swap(nums2[j], nums1[k]);\r\n            j--;\r\n            k--;\r\n        }\r\n    }\r\n    \r\n    // Copy remaining elements from nums2 to nums1 if any\r\n    while (j >= 0) {\r\n        swap(nums2[j], nums1[k]);\r\n        j--;\r\n        k--;\r\n    }\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(m + n), where m and n are the lengths of nums1 and nums2 respectively.\r\nThe merging process requires iterating through both arrays once.\r\nSPACE COMPLEXITY: O(1)\r\nThe merge is performed in-place without using any additional space.\r\n\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "while (i >= 0 && j >= 0)",
        "while (j >= 0)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\08.Merge_2_sorted_array_without_space.cpp",
      "verified": false,
      "needsReview": true
    },
    "repeating-and-missing-numbers": {
      "id": "repeating-and-missing-numbers",
      "title": "Repeating and missing numbers",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an unsorted array Arr of size N of positive integers. One number 'A' from set {1, 2,....,N} is missing and one number 'B' occurs twice in the array. Find these two numbers.\r\n\r\nExample:\r\nInput:\r\nN = 2\r\nArr[] = {2, 2}\r\nOutput: 2 1\r\nExplanation: Repeating number is 2 and the smallest positive missing number is 1.",
      "approach": "To find the missing and repeating numbers in the given unsorted array, we can utilize the properties of summation and sum of squares. Let's denote the missing number as 'x' and the repeating number as 'y'.\r\n\r\n1. Calculate the optimal sum 'optSum' using the formula: optSum = N * (N + 1) / 2, where N is the size of the array.\r\n2. Calculate the optimal sum of squares 'opt2Sum' using the formula: opt2Sum = N * (N + 1) * (2 * N + 1) / 6.\r\n3. Calculate the actual sum 'actSum' and actual sum of squares 'act2Sum' of the given array.\r\n4. Find the difference between the optimal sum and the actual sum: xMinusY = optSum - actSum.\r\n5. Find the difference between the optimal sum of squares and the actual sum of squares: x2MinusY2 = opt2Sum - act2Sum.\r\n6. Calculate the sum of 'x' and 'y': xPlusY = x2MinusY2 / xMinusY.\r\n7. Calculate 'x' and 'y' using the equations: x = (xPlusY + xMinusY) / 2 and y = xPlusY - x.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> findTwoElement(vector<int> arr, int N) {\r\n    long long n = N;\r\n    long long optSum = n * (n + 1) / 2; // Sum if all elements are present once\r\n    long long opt2Sum = n * (n + 1) * (2 * n + 1) / 6; // Optimum sum of squares\r\n    long long actSum = 0; // Actual sum of the given array\r\n    long long act2Sum = 0; // Actual sum of squares\r\n    \r\n    for (auto it : arr) {\r\n        actSum += it;\r\n        act2Sum += (long long)it * (long long)it;\r\n    }\r\n    \r\n    long long xMinusY = optSum - actSum;\r\n    long long x2MinusY2 = opt2Sum - act2Sum;\r\n    long long xPlusY = x2MinusY2 / xMinusY;\r\n    \r\n    long long x = (xPlusY + xMinusY) / 2;\r\n    long long y = xPlusY - x;\r\n    \r\n    return {(int)y, (int)x};\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(N), where N is the size of the array.\r\nSPACE COMPLEXITY: O(1).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (auto it : arr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\09.Repeating_and_missing_numbers.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-inversions": {
      "id": "count-inversions",
      "title": "Count inversions",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array of integers. Find the Inversion Count in the array.\r\n\r\nInversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If the array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum. \r\nFormally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.\r\n\r\nExample 1:\r\nInput: N = 5, arr[] = {2, 4, 1, 3, 5}\r\nOutput: 3\r\nExplanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).\r\n\r\nExample 2:\r\nInput: N = 5, arr[] = {2, 3, 4, 5, 6}\r\nOutput: 0\r\nExplanation: As the sequence is already sorted, there is no inversion count.",
      "approach": "To find the inversion count in the array, we can utilize the merge sort algorithm. The idea is to divide the array into two halves, recursively count the inversions in each half, and then merge the two halves while counting the inversions across them.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nlong long int inv_cnt = 0;\r\n\r\nlong long int merge(long long start, long long mid, long long end, long long arr[]) {\r\n    long long leftsize = mid - start + 1;\r\n    long long rightsize = end - mid;\r\n    long long left[leftsize], right[rightsize];\r\n    \r\n    for (long long i = 0; i < leftsize; i++) {\r\n        left[i] = arr[start + i];\r\n    }\r\n    for (long long i = 0; i < rightsize; i++) {\r\n        right[i] = arr[mid + 1 + i];\r\n    }\r\n    \r\n    long long i = 0, j = 0, k = start;\r\n    while (i < leftsize && j < rightsize) {\r\n        if (left[i] > right[j]) {\r\n            inv_cnt += leftsize - i;\r\n            arr[k++] = right[j++];\r\n        } else {\r\n            arr[k++] = left[i++];\r\n        }\r\n    }\r\n    while (i < leftsize) {\r\n        arr[k++] = left[i++];\r\n    }\r\n    while (j < rightsize) {\r\n        arr[k++] = right[j++];\r\n    }\r\n}\r\n\r\nvoid mergesort(long long start, long long end, long long arr[]) {\r\n    if (start >= end)\r\n        return;\r\n    long long mid = start + (end - start) / 2;\r\n    mergesort(start, mid, arr);\r\n    mergesort(mid + 1, end, arr);\r\n    merge(start, mid, end, arr);\r\n}\r\n\r\nlong long int inversionCount(long long arr[], long long N) {\r\n    mergesort(0, N - 1, arr);\r\n    return inv_cnt;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(N log N), where N is the size of the array.\r\nSPACE COMPLEXITY: O(N).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search",
        "recursion",
        "divide-conquer"
      ],
      "fingerprint": [
        "for (long long i = 0; i < leftsize; i++)",
        "for (long long i = 0; i < rightsize; i++)",
        "while (i < leftsize && j < rightsize)",
        "while (i < leftsize)",
        "while (j < rightsize)",
        "sort(",
        "sort(",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\10.Count_inversions.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-pairs": {
      "id": "reverse-pairs",
      "title": "Reverse pairs",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an integer array nums, return the number of reverse pairs in the array.\r\nA reverse pair is a pair (i, j) where:\r\n0 <= i < j < nums.length and\r\nnums[i] > 2 * nums[j].\r\n\r\nExample:\r\nInput: nums = [1,3,2,3,1]\r\nOutput: 2\r\nExplanation: The reverse pairs are:\r\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\r\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1",
      "approach": "To solve this problem, we can use the merge sort algorithm. While merging the two sorted subarrays, we can count the number of reverse pairs.\r\n\r\n1. Define a variable 'rev_pair' to store the count of reverse pairs.\r\n2. Implement the 'merge' function to merge two subarrays and count the reverse pairs.\r\n3. Implement the 'mergesort' function to recursively divide the array into subarrays and perform merge sort.\r\n4. Initialize 'rev_pair' to 0 and call the 'mergesort' function on the given array.\r\n5. Return the 'rev_pair' as the result.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint rev_pair = 0;\r\n\r\nvoid merge(int start, int mid, int end, vector<int>& nums){\r\n    int left_size = mid - start + 1;\r\n    int right_size = end - mid;\r\n    vector<int> left(left_size);\r\n    vector<int> right(right_size);\r\n\r\n    for(int i = 0; i < left_size; i++){\r\n        left[i] = nums[start + i];\r\n    }\r\n    for(int i = 0; i < right_size; i++){\r\n        right[i] = nums[mid + 1 + i];\r\n    }\r\n\r\n    // main logic resides here\r\n    int m = 0;\r\n    for(int i = 0; i < left_size; i++){\r\n        while(m < right_size && left[i] > (long long)2 * right[m]){\r\n            m++;\r\n        }\r\n        rev_pair += m;\r\n    }\r\n\r\n    int i = 0, j = 0, k = start;\r\n    while(i < left_size && j < right_size){\r\n        if(left[i] > right[j]){\r\n            nums[k++] = right[j++];\r\n        }\r\n        else{\r\n            nums[k++] = left[i++];\r\n        }\r\n    }\r\n    while(i < left_size){\r\n        nums[k++] = left[i++];\r\n    }\r\n    while(j < right_size){\r\n        nums[k++] = right[j++];\r\n    }\r\n}\r\n\r\nvoid mergesort(int start, int end, vector<int>& nums){\r\n    if(start >= end)\r\n        return;\r\n    int mid = start + (end - start) / 2;\r\n    mergesort(start, mid, nums);\r\n    mergesort(mid + 1, end, nums);\r\n    merge(start, mid, end, nums);\r\n}\r\n\r\nint reversePairs(vector<int>& nums) {\r\n    rev_pair = 0;\r\n    mergesort(0, nums.size() - 1, nums);\r\n    return rev_pair;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(n log n), where n is the size of the array.\r\nSPACE COMPLEXITY: O(n), where n is the size of the array.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search",
        "recursion",
        "divide-conquer"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for(int i = 0; i < left_size; i++)",
        "for(int i = 0; i < right_size; i++)",
        "for(int i = 0; i < left_size; i++)",
        "while(m < right_size && left[i] > (long long)",
        "while(i < left_size && j < right_size)",
        "while(i < left_size)",
        "sort(",
        "sort(",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\11.Reverse_pairs.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximum-product-subarray": {
      "id": "maximum-product-subarray",
      "title": "Maximum product subarray",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.\r\n\r\nExample:\r\n\r\nInput: nums = [2,3,-2,4]\r\nOutput: 6\r\nExplanation: [2,3] has the largest product 6.",
      "approach": "To find the subarray with the largest product, we iterate through the array while keeping track of the current product. We maintain two variables: `ans` to store the maximum product found so far and `prdct` to store the current product. Since negative numbers can change the sign and potentially result in a larger product, we run the loop twice, once from left to right and once from right to left.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint maxProduct(vector<int>& nums) {\r\n    int ans = INT_MIN;\r\n    int prdct = 1;\r\n\r\n    // Iterate from left to right\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        prdct = prdct * nums[i];\r\n        ans = max(ans, prdct);\r\n        if (prdct == 0)\r\n            prdct = 1;\r\n    }\r\n\r\n    prdct = 1;\r\n\r\n    // Iterate from right to left\r\n    for (int i = nums.size() - 1; i >= 0; i--) {\r\n        prdct = prdct * nums[i];\r\n        ans = max(ans, prdct);\r\n        if (prdct == 0)\r\n            prdct = 1;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(N), where N is the size of the input array.\r\nSPACE COMPLEXITY: O(1).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < nums.size()",
        "for (int i = nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\12.Maximum_product_subarray.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-subarray-with-sum-k-containg-ves-and-ves": {
      "id": "longest-subarray-with-sum-k-containg-ves-and-ves",
      "title": "Longest subarray with sum k containg +ves and -ves",
      "category": "arrays",
      "difficulty": "hard",
      "problemStatement": "Given an array containing N integers and an integer K, find the length of the longest subarray with the sum of the elements equal to K.\r\n\r\nExample:\r\nInput:\r\nA[] = {10, 5, 2, 7, 1, 9}\r\nK = 15\r\nOutput:\r\n4\r\nExplanation:\r\nThe sub-array is {5, 2, 7, 1}.",
      "approach": "To solve this problem, we can use a prefix sum approach along with a hashmap to keep track of the prefix sums encountered so far. We iterate through the array and maintain a prefix sum variable. At each index, we check if the prefix sum equals K, in which case we update the maximum length of the subarray found so far. Additionally, we check if the current prefix sum minus K exists in the hashmap. If it does, it means there is a subarray between the previous occurrence of the prefix sum minus K and the current index that sums up to K. We update the maximum length accordingly. We store the prefix sums and their corresponding indices in the hashmap.\r\n\r\nCode:",
      "code": "*/\r\nint lenOfLongSubarr(int A[], int N, int K) {\r\n    int pref_sum = 0;\r\n    int ans = 0;\r\n    unordered_map<int, int> mp;\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        pref_sum += A[i];\r\n        if (pref_sum == K)\r\n            ans = max(ans, i + 1);\r\n        if (mp.find(pref_sum - K) != mp.end())\r\n            ans = max(ans, i - mp[pref_sum - K]);\r\n        if (mp.find(pref_sum) == mp.end())\r\n            mp[pref_sum] = i;\r\n    }\r\n    return ans;\r\n}\r\n/*\r\nTime Complexity: The code iterates through the array once, resulting in a time complexity of O(N), where N is the size of the array.\r\nSpace Complexity: The code uses an unordered map to store the prefix sums and their corresponding indices. In the worst case, all elements of the array could be distinct, leading to a space complexity of O(N) to store the prefix sums in the map.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "for (int i = 0; i < N; i++)",
        ".find(",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\01.Arrays\\3.Hard\\13.Longest_subarray_with_sum_k_containg_+ves_and_-ves.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-x-in-sorted-array": {
      "id": "find-x-in-sorted-array",
      "title": "Find x in sorted array",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\r\n\r\nExample 1:\r\nInput: nums = [-1,0,3,5,9,12], target = 9\r\nOutput: 4\r\nExplanation: The target value 9 exists in the nums array, and its index is 4.\r\n\r\nExample 2:\r\nInput: nums = [-1,0,3,5,9,12], target = 2\r\nOutput: -1\r\nExplanation: The target value 2 does not exist in the nums array, so return -1.",
      "approach": "-\r\n1. Initialize low as 0 and high as the last index of the array.\r\n2. Iterate using a while loop until low is less than or equal to high.\r\n3. Calculate the middle index using the formula mid = low + (high - low) / 2.\r\n4. Compare the target value with the element at the middle index:\r\n   - If they are equal, return the middle index.\r\n   - If the target is less than the element, update high to mid - 1 and continue the search in the left half.\r\n   - If the target is greater than the element, update low to mid + 1 and continue the search in the right half.\r\n5. If the target is not found, return -1.",
      "code": "int search(vector<int>& nums, int target) {\r\n    int low = 0, high = nums.size() - 1;\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (nums[mid] == target)\r\n            return mid;\r\n        else if (nums[mid] > target)\r\n            high = mid - 1;\r\n        else\r\n            low = mid + 1;\r\n    }\r\n    return -1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\01.Find_x_in_sorted_array.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-lower-bound": {
      "id": "implement-lower-bound",
      "title": "Implement lower bound",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a sorted array arr[] of size N without duplicates, and given a value x. Floor of x is defined as the largest element K in arr[] such that K is smaller than or equal to x. Find the index of K (0-based indexing).\r\n\r\nExample 1:\r\nInput:\r\nN = 7, x = 0\r\narr[] = {1,2,8,10,11,12,19}\r\nOutput: -1\r\nExplanation: No element less than 0 is found. So the output is \"-1\".\r\n\r\nExample 2:\r\nInput:\r\nN = 7, x = 5\r\narr[] = {1,2,8,10,11,12,19}\r\nOutput: 1\r\nExplanation: Largest number less than 5 is 2 (i.e K = 2), whose index is 1 (0-based indexing).",
      "approach": "- Initialize low as 0 and high as N-1.\r\n- Iterate using a while loop until low is less than or equal to high.\r\n- Calculate the mid index using mid = low + (high - low) / 2.\r\n- Check if the element at mid index is less than or equal to x.\r\n  - If true, update the answer as mid and move the low pointer to mid+1 to search for a larger element.\r\n  - If false, update the high pointer to mid-1 to search in the lower half of the array.\r\n- Finally, return the answer.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint findFloor(vector<long long> v, long long n, long long x) {\r\n    long long low = 0, high = n - 1;\r\n    int ans = -1;\r\n    while (low <= high) {\r\n        long long mid = low + (high - low) / 2;\r\n        if (v[mid] <= x) {\r\n            ans = mid;\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<long long>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\02.Implement_lower_bound.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-lower-upper-bound": {
      "id": "implement-lower-upper-bound",
      "title": "Implement lower upper bound",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an unsorted array Arr[] of N integers and an integer X, find floor and ceiling of X in Arr[0..N-1].\r\n\r\nFloor of X is the largest element which is smaller than or equal to X. Floor of X doesn’t exist if X is smaller than the smallest element of Arr[].\r\n\r\nCeil of X is the smallest element which is greater than or equal to X. Ceil of X doesn’t exist if X is greater than the greatest element of Arr[].\r\n\r\nExample:\r\n\r\nInput:\r\nN = 8, X = 7\r\nArr[] = {5, 6, 8, 9, 6, 5, 5, 6}\r\nOutput: 6 8\r\nExplanation:\r\nFloor of 7 is 6 and ceil of 7 is 8.",
      "approach": "1. Sort the array in ascending order.\r\n2. Use binary search to find the floor and ceil values.\r\n3. The floor value is the largest element smaller than or equal to X, and the ceil value is the smallest element greater than or equal to X.\r\n4. If the floor or ceil values are not found, set them to -1.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint lowerbound(int arr[], int n, int x){\r\n    int low = 0, high = n-1;\r\n    int ans = -1;\r\n    while(low<=high){\r\n        int mid = low+(high-low)/2;\r\n        if(arr[mid]<=x){\r\n            ans = mid;\r\n            low = mid+1;\r\n        }\r\n        else{\r\n            high = mid-1;\r\n        }\r\n    }\r\n    if(ans!=-1) ans = arr[ans];\r\n    return ans;\r\n}\r\n\r\nint upperbound(int arr[], int n, int x){\r\n    int low = 0, high = n-1;\r\n    int ans = -1;\r\n    while(low<=high){\r\n        int mid = low+(high-low)/2;\r\n        if(arr[mid]>=x){\r\n            ans = mid;\r\n            high = mid-1;\r\n        }\r\n        else{\r\n            low = mid+1;\r\n        }\r\n    }\r\n    if(ans!=-1) ans = arr[ans];\r\n    return ans;\r\n}\r\n\r\npair<int, int> getFloorAndCeil(int arr[], int n, int x) {\r\n    sort(arr,arr+n);\r\n    int Floor = lowerbound(arr,n,x);\r\n    int Ceil = upperbound(arr,n,x);\r\n    return {Floor,Ceil};\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "binary-search"
      ],
      "fingerprint": [
        "while(low<=high)",
        "while(low<=high)",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\03.Implement_lower_upper_bound.cpp",
      "verified": false,
      "needsReview": true
    },
    "search-insert-position": {
      "id": "search-insert-position",
      "title": "Search insert position",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample:\r\n\r\nInput: nums = [1,3,5,6], target = 5\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [1,3,5,6], target = 2\r\nOutput: 1",
      "approach": "We can use the lower_bound function from the C++ standard library to find the index where the target should be inserted. The lower_bound function returns an iterator pointing to the first element that is not less than the target. By subtracting the beginning iterator from the lower_bound iterator, we get the index where the target should be inserted.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint searchInsert(vector<int>& nums, int target) {\r\n    auto ans = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "lower_bound("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\04.Search_insert_position.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-if-array-is-sorted": {
      "id": "check-if-array-is-sorted",
      "title": "Check If array is sorted",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an array arr[] of size N, check if it is sorted in non-decreasing order or not.",
      "approach": "- We can use a recursive approach to check if the array is sorted in non-decreasing order or not.\r\n- The base case for recursion is when the subarray has only one element or when the subarray is empty, in which case we consider it to be sorted.\r\n- For a non-empty subarray, we compare the middle element with its next element. If they are in non-decreasing order and both the left and right subarrays are also sorted, then we consider the entire array to be sorted.\r\n- We recursively check the left and right subarrays using the same approach.\r\n- If any of the recursive calls returns false, we return false. Otherwise, we return true.\r\n\r\nExample:\r\n\r\nInput:\r\nN = 5\r\narr[] = {10, 20, 30, 40, 50}\r\nOutput: 1\r\nExplanation: The given array is sorted.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool solve(int arr[], int low, int high) {\r\n    if (low >= high)\r\n        return true;\r\n    \r\n    int mid = low + (high - low) / 2;\r\n    if (arr[mid] <= arr[mid + 1] && solve(arr, low, mid) && solve(arr, mid + 1, high))\r\n        return true;\r\n    \r\n    return false;\r\n}\r\n\r\nbool arraySortedOrNot(int arr[], int n) {\r\n    return solve(arr, 0, n - 1);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\05.Check_If_array_is_sorted.cpp",
      "verified": false,
      "needsReview": true
    },
    "first-and-last-position": {
      "id": "first-and-last-position",
      "title": "First and last position",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\r\n\r\nIf target is not found in the array, return [-1, -1].\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample:\r\n\r\nInput: nums = [5,7,7,8,8,10], target = 8\r\nOutput: [3,4]",
      "approach": "1. Use lower_bound to find the index of the first occurrence of the target in the array.\r\n2. If the target is not found, return [-1, -1].\r\n3. Use upper_bound to find the index of the last occurrence of the target in the array.\r\n4. Return the range [first, last-1] as the starting and ending positions.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> searchRange(vector<int>& nums, int target) {\r\n    int first = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\r\n    // if the target is not found, return [-1, -1]\r\n    if (first == nums.size() || nums[first] != target)\r\n        return {-1, -1};\r\n    int last = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\r\n    return {first, last-1};\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "lower_bound(",
        "upper_bound("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\06.First_and_last_position.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-occurences": {
      "id": "number-of-occurences",
      "title": "Number of occurences",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a sorted array Arr of size N and a number X, you need to find the number of occurrences of X in Arr.\r\n\r\nExample:\r\n\r\nInput:\r\nN = 7, X = 2\r\nArr[] = {1, 1, 2, 2, 2, 2, 3}\r\nOutput: 4\r\nExplanation: 2 occurs 4 times in the given array.\r\nExample 2:\r\n\r\nInput:\r\nN = 7, X = 4\r\nArr[] = {1, 1, 2, 2, 2, 2, 3}\r\nOutput: 0\r\nExplanation: 4 is not present in the given array.",
      "approach": "1. Use binary search to find the first occurrence of the target element.\r\n2. Use binary search to find the last occurrence of the target element.\r\n3. Return the difference between the indices of the first and last occurrence + 1.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint countOccurrences(int arr[], int n, int x) {\r\n    int first = lower_bound(arr, arr + n, x) - arr;\r\n    if (first == n || arr[first] != x)\r\n        return 0;\r\n    int last = upper_bound(arr, arr + n, x) - arr;\r\n    return last - first;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "lower_bound(",
        "upper_bound("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\07.Number_of_occurences.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-peak-element": {
      "id": "find-peak-element",
      "title": "Find peak element",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "A peak element is an element that is strictly greater than its neighbors.\r\n\r\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\r\n\r\nYou may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\r\n\r\nYou must write an algorithm that runs in O(log n) time.\r\n\r\nExample 1:\r\nInput: nums = [1,2,3,1]\r\nOutput: 2\r\nExplanation: 3 is a peak element and your function should return the index number 2.\r\n\r\nExample 2:\r\nInput: nums = [1,2,1,3,5,6,4]\r\nOutput: 5\r\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
      "approach": "-\r\nWe can use the binary search approach to find the peak element.\r\n1. Initialize low = 0 and high = n-1, where n is the size of the array.\r\n2. While low < high, calculate mid = low + (high - low) / 2.\r\n3. If nums[mid] < nums[mid+1], it means a peak element exists on the right side of mid, so update low = mid+1.\r\n4. Otherwise, a peak element exists on the left side of mid or mid itself is a peak, so update high = mid.\r\n5. After the loop ends, low will be pointing to the peak element index.\r\n6. Return low as the result.",
      "code": "*/\r\n\r\nint findPeakElement(vector<int>& nums) {\r\n    int low = 0, high = nums.size()-1;\r\n    while(low < high){\r\n        int mid = low + (high - low) / 2;\r\n        if(nums[mid] < nums[mid+1])\r\n            low = mid+1;\r\n        else\r\n            high = mid;\r\n    }\r\n    return low;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while(low < high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\08.Find_peak_element.cpp",
      "verified": false,
      "needsReview": true
    },
    "search-in-rotated-sorted-array": {
      "id": "search-in-rotated-sorted-array",
      "title": "Search in rotated sorted array",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values).\r\n\r\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\r\n\r\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample 1:\r\nInput: nums = [4,5,6,7,0,1,2], target = 0\r\nOutput: 4\r\n\r\nExample 2:\r\nInput: nums = [4,5,6,7,0,1,2], target = 3\r\nOutput: -1",
      "approach": "We can use the binary search approach to find the target element in the rotated sorted array.\r\n1. Initialize low = 0 and high = nums.size() - 1, where nums is the input array.\r\n2. Perform binary search using the while loop until low <= high.\r\n3. Calculate mid = low + (high - low) / 2.\r\n4. If nums[mid] is equal to the target, return mid.\r\n5. Check if the left part of the array (nums[low] to nums[mid]) is sorted or the right part (nums[mid] to nums[high]) is sorted.\r\n   - If the left part is sorted:\r\n     - If the target is within the range of nums[low] and nums[mid], update high = mid - 1.\r\n     - Otherwise, update low = mid + 1.\r\n   - If the right part is sorted:\r\n     - If the target is within the range of nums[mid] and nums[high], update low = mid + 1.\r\n     - Otherwise, update high = mid - 1.\r\n6. If the target is not found after the while loop, return -1.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint search(vector<int>& nums, int target) {\r\n    int low = 0, high = nums.size() - 1;\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (nums[mid] == target)\r\n            return mid;\r\n        if (nums[low] <= nums[mid]) {\r\n            if (nums[low] <= target && target <= nums[mid])\r\n                high = mid - 1;\r\n            else\r\n                low = mid + 1;\r\n        } else {\r\n            if (nums[mid] <= target && target <= nums[high])\r\n                low = mid + 1;\r\n            else\r\n                high = mid - 1;\r\n        }\r\n    }\r\n    return -1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\09.Search_in_rotated_sorted_array.cpp",
      "verified": false,
      "needsReview": true
    },
    "search-in-rotated-sorted-array-with-duplicates": {
      "id": "search-in-rotated-sorted-array-with-duplicates",
      "title": "Search in rotated sorted array with duplicates",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\r\n\r\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\r\n\r\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\r\n\r\nYou must decrease the overall operation steps as much as possible.\r\n\r\nExample 1:\r\nInput: nums = [2,5,6,0,0,1,2], target = 0\r\nOutput: true\r\n\r\nExample 2:\r\nInput: nums = [2,5,6,0,0,1,2], target = 3\r\nOutput: false",
      "approach": "We can modify the standard binary search algorithm to search for the target element.\r\n1. Initialize low = 0 and high = nums.size() - 1.\r\n2. While low <= high, calculate mid = low + (high - low) / 2.\r\n3. If nums[mid] equals the target, return true.\r\n4. If nums[mid] is equal to nums[low], we are in a situation where we can't determine which part of the array is sorted.\r\n   In this case, we increment low and decrement high to skip the duplicate elements.\r\n5. If the left part of the array from low to mid is sorted, check if the target lies within this range.\r\n   If so, update high = mid - 1. Otherwise, update low = mid + 1.\r\n6. If the right part of the array from mid to high is sorted, check if the target lies within this range.\r\n   If so, update low = mid + 1. Otherwise, update high = mid - 1.\r\n7. If the target is not found, return false.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool search(vector<int>& nums, int target) {\r\n    int low = 0, high = nums.size() - 1;\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (nums[mid] == target)\r\n            return true;\r\n        if (nums[mid] == nums[low] && nums[mid] == nums[high]) {\r\n            low++;\r\n            high--;\r\n            continue;\r\n        }\r\n        if (nums[low] <= nums[mid]) {\r\n            if (nums[low] <= target && target <= nums[mid])\r\n                high = mid - 1;\r\n            else\r\n                low = mid + 1;\r\n        } else {\r\n            if (nums[mid] <= target && target <= nums[high])\r\n                low = mid + 1;\r\n            else\r\n                high = mid - 1;\r\n        }\r\n    }\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\10.Search_in_rotated_sorted_array_with_duplicates.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-the-minimum-element-in-sorted-rotated-array": {
      "id": "find-the-minimum-element-in-sorted-rotated-array",
      "title": "Find the minimum element in sorted rotated array",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\r\n\r\n[4,5,6,7,0,1,2] if it was rotated 4 times.\r\n[0,1,2,4,5,6,7] if it was rotated 7 times.\r\n\r\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.",
      "approach": "We can use the binary search approach to find the minimum element.\r\n1. Initialize low = 0 and high = n-1, where n is the size of the array.\r\n2. While low < high, calculate mid = low + (high - low) / 2.\r\n3. If nums[mid] > nums[high], it means the minimum element is on the right side of mid, so update low = mid+1.\r\n4. Otherwise, the minimum element is on the left side of mid or mid itself, so update high = mid.\r\n5. After the loop ends, low will be pointing to the minimum element index.\r\n6. Return nums[low] as the result.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint findMin(vector<int>& nums) {\r\n    int low = 0, high = nums.size()-1;\r\n    while(low < high){\r\n        int mid = low + (high - low) / 2;\r\n        if(nums[mid] > nums[high])\r\n            low = mid+1;\r\n        else\r\n            high = mid;\r\n    }\r\n    return nums[low];\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while(low < high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\11.Find_the_minimum_element_in_sorted_rotated_array.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-single-element-in-sorted-array": {
      "id": "find-single-element-in-sorted-array",
      "title": "Find single element in sorted array",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\r\n\r\nReturn the single element that appears only once.",
      "approach": "Since the array is sorted and every element appears exactly twice except for one element, we can use binary search to find the single element.\r\n1. Initialize low = 0 and high = nums.size()-1, where nums is the input array.\r\n2. While low < high, calculate mid = low + (high - low) / 2.\r\n3. Check if mid is an even index (mid % 2 == 0).\r\n    - If nums[mid] is equal to nums[mid + 1], it means the single element is on the right side, so update low = mid + 1.\r\n    - Otherwise, the single element is on the left side, so update high = mid.\r\n4. If mid is an odd index (mid % 2 == 1).\r\n    - If nums[mid] is not equal to nums[mid + 1], it means the single element is on the right side, so update low = mid + 1.\r\n    - Otherwise, the single element is on the left side, so update high = mid.\r\n5. After the loop ends, low will be pointing to the single element.\r\n6. Return nums[low] as the result.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint singleNonDuplicate(vector<int>& nums) {\r\n    int low = 0, high = nums.size() - 1;\r\n    while (low < high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (mid % 2 == 0) {\r\n            if (nums[mid] == nums[mid + 1])\r\n                low = mid + 1;\r\n            else\r\n                high = mid;\r\n        } else {\r\n            if (nums[mid] != nums[mid + 1])\r\n                low = mid + 1;\r\n            else\r\n                high = mid;\r\n        }\r\n    }\r\n    return nums[low];\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "while (low < high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\12.Find_single_element_in_sorted_array.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-how-many-times-array-is-rotated": {
      "id": "find-how-many-times-array-is-rotated",
      "title": "Find how many times array is rotated",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an ascending sorted rotated array Arr of distinct integers of size N. The array is right rotated K times. Find the value of K.\r\n\r\nExample 1:\r\n\r\nInput:\r\nN = 5\r\nArr[] = {5, 1, 2, 3, 4}\r\nOutput: 1\r\nExplanation: The given array is 5 1 2 3 4. \r\nThe original sorted array is 1 2 3 4 5. \r\nWe can see that the array was rotated \r\n1 times to the right.",
      "approach": "To find the value of K, we can use binary search.\r\n1. Initialize low = 0 and high = N-1, where N is the size of the array.\r\n2. While low < high, calculate mid = low + (high - low) / 2.\r\n3. Check if arr[mid] > arr[n-1].\r\n    - If true, it means the rotation point lies on the right side of mid, so update low = mid + 1.\r\n    - If false, it means the rotation point lies on the left side of mid or mid is the rotation point, so update high = mid.\r\n4. After the loop ends, low will be pointing to the rotation point.\r\n5. Return low as the value of K.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint findKRotation(int arr[], int n) {\r\n    int low = 0, high = n - 1;\r\n    while (low < high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (arr[mid] > arr[n - 1])\r\n            low = mid + 1;\r\n        else\r\n            high = mid;\r\n    }\r\n    return low;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "while (low < high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\1D Arrays\\13.Find_how_many_times_array_is_rotated.cpp",
      "verified": false,
      "needsReview": true
    },
    "row-with-maximum-number-of-1-s": {
      "id": "row-with-maximum-number-of-1-s",
      "title": "Row with maximum number of 1's",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a boolean 2D array of n x m dimensions where each row is sorted. Find the 0-based index of the first row that has the maximum number of 1's.\r\n\r\nExample 1:\r\n\r\nInput:\r\nN = 4 , M = 4\r\nArr[][] = {{0, 1, 1, 1},\r\n           {0, 0, 1, 1},\r\n           {1, 1, 1, 1},\r\n           {0, 0, 0, 0}}\r\nOutput: 2\r\nExplanation: Row 2 contains 4 1's (0-based indexing).",
      "approach": "-\r\n-> We can use two pointer i and j which indicates current row and col\r\n-> As we know the matrix is row-wise sorted we can intilaize j=m-1 i.e. last col and i=0 i.e. first row\r\n-> Now, the idea is we will keep moving left j while we occur 1 and if 0 is found we will check in next row\r\n-> The last row where we encountered 1 will be our ans\r\n\r\n                {*0, *1, *1, *1}\r\n                {*0,  0,  1,  1}\r\nout of matrix  *{*1,  1,  1,  1} ---> ans\r\n                {0,  0,  0,  0}",
      "code": "int rowWithMax1s(vector<vector<int>> arr, int n, int m)\r\n{\r\n    int j = m - 1;\r\n    int i = 0;\r\n    int ans = -1;\r\n    while (j >= 0 && i < n)\r\n    {\r\n        while (arr[i][j] == 1)\r\n        {\r\n            ans = i;\r\n            j--;\r\n        }\r\n        if (i < n)\r\n            i++;\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": "O(N+M) //",
          "worst": "O(N+M) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "while (j >= 0 && i < n)",
        "while (arr[i][j] == 1)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\2D Arrays\\1.Row_with_maximum_number_of_1's.cpp",
      "verified": false,
      "needsReview": false
    },
    "search-in-sorted-matrix": {
      "id": "search-in-sorted-matrix",
      "title": "Search in sorted matrix",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You are given an m x n integer matrix matrix with the following two properties:\r\n\r\nEach row is sorted in non-decreasing order.\r\nThe first integer of each row is greater than the last integer of the previous row.\r\nGiven an integer target, return true if target is in matrix or false otherwise.\r\n\r\nYou must write a solution in O(log(m * n)) time complexity.\r\n\r\n\r\n\r\nExample 1:\r\nInput:  matrix = [[1,3,5,7]\r\n                [10,11,16,20]\r\n                [23,30,34,60]]\r\n        target = 3\r\nOutput: true",
      "approach": "-\r\n-> Since the array is sorted we can use binary search low = 0 and high = n*m-1 i.e. total number of elements\r\n-> Value at mid position could be accessed by matrix[mid/m][mid%m]\r\n-> Then, follow the traditional binary search",
      "code": "bool searchMatrix(vector<vector<int>> &matrix, int target)\r\n{\r\n    int n = matrix.size();\r\n    int m = matrix[0].size();\r\n    int low = 0;\r\n    int high = n * m - 1;\r\n    while (low <= high)\r\n    {\r\n        int mid = low + (high - low) / 2;\r\n        int val = matrix[mid / m][mid % m];\r\n        if (val == target)\r\n            return true;\r\n        else if (val > target)\r\n            high = mid - 1;\r\n        else\r\n            low = mid + 1;\r\n    }\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": "O(log(M * N)) //",
          "worst": "O(log(M * N)) //"
        },
        "space": {
          "average": "O(0)",
          "worst": "O(0)"
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\2D Arrays\\2.Search_in_sorted_matrix.cpp",
      "verified": false,
      "needsReview": false
    },
    "search-in-rowwise-sorted-matrix": {
      "id": "search-in-rowwise-sorted-matrix",
      "title": "Search in rowwise sorted matrix",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\r\n- Integers in each row are sorted in ascending order from left to right.\r\n- Integers in each column are sorted in ascending order from top to bottom.\r\n\r\nExample 1:\r\nInput: matrix = [\r\n  [1, 4, 7, 11, 15],\r\n  [2, 5, 8, 12, 19],\r\n  [3, 6, 9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n], target = 5\r\nOutput: true\r\nExplanation: The element 5 is present in the matrix.\r\n\r\nExample 2:\r\nInput: matrix = [\r\n  [1, 4, 7, 11, 15],\r\n  [2, 5, 8, 12, 19],\r\n  [3, 6, 9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n], target = 20\r\nOutput: false\r\nExplanation: The element 20 is not present in the matrix.",
      "approach": "We can start the search from the top-right element or the bottom-left element and move towards the target element based on the properties of the matrix.\r\n\r\n1. Initialize the current position to the top-right element (row = 0, col = n-1), where n is the number of columns in the matrix.\r\n2. While the current position is within the matrix boundaries:\r\n     - If the current element is equal to the target, return true.\r\n     - If the current element is greater than the target, move left to the previous column.\r\n     - If the current element is less than the target, move down to the next row.\r\n3. If the loop exits without finding the target, return false.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\r\n    int row = 0, col = matrix[0].size() - 1;\r\n    while (row < matrix.size() && col >= 0) {\r\n        if (matrix[row][col] == target)\r\n            return true;\r\n        else if (matrix[row][col] > target)\r\n            col--;\r\n        else\r\n            row++;\r\n    }\r\n    return false;\r\n}\r\n\r\n/*\r\nTime Complexity: The time complexity of this algorithm is O(m + n), where m is the number of rows and n is the number of columns in the matrix.\r\n                In the worst case, we may need to traverse through the entire row or column of the matrix.\r\nSpace Complexity: The space complexity is O(1) since we are using constant extra space.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<vector<int>",
        "while (row < matrix.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\2D Arrays\\3.Search_in_rowwise_sorted_matrix.cpp",
      "verified": false,
      "needsReview": true
    },
    "peak-element-in-matrix": {
      "id": "peak-element-in-matrix",
      "title": "Peak element in matrix",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.\r\n\r\nGiven a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].\r\n\r\nYou may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.\r\n\r\nYou must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.\r\n\r\nExample 1:\r\nInput: mat = [[1,4],[3,2]]\r\nOutput: [0,1]\r\nExplanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.\r\n\r\nExample 2:\r\nInput: mat = [[10,20,15],[21,30,14],[7,16,32]]\r\nOutput: [1,1]\r\nExplanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.",
      "approach": "- Perform a binary search on the columns of the matrix.\r\n- Find the maximum element in each column and check if it is a peak element by comparing it with its adjacent elements.\r\n- If it is a peak element, return its position [i, j].\r\n\r\nTIME COMPLEXITY: O(m log(n)) or O(n log(m)) - Binary search is performed on the columns of the matrix.\r\nSPACE COMPLEXITY: O(1) - Constant space is used.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint max_finder(vector<int>& row) {\r\n    int maxi = INT_MIN;\r\n    int ans = -1;\r\n    for (int i = 0; i < row.size(); i++) {\r\n        if (row[i] > maxi) {\r\n            maxi = row[i];\r\n            ans = i;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> findPeakGrid(vector<vector<int>>& mat) {\r\n    int n = mat.size();\r\n    int low = 0, high = n - 1;\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        int col = max_finder(mat[mid]);\r\n        if ((mid == 0 || mat[mid][col] > mat[mid - 1][col]) && \r\n            (mid == n - 1 || mat[mid][col] > mat[mid + 1][col]))\r\n            return {mid, col};\r\n        else {\r\n            if (mid != 0 && mat[mid][col] < mat[mid - 1][col])\r\n                high = mid - 1;\r\n            else\r\n                low = mid + 1;\r\n        }\r\n    }\r\n    return {-1, -1};\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(m log(n)) or O(n log(m)) - Binary search is performed on the columns of the matrix.\r\nSPACE COMPLEXITY: O(1) - Constant space is used.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "for (int i = 0; i < row.size()",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\2D Arrays\\4.Peak_element_in_matrix.cpp",
      "verified": false,
      "needsReview": true
    },
    "matrix-median": {
      "id": "matrix-median",
      "title": "Matrix median",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a row-wise sorted matrix of size R*C where R and C are always odd, find the median of the matrix.\r\n\r\nExample:\r\n\r\nInput:\r\nR = 3, C = 3\r\nM = [[1, 3, 5], \r\n     [2, 6, 9], \r\n     [3, 6, 9]]\r\nOutput: 5\r\nExplanation: Sorting matrix elements gives us {1, 2, 3, 3, 5, 6, 6, 9, 9}. Hence, 5 is the median.",
      "approach": "To find the median of a row-wise sorted matrix, we can follow these steps:\r\n\r\n1. Initialize two variables, `low` and `high`, to keep track of the minimum and maximum elements in the matrix.\r\n2. Iterate through each row and update `low` with the minimum value of the first element in each row and `high` with the maximum value of the last element in each row.\r\n3. Perform binary search between `low` and `high`.\r\n4. For each iteration of binary search, count the number of elements in the matrix that are less than or equal to the mid value.\r\n   - If the count is less than the desired median position, update `low` to mid + 1.\r\n   - If the count is greater than or equal to the desired median position, update the answer with the mid value and update `high` to mid - 1.\r\n5. Repeat steps 3-4 until `low` becomes greater than `high`.\r\n6. Return the final answer as the median of the matrix.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint median(vector<vector<int>>& matrix, int R, int C) {\r\n    int low = INT_MAX;\r\n    int high = INT_MIN;\r\n    int opt_cnt = (R * C + 1) / 2;\r\n    int ans = -1;\r\n\r\n    for (int i = 0; i < R; i++) {\r\n        low = min(low, matrix[i][0]);\r\n        high = max(high, matrix[i][C - 1]);\r\n    }\r\n\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        int cnt = 0;\r\n        for (int i = 0; i < R; i++) {\r\n            cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\r\n        }\r\n        if (cnt < opt_cnt)\r\n            low = mid + 1;\r\n        else {\r\n            ans = mid;\r\n            high = mid - 1;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(R * log(C) * log(range)), where R is the number of rows, C is the number of columns, and range is the difference between the minimum and maximum elements in the matrix. \r\n                The algorithm performs binary search on each row, which takes O(log(C)) time, and the outer binary search iterates log(range) times.\r\nSPACE COMPLEXITY: O(1) as the algorithm only uses a constant amount of additional space to store variables.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "for (int i = 0; i < R; i++)",
        "for (int i = 0; i < R; i++)",
        "while (low <= high)",
        "upper_bound("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\2D Arrays\\5.Matrix_median.cpp",
      "verified": false,
      "needsReview": true
    },
    "square-root-of-number": {
      "id": "square-root-of-number",
      "title": "Square root of number",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an integer x, find the square root of x. If x is not a perfect square, then return floor(√x).\r\n\r\nExample:\r\n\r\nInput:\r\nx = 5\r\nOutput: 2\r\nExplanation: Since 5 is not a perfect square, the floor of the square root of 5 is 2.\r\n\r\nInput:\r\nx = 4\r\nOutput: 2\r\nExplanation: Since 4 is a perfect square, the square root of 4 is 2.",
      "approach": "We can use binary search to find the square root of x. \r\n1. Initialize the search space with low = 1 and high = x.\r\n2. While low is less than or equal to high:\r\n     - Calculate the mid of the search space.\r\n     - If the square of mid is equal to x, return mid as the square root.\r\n     - If the square of mid is less than x, update the answer to mid and set low = mid + 1 to search for a larger value.\r\n     - If the square of mid is greater than x, set high = mid - 1 to search for a smaller value.\r\n3. Return the answer, which represents the floor of the square root of x.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nlong long int floorSqrt(long long int x) \r\n{\r\n    long long int low = 1, high = x;\r\n    long long int ans = -1;\r\n    while(low <= high){\r\n        long long int mid = low + (high - low) / 2;\r\n        if(x == mid * mid)\r\n            return mid;\r\n        else if(mid * mid < x){\r\n            ans = mid;\r\n            low = mid + 1;\r\n        }\r\n        else\r\n            high = mid - 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(log(x))\r\nSpace Complexity: O(1)\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "binary-search"
      ],
      "fingerprint": [
        "while(low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\01.Square_root_of_number.cpp",
      "verified": false,
      "needsReview": true
    },
    "nth-root-of-integer": {
      "id": "nth-root-of-integer",
      "title": "Nth root of integer",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You are given 2 numbers (n, m); the task is to find n√m (nth root of m).\r\n\r\nExample:\r\n\r\nInput: n = 2, m = 9\r\nOutput: 3\r\nExplanation: 3^2 = 9\r\n\r\nInput: n = 3, m = 9\r\nOutput: -1\r\nExplanation: 3rd root of 9 is not an integer.",
      "approach": "We can use a binary search algorithm to find the nth root of m.\r\n1. Initialize the search range with low = 1 and high = m.\r\n2. While low is less than or equal to high:\r\n   - Calculate the mid value as the average of low and high.\r\n   - If mid raised to the power of n is equal to m, return mid.\r\n   - If mid raised to the power of n is less than m, update low to mid + 1.\r\n   - If mid raised to the power of n is greater than m, update high to mid - 1.\r\n3. If the loop exits without finding the nth root, return -1.\r\n\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint NthRoot(int n, int m) {\r\n    int low = 1, high = m;\r\n    while (low <= high) {\r\n        long long mid = low + (high - low) / 2;\r\n        if (pow(mid, n) == m)\r\n            return mid;\r\n        else if (pow(mid, n) < m)\r\n            low = mid + 1;\r\n        else\r\n            high = mid - 1;\r\n    }\r\n    return -1;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY: O(log m)\r\nThe binary search algorithm runs in logarithmic time complexity as it reduces the search range by half at each step.\r\n\r\nSPACE COMPLEXITY: O(1)\r\nThe algorithm uses a constant amount of space to store the variables and perform calculations.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\02.Nth_root_of_integer.cpp",
      "verified": false,
      "needsReview": true
    },
    "koko-eating-banana": {
      "id": "koko-eating-banana",
      "title": "Koko eating banana",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\r\n\r\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\r\n\r\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\r\n\r\nReturn the minimum integer k such that she can eat all the bananas within h hours.\r\n\r\nEXAMPLES:\r\nInput: piles = [3,6,7,11], h = 8\r\nOutput: 4\r\n\r\nInput: piles = [30,11,23,4,20], h = 5\r\nOutput: 30",
      "approach": "- We can apply binary search to find the minimum eating speed.\r\n- The eating speed can range from 1 to the maximum number of bananas in a pile.\r\n- For each eating speed, we check if it is possible to finish eating all the bananas within h hours.\r\n- We calculate the required time based on the eating speed, considering the number of bananas in each pile.\r\n- If the required time is less than or equal to h, it means it is possible to finish eating all the bananas within h hours.\r\n- We update the answer accordingly and continue the binary search.\r\n\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isPossible(int mid, vector<int>& piles, int h){\r\n    long req = 0;\r\n    for(auto it:piles){\r\n        int time = it/mid;\r\n        req += time;\r\n        if(it%mid!=0) req++;\r\n    }\r\n    if(req<=h)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nint minEatingSpeed(vector<int>& piles, int h) {\r\n    int ans = -1;\r\n    int low = 1, high = INT_MIN;\r\n    for(auto it:piles){\r\n        high = max(high,it);\r\n    }\r\n    while(low<=high){\r\n        int mid = low+(high-low)/2;\r\n        if(isPossible(mid,piles,h)){\r\n            ans = mid;\r\n            high = mid-1;\r\n        }\r\n        else{\r\n            low = mid+1;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(auto it:piles)",
        "for(auto it:piles)",
        "while(low<=high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\03.Koko_eating_banana.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-days-to-make-boquets": {
      "id": "minimum-days-to-make-boquets",
      "title": "Minimum days to make boquets",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You are given an integer array bloomDay, an integer m, and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\r\n\r\nThe garden consists of n flowers, where the i-th flower will bloom on the bloomDay[i] day and can be used in exactly one bouquet.\r\n\r\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets, return -1.\r\n\r\nExample:\r\n\r\nInput:\r\nbloomDay = [1,10,3,10,2]\r\nm = 3\r\nk = 1\r\n\r\nOutput:\r\n3\r\n\r\nExplanation:\r\nLet us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\r\nWe need 3 bouquets each should contain 1 flower.\r\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\r\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\r\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.",
      "approach": "- Use binary search to find the minimum number of days required to make m bouquets.\r\n- The search space will be between the minimum and maximum bloom day.\r\n- For each mid value, simulate the process of making bouquets.\r\n- Count the number of bouquets that can be made using k adjacent flowers on or after the current day.\r\n- If the count is equal to or greater than m, update the answer and search in the lower half of the search space.\r\n- If the count is less than m, search in the upper half of the search space.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\04.Minimum_days_to_make_boquets.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-smallest-integer": {
      "id": "find-smallest-integer",
      "title": "Find smallest integer",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You are given an array of integers nums and an integer threshold. We need to find the smallest divisor\r\nsuch that the result of dividing each element of the array by the divisor and summing up the results\r\nis less than or equal to the threshold.\r\n\r\nExample:\r\nInput: nums = [1,2,5,9], threshold = 6\r\nOutput: 5\r\nExplanation: We can get a sum of 17 (1+2+5+9) if the divisor is 1.\r\nIf the divisor is 4, we can get a sum of 7 (1+1+2+3).\r\nIf the divisor is 5, the sum will be 5 (1+1+1+2).\r\nThe smallest divisor that gives a sum less than or equal to the threshold is 5.",
      "approach": "- Start with a range of possible divisors from 1 to the maximum value in the array.\r\n- Use binary search to find the smallest divisor that satisfies the given condition.\r\n- Check the midpoint of the range and calculate the sum of divisions using the current divisor.\r\n- If the sum is less than or equal to the threshold, update the answer and continue searching in the lower half of the range.\r\n- If the sum is greater than the threshold, search in the upper half of the range.\r\n- Repeat this process until the range is narrowed down to a single value, which will be the smallest divisor.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint smallestDivisor(vector<int>& nums, int threshold) {\r\n    int ans = -1;\r\n    int low = 1, high = INT_MIN;\r\n\r\n    // Finding the maximum value in the array\r\n    for (auto it : nums)\r\n        high = max(high, it);\r\n\r\n    // Binary search for the smallest divisor\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        int sum = 0;\r\n        for (auto num : nums) {\r\n            sum += (num + mid - 1) / mid;\r\n        }\r\n        if (sum <= threshold) {\r\n            ans = mid;\r\n            high = mid - 1;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "for (auto it : nums)",
        "for (auto num : nums)",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\05.Find_smallest_integer.cpp",
      "verified": false,
      "needsReview": true
    },
    "capacity-to-ship-packages": {
      "id": "capacity-to-ship-packages",
      "title": "Capacity to ship packages",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "A conveyor belt has packages that must be shipped from one port to another within days days.\r\n\r\nThe ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\r\n\r\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\r\n\r\nExample:\r\n\r\nInput: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\r\nOutput: 15\r\nExplanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\r\n1st day: 1, 2, 3, 4, 5\r\n2nd day: 6, 7\r\n3rd day: 8\r\n4th day: 9\r\n5th day: 10",
      "approach": "To find the least weight capacity of the ship, we can use binary search. We set the low and high as the minimum and maximum weight from the weights array, respectively. Then, we iterate through the weights and check if it can be accommodated within the current capacity. If it can, we subtract the weight from the capacity. If it cannot, we increment the required number of days and update the capacity with the current weight. We continue this process until we find the minimum capacity that satisfies the given number of days.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isPossible(int mid, vector<int>& weights, int days){\r\n    int req_day = 1, temp = mid;\r\n    for(auto it:weights){\r\n        if(it <= temp){\r\n            temp -= it;\r\n        }\r\n        else{\r\n            req_day++;\r\n            if(it > mid)\r\n                return false;\r\n            temp = mid - it;\r\n        }\r\n    }\r\n    if(req_day <= days)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nint shipWithinDays(vector<int>& weights, int days) {\r\n    int ans = -1;\r\n    int low = INT_MAX, high = 0;\r\n    for(auto it:weights){\r\n        low = min(low, it);\r\n        high += it;\r\n    }\r\n    while(low <= high){\r\n        int mid = low + (high - low) / 2;\r\n        if(isPossible(mid, weights, days)){\r\n            ans = mid;\r\n            high = mid - 1;\r\n        }\r\n        else\r\n            low = mid + 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\n- Time Complexity: O(N log M), where N is the size of the weights array and M is the sum of all the weights.\r\n- Space Complexity: O(1) as we are using a constant amount of extra space.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(auto it:weights)",
        "for(auto it:weights)",
        "while(low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\06.Capacity_to_ship_packages.cpp",
      "verified": false,
      "needsReview": true
    },
    "aggresive-cows": {
      "id": "aggresive-cows",
      "title": "Aggresive cows",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\r\n\r\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\r\n\r\nGiven the integer array position and the integer m. Return the required force.\r\n\r\nExample:\r\n\r\nInput: position = [1,2,3,4,7], m = 3\r\nOutput: 3\r\nExplanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.",
      "approach": "- Sort the position array in ascending order to simplify the possibility check.\r\n- Use binary search to find the maximum minimum magnetic force.\r\n- Set the low and high values for the binary search.\r\n- While the low value is less than or equal to the high value, calculate the mid value.\r\n- Check if it is possible to distribute the balls with a minimum magnetic force of mid using the isPossible() function.\r\n- If it is possible, update the answer and set the low value to mid + 1.\r\n- If it is not possible, set the high value to mid - 1.\r\n- Return the answer.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isPossible(int mid, vector<int>& position, int m){\r\n    int placeM = 1;\r\n    int start = 0;\r\n    for(int i=1; i<position.size(); i++){\r\n        if(position[i]-position[start]>=mid){\r\n            placeM++;\r\n            start = i;\r\n        }\r\n    }\r\n    if(placeM>=m)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nint maxDistance(vector<int>& position, int m) {\r\n    sort(position.begin(),position.end());\r\n    int low = 1, high = position[position.size()-1]-position[0];\r\n    int ans = -1; \r\n    while(low<=high){\r\n        int mid = low+(high-low)/2;\r\n        if(isPossible(mid,position,m)){\r\n            ans = mid;\r\n            low = mid+1;\r\n        }\r\n        else{\r\n            high = mid-1;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(n log n), where n is the size of the position array. Sorting the array takes O(n log n) time and the binary search takes O(log n) time.\r\nSpace Complexity: O(1), constant space is used.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "binary-search",
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(int i=1; i<position.size()",
        "while(low<=high)",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\08.Aggresive_cows.cpp",
      "verified": false,
      "needsReview": true
    },
    "book-allocation": {
      "id": "book-allocation",
      "title": "Book allocation",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "You have N books, each with Ai number of pages. M students need to be allocated contiguous books, with each student getting at least one book. Out of all the permutations, the goal is to find the permutation where the student with the most pages allocated to him gets the minimum number of pages, out of all possible permutations.\r\n\r\nNote: Return -1 if a valid assignment is not possible, and allotment should be in contiguous order.\r\n\r\nExample:\r\n\r\nInput:\r\nN = 4\r\nA[] = {12,34,67,90}\r\nM = 2\r\nOutput: 113\r\nExplanation:\r\nAllocation can be done in following ways:\r\n{12} and {34, 67, 90} Maximum Pages = 191\r\n{12, 34} and {67, 90} Maximum Pages = 157\r\n{12, 34, 67} and {90} Maximum Pages = 113.\r\nTherefore, the minimum of these cases is 113, which is selected as the output.",
      "approach": "- We can use binary search to find the minimum number of pages that can be allocated to the student with the most pages.\r\n- The range for binary search will be from the minimum number of pages in the array to the sum of all the pages in the array.\r\n- For each mid value, we will check if it is possible to allocate the books in a way that the maximum number of pages for a student is less than or equal to mid.\r\n- To check this, we iterate through the array of pages and keep track of the number of students and the sum of pages allocated to the current student.\r\n- If at any point, the sum exceeds the mid value, we increment the number of students and reset the sum to the current page value.\r\n- If the number of students exceeds the given M, it means we need more students to allocate the pages, so we return false.\r\n- If at the end, the number of students is less than or equal to M, it means it is possible to allocate the pages within the given constraints, so we return true.\r\n- Finally, we perform binary search and find the minimum mid value that returns true in the isPossible function.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isPossible(int mid, int A[], int N, int M) {\r\n    int pos_m = 1;\r\n    int temp = 0;\r\n    for (int i = 0; i < N; i++) {\r\n        if (temp + A[i] <= mid) {\r\n            temp += A[i];\r\n        } else {\r\n            pos_m++;\r\n            if (A[i] > mid)\r\n                return false;\r\n            temp = A[i];\r\n        }\r\n    }\r\n    if (pos_m <= M)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nint findPages(int A[], int N, int M) {\r\n    if (M > N)\r\n        return -1;\r\n    int low = INT_MAX, high = 0;\r\n    int ans = -1;\r\n    for (int i = 0; i < N; i++) {\r\n        low = min(low, A[i]);\r\n        high += A[i];\r\n    }\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (isPossible(mid, A, N, M)) {\r\n            ans = mid;\r\n            high = mid - 1;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(N log S), where N is the number of books and S is the sum of all the pages in the array. The binary search takes log S iterations, and for each iteration, we check the validity of allocation in O(N) time.\r\nSpace Complexity: O(1), as we are using a constant amount of extra space.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "binary-search"
      ],
      "fingerprint": [
        "for (int i = 0; i < N; i++)",
        "for (int i = 0; i < N; i++)",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\09.Book_allocation.cpp",
      "verified": false,
      "needsReview": true
    },
    "split-array-largest": {
      "id": "split-array-largest",
      "title": "Split array largest",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split.\r\n\r\nExample:\r\nInput: nums = [7,2,5,10,8], k = 2\r\nOutput: 18\r\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.",
      "approach": "- The problem can be solved using the binary search algorithm.\r\n- We need to find the range of possible values for the minimized largest sum.\r\n- The lower bound of the range is the maximum element in the array (as each subarray must contain at least one element).\r\n- The upper bound of the range is the sum of all elements in the array (as the largest sum cannot exceed the total sum of the array).\r\n- We perform binary search within this range to find the minimum largest sum that satisfies the given condition.\r\n- In each iteration, we calculate the mid value of the range and check if it is a valid solution using a helper function.\r\n- The helper function checks if it is possible to split the array into k subarrays with a maximum sum of mid.\r\n- If it is possible, we update the answer and search the lower half of the range.\r\n- If it is not possible, we search the upper half of the range.\r\n- We continue this process until we find the optimal solution.\r\n\r\nTime Complexity: O(n * log(sum of array))\r\nSpace Complexity: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\10.Split_array_largest.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-missing-number": {
      "id": "kth-missing-number",
      "title": "Kth missing number",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given a sorted array arr of positive integers and an integer k, find the kth positive integer that is missing from the array.\r\n\r\nExample:\r\nInput: arr = [2,3,4,7,11], k = 5\r\nOutput: 9\r\nExplanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.",
      "approach": "- We can solve this problem by finding the position in the array where the count of missing positive integers becomes greater than or equal to k.\r\n- Initialize a variable `low` to 0 to represent the start of the array.\r\n- Initialize a variable `high` to the size of the array minus 1 to represent the end of the array.\r\n- Initialize a variable `pos` to -1 to store the position of the missing integer.\r\n- Perform a binary search on the array:\r\n  - Calculate the middle index `mid` using the formula `low + (high - low) / 2`.\r\n  - If the count of missing positive integers in the subarray from the start to `mid` is less than k, update `low` to `mid + 1`.\r\n  - Otherwise, update `pos` to `mid` and update `high` to `mid - 1`.\r\n- After the binary search, check if a missing integer was found:\r\n  - If `pos` is still -1, it means that the missing integer should be after the last element in the array. Return the sum of the size of the array and k.\r\n  - Otherwise, return `pos + k` as the kth missing positive integer.\r\n\r\nTime Complexity: O(log n), where n is the size of the array.\r\nSpace Complexity: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\11.Kth_missing_number.cpp",
      "verified": false,
      "needsReview": true
    },
    "gas-station": {
      "id": "gas-station",
      "title": "Gas station",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "",
      "approach": "- To minimize the maximum distance between adjacent gas stations, we can perform binary search on the possible range of distances.\r\n- Initialize `low` to 0 and `high` to the maximum distance between adjacent existing gas stations.\r\n- While `high - low` is greater than a small threshold (e.g., 1e-6), calculate the mid-point `mid` between `low` and `high`.\r\n- Check if it is possible to add `K` additional gas stations such that the maximum distance between adjacent gas stations is less than or equal to `mid`.\r\n  - Iterate over the existing gas stations and check the distance between adjacent stations.\r\n  - If the total number of additional stations required is less than or equal to `K`, it is possible to achieve the maximum distance `mid`.\r\n- If it is possible, update `high` to `mid`, as we are looking for smaller distances.\r\n- Otherwise, update `low` to `mid`.\r\n- Finally, return the value of `low` plus a small value (e.g., 0.000001) to represent the answer to 2 decimal places.\r\n\r\nTime Complexity: O(N log M), where N is the number of existing gas stations and M is the range of distances between adjacent gas stations.\r\nSpace Complexity: O(1), as we are using constant extra space.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\12.Gas_station.cpp",
      "verified": false,
      "needsReview": true
    },
    "median-of-two-sorted-arrays": {
      "id": "median-of-two-sorted-arrays",
      "title": "Median of two sorted arrays",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given two sorted arrays nums1 and nums2 of sizes m and n respectively, you need to find the median of the two sorted arrays.",
      "approach": "To find the median of two sorted arrays, we can apply the concept of binary search. The overall time complexity of the solution should be O(log (m+n)).\r\n\r\n1. First, we ensure that nums1 is the smaller sized array. If not, we swap nums1 and nums2.\r\n2. Calculate the optimal count opt_cnt, which is (nums1.size() + nums2.size() + 1) / 2. This represents the median index in the merged array.\r\n3. Initialize low to 0 and high to nums1.size() - 1.\r\n4. Perform binary search until low is less than or equal to high:\r\n     - Calculate the cut1 as low + (high - low) / 2, which represents the potential index to partition nums1.\r\n     - Calculate cut2 as opt_cnt - cut1, which represents the corresponding index in nums2.\r\n     - Calculate l1, l2, r1, and r2 as the left and right elements around the potential partition points.\r\n     - If l1 is less than or equal to r2 and l2 is less than or equal to r1, it means we have found the correct partition points.\r\n          - If the total number of elements is even, return the average of the maximum of l1 and l2 and the minimum of r1 and r2.\r\n          - If the total number of elements is odd, return the maximum of l1 and l2.\r\n     - If l1 is greater than r2, move the high pointer to cut1 - 1.\r\n     - Otherwise, move the low pointer to cut1 + 1.\r\n5. If no median is found, return 0.0.\r\n\r\nCODE:",
      "code": "*/\r\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\r\n    if (nums1.size() > nums2.size())\r\n        return findMedianSortedArrays(nums2, nums1);\r\n        \r\n    int opt_cnt = (nums1.size() + nums2.size() + 1) / 2;\r\n    int low = 0, high = nums1.size();\r\n    \r\n    while (low <= high) {\r\n        int cut1 = low + (high - low) / 2;\r\n        int cut2 = opt_cnt - cut1;\r\n        int l1, l2, r1, r2;\r\n\r\n        (cut1 - 1 < 0) ? l1 = INT_MIN : l1 = nums1[cut1 - 1];\r\n        (cut2 - 1 < 0) ? l2 = INT_MIN : l2 = nums2[cut2 - 1];\r\n        (cut1 >= nums1.size()) ? r1 = INT_MAX : r1 = nums1[cut1];\r\n        (cut2 >= nums2.size()) ? r2 = INT_MAX : r2 = nums2[cut2];\r\n\r\n        if (l1 <= r2 && l2 <= r1) {\r\n            if ((nums1.size() + nums2.size()) % 2 == 0)\r\n                return (max(l1, l2) + min(r1, r2)) / 2.0;\r\n            return max(l1, l2);\r\n        } else if (l1 > r2) {\r\n            high = cut1 - 1;\r\n        } else {\r\n            low = cut1 + 1;\r\n        }\r\n    }\r\n    return 0.0;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(log(min(m, n))), where m and n are the sizes of the input arrays nums1 and nums2, respectively. We perform binary search on the smaller array.\r\n- Space complexity: O(1), as we use constant extra space throughout the algorithm.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "while (low <= high)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\13.Median_of_two_sorted_arrays.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-element-of-two-sorted-arrays": {
      "id": "kth-element-of-two-sorted-arrays",
      "title": "Kth element of two sorted arrays",
      "category": "binary-search",
      "difficulty": "unknown",
      "problemStatement": "Given two sorted arrays arr1 and arr2 of size N and M respectively and an element K.\r\nFind the element that would be at the kth position of the final sorted array.\r\n\r\nExample:- \r\n\r\nInput:\r\narr1[] = {2, 3, 6, 7, 9}\r\narr2[] = {1, 4, 8, 10}\r\nk = 5\r\nOutput:\r\n6\r\nExplanation:\r\nThe final sorted array would be -\r\n1, 2, 3, 4, 6, 7, 8, 9, 10\r\nThe 5th element of this array is 6.",
      "approach": "1. Compare the sizes of the two arrays, arr1 and arr2. If the size of arr1 is greater than arr2, swap the arrays to ensure arr1 is the smaller sized array.\r\n2. Set the low and high variables for binary search.\r\n   - If m < k, set low = k - m, otherwise set low = 0.\r\n   - If k < n, set high = k, otherwise set high = n.\r\n3. Perform binary search within the range [low, high] to find the kth element.\r\n4. In each iteration of binary search:\r\n   - Calculate the cut positions, cut1 and cut2, based on the mid position.\r\n   - Determine the left and right elements of arr1 and arr2 based on the cut positions.\r\n   - Compare the left and right elements and adjust the low and high pointers accordingly.\r\n5. Return the maximum element among the left elements, as it would be the kth element in the final sorted array.\r\n\r\nCODE",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "binary-search"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\02.Binary Search\\In Search Space\\14.Kth_element_of_two_sorted_arrays.cpp",
      "verified": false,
      "needsReview": true
    },
    "remove-outer-parenthesis": {
      "id": "remove-outer-parenthesis",
      "title": "Remove outer parenthesis",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Given a valid parentheses string `s`, remove the outermost parentheses of every primitive string in the primitive decomposition of `s`.",
      "approach": "- We can iterate through the characters of the string and keep track of the number of open parentheses encountered.\r\n- Whenever we encounter an opening parenthesis, if the count of open parentheses is greater than 0, we append it to the result string.\r\n- When we encounter a closing parenthesis, we decrement the count of open parentheses and append it to the result string only if the count is greater than 1.\r\n\r\nCode:",
      "code": "*/\r\nstring removeOuterParentheses(string s) {\r\n    string res;\r\n    int opened = 0;\r\n\r\n    for (auto c : s) {\r\n        if (c == '(') {\r\n            if (opened > 0)\r\n                res += c;\r\n            opened++;\r\n        } else {\r\n            if (opened > 1)\r\n                res += c;\r\n            opened--;\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n/*\r\nTime Complexity: O(N), where N is the length of the input string `s`.\r\nSpace Complexity: O(N), where N is the length of the input string `s`.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (auto c : s)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\01.Remove_outer_parenthesis.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-words-in-string": {
      "id": "reverse-words-in-string",
      "title": "Reverse words in string",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Given an input string s, reverse the order of the words.\r\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\r\nReturn a string of the words in reverse order concatenated by a single space.\r\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\r\n\r\nExample:\r\nInput: s = \"the sky is blue\"\r\nOutput: \"blue is sky the\"",
      "approach": "- Initialize an empty string 'ans' to store the reversed words.\r\n- Initialize 'start' and 'end' variables to keep track of the start and end indices of each word.\r\n- Iterate through the input string 's'.\r\n- Ignore leading spaces by advancing the iterator 'i' until a non-space character is found.\r\n- Set 'start' to the current index 'i'.\r\n- Find the end index 'end' of the current word by advancing 'i' until a space or the end of the string is encountered.\r\n- Extract the current word using the substr() function and store it in a temporary string 'temp'.\r\n- Reverse the characters in 'temp'.\r\n- Append 'temp' to 'ans' with a space delimiter.\r\n- Reverse the characters in 'ans' to get the reversed order of words.\r\n- Remove any leading or trailing spaces in 'ans'.\r\n- Return the resulting string 'ans'.\r\n\r\nCode:",
      "code": "*/\r\n\r\nstring reverseWords(string s) {\r\n    string ans = \"\";\r\n    int start = -1, end = -1;\r\n    for(int i=0; i<s.size(); i++){\r\n        while(s[i]==' ')\r\n            i++;\r\n        start = i;\r\n        while(i<s.size() && s[i]!=' ')\r\n            i++;\r\n        end = i;\r\n        string temp = s.substr(start,end-start);\r\n        reverse(temp.begin(),temp.end());\r\n        ans = ans+\" \"+temp;\r\n    }\r\n    reverse(ans.begin(),ans.end());\r\n    int i=0, j=ans.size()-1;\r\n    while(ans[i]==' ')\r\n        i++;\r\n    while(ans[j]==' ')\r\n        j--;\r\n    ans = ans.substr(i,j-i+1);\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(n), where n is the length of the input string 's'.\r\nSpace Complexity: O(n), where n is the length of the input string 's'.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers"
      ],
      "fingerprint": [
        "for(int i=0; i<s.size()",
        "while(s[i]==' ')",
        "while(i<s.size()",
        "while(ans[i]==' ')"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\02.Reverse_words_in_string.cpp",
      "verified": false,
      "needsReview": true
    },
    "largest-odd-number-in-string": {
      "id": "largest-odd-number-in-string",
      "title": "Largest odd number in string",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists.\r\nA substring is a contiguous sequence of characters within a string.",
      "approach": "1. Iterate through the string from the last character.\r\n2. Check if the current character is odd.\r\n3. If it is odd, return the substring from the beginning of the string to the current character index.\r\n4. If no odd number is found, return an empty string.\r\n\r\nTime Complexity: O(N), where N is the length of the input string num.\r\n- We iterate through the string once to find the largest odd number.\r\n\r\nSpace Complexity: O(1)\r\n- We use constant space to store the result and iterate through the string.\r\n\r\nCode:",
      "code": "*/\r\n\r\nstring largestOddNumber(string num) {\r\n    // Check the first odd number from last\r\n    for (int i = num.size() - 1; i >= 0; i--) {\r\n        if ((num[i] - '0') % 2 != 0)\r\n            return num.substr(0, i + 1);\r\n    }\r\n    return \"\";\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (int i = num.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\03.Largest_odd_number_in_string.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-common-prefix": {
      "id": "longest-common-prefix",
      "title": "Longest common prefix",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Write a function to find the longest common prefix string amongst an array of strings.\r\nIf there is no common prefix, return an empty string \"\".",
      "approach": "1. Sort the array of strings lexicographically.\r\n2. Take the first and last string from the sorted array.\r\n3. Compare each character of the first and last string until they don't match or the end of either string is reached.\r\n4. Return the common prefix.\r\n\r\nTime Complexity: O(N*M*log(N)), where N is the number of strings and M is the maximum length of the strings.\r\n- Sorting the array of strings takes O(N*log(N)) time.\r\n- Comparing the first and last string takes O(M) time.\r\n\r\nSpace Complexity: O(1)\r\n- We use constant space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nusing namespace std;\r\n\r\nstring longestCommonPrefix(vector<string>& strs) {\r\n    if (strs.empty())\r\n        return \"\";\r\n\r\n    sort(strs.begin(), strs.end());\r\n\r\n    int first = 0, last = strs.size() - 1;\r\n    int i = 0, j = 0;\r\n    int len = 0;\r\n\r\n    while (i < strs[first].size() && j < strs[last].size() && strs[first][len] == strs[last][len]) {\r\n        i++;\r\n        j++;\r\n        len++;\r\n    }\r\n\r\n    return strs[first].substr(0, len);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "sorting"
      ],
      "fingerprint": [
        "vector<string>",
        "while (i < strs[first].size()",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\04.Longest_common_prefix.cpp",
      "verified": false,
      "needsReview": true
    },
    "isomorphic-string": {
      "id": "isomorphic-string",
      "title": "Isomorphic string",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Given two strings s and t, determine if they are isomorphic.\r\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\r\nAll occurrences of a character must be replaced with another character while preserving the order of characters.\r\nNo two characters may map to the same character, but a character may map to itself.",
      "approach": "1. Initialize two maps to store the mapping of characters from s to t and from t to s.\r\n2. Iterate through each character in s and t simultaneously.\r\n3. If the current characters in s and t are already mapped differently, return false.\r\n4. If the current characters in s and t are not mapped yet, add them to the maps.\r\n5. If the current characters in s and t are already mapped to each other, continue to the next characters.\r\n6. If all characters have been iterated and no inconsistencies are found, return true.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isIsomorphic(string s, string t) {\r\n    unordered_map<char, char> mps;\r\n    unordered_map<char, char> mpt;\r\n\r\n    for (int i = 0; i < s.size(); i++) {\r\n        if (mps.find(s[i]) == mps.end() && mpt.find(t[i]) == mpt.end()) {\r\n            mps[s[i]] = t[i];\r\n            mpt[t[i]] = s[i];\r\n        } else if (mps[s[i]] != t[i] || mpt[t[i]] != s[i]) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*\r\nTime Complexity: O(n), where n is the length of the input strings s and t.\r\n- We iterate through each character of s and t once.\r\n\r\nSpace Complexity: O(m), where m is the number of unique characters in the input strings s and t.\r\n- In the worst case, all characters in s and t are unique, and we need to store mappings for all of them.\r\n- The space complexity can also be considered as O(1) since the maximum number of unique characters is limited (26 English alphabets).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<char, char>",
        "unordered_map<char, char>",
        "for (int i = 0; i < s.size()",
        ".find(",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\05.Isomorphic_string.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-for-rotated-string": {
      "id": "check-for-rotated-string",
      "title": "Check for rotated string",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Rotate String\r\nGiven two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\r\n\r\nA shift on s consists of moving the leftmost character of s to the rightmost position.\r\n\r\nExample:\r\nInput: s = \"abcde\", goal = \"cdeab\"\r\nOutput: true\r\n\r\nInput: s = \"abcde\", goal = \"abced\"\r\nOutput: false",
      "approach": "- First, we check if the lengths of the two strings `s` and `goal` are equal. If not, they cannot be rotated versions of each other, so we return `false`.\r\n- Then, we concatenate `s` with itself to create a new string `concat`.\r\n- We check if `goal` is a substring of `concat`. If it is, that means `s` can be transformed into `goal` by performing some number of left shifts, so we return `true`. Otherwise, we return `false`.",
      "code": "*/\r\n\r\nbool rotateString(string s, string goal) {\r\n    if (s.size() != goal.size())\r\n        return false;\r\n    if ((s + s).find(goal) == string::npos)\r\n        return false;\r\n    return true;\r\n}\r\n\r\n/*\r\nTime Complexity: The time complexity of this approach is O(N^2), where N is the length of the input strings `s` and `goal`. This is because the `find` function is used to search for the substring `goal` within the concatenated string, which has a time complexity of O(N^2).\r\nSpace Complexity: The space complexity is O(N), where N is the length of the input string `s`. This is because we create a new string `concat` by concatenating `s` with itself.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\06.Check_for_rotated_string.cpp",
      "verified": false,
      "needsReview": true
    },
    "valid-anagram": {
      "id": "valid-anagram",
      "title": "Valid anagram",
      "category": "strings",
      "difficulty": "easy",
      "problemStatement": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\r\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\r\n\r\nExample 1:\r\n\r\nInput: s = \"anagram\", t = \"nagaram\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"rat\", t = \"car\"\r\nOutput: false\r\n\r\nProblem: Valid Anagram",
      "approach": "1. Create an unordered map to store the count of each character in string `s`.\r\n2. Iterate over each character in `s` and increment its count in the map.\r\n3. Iterate over each character in `t`.\r\n   - If the character is not present in the map or its count is zero, return false.\r\n   - Decrement the count of the character in the map.\r\n   - If the count becomes zero, remove the character from the map.\r\n4. After iterating through all characters in `t`, if the map is empty, return true; otherwise, return false.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isAnagram(string s, string t) {\r\n    unordered_map<char,int>mp;\r\n    for(auto c:s)\r\n        mp[c]++;\r\n    for(auto c:t){\r\n        if(mp.find(c)==mp.end())\r\n            return false;\r\n        mp[c]--;\r\n        if(mp[c]==0)\r\n            mp.erase(c);\r\n    }\r\n    return (mp.size()==0);\r\n}\r\n\r\n/* \r\nTime complexity: O(max(s.length(), t.length()))\r\nSpace complexity: O(s.length())\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<char,int>",
        "for(auto c:s)",
        "for(auto c:t)",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\1.Easy\\07.Valid_anagram.cpp",
      "verified": false,
      "needsReview": true
    },
    "sort-characters-by-frequency": {
      "id": "sort-characters-by-frequency",
      "title": "Sort characters by frequency",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "Given a string s, sort it in decreasing order based on the frequency of the characters.\r\nThe frequency of a character is the number of times it appears in the string.",
      "approach": "1. Create a frequency map to count the occurrences of each character in the string.\r\n2. Use a priority queue to sort the characters based on their frequencies in decreasing order.\r\n3. Iterate through the priority queue and append the characters to a new string according to their frequencies.\r\n\r\nCode:",
      "code": "*/\r\n\r\nstring frequencySort(string s) {\r\n    unordered_map<char, int> mp;\r\n    for (auto c : s) {\r\n        mp[c]++;\r\n    }\r\n\r\n    priority_queue<pair<int, char>> pq;\r\n    for (auto it : mp) {\r\n        pq.push({ it.second, it.first });\r\n    }\r\n\r\n    string ans = \"\";\r\n    while (!pq.empty()) {\r\n        auto curr = pq.top();\r\n        pq.pop();\r\n        ans.append(curr.first, curr.second);\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(n log n), where n is the length of the string. Building the frequency map takes O(n) time, and the priority queue operations take O(n log n) time.\r\nSpace Complexity: O(n), where n is the length of the string. The space is used to store the frequency map and the priority queue.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "heap"
      ],
      "fingerprint": [
        "unordered_map<char, int>",
        "priority_queue<pair<int, char>",
        "queue<pair<int, char>",
        "for (auto c : s)",
        "for (auto it : mp)",
        "while (!pq.empty()",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\01.Sort_characters_by_frequency.cpp",
      "verified": false,
      "needsReview": true
    },
    "max-nesting-depth-of-parenthesis": {
      "id": "max-nesting-depth-of-parenthesis",
      "title": "Max nesting depth of parenthesis",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "Given a VPS represented as a string s, return the nesting depth of s.",
      "approach": "1. Initialize `opened` as 0 and `ans` as 0 to keep track of the number of opened parentheses and the maximum nesting depth respectively.\r\n2. Iterate through each character `c` in the string `s`.\r\n    a. If `c` is an opening parenthesis '(', increment `opened` by 1 and update `ans` if it is greater than the current value of `ans`.\r\n    b. If `c` is a closing parenthesis ')', decrement `opened` by 1.\r\n3. Return `ans` as the maximum nesting depth.",
      "code": "*/\r\n\r\nint maxDepth(string s) {\r\n    int opened = 0, ans = 0;\r\n    for (auto c : s) {\r\n        if (c == '(') {\r\n            opened++;\r\n            ans = max(ans, opened);\r\n        } else if (c == ')') {\r\n            opened--;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity: O(n), where n is the length of the string `s`.\r\nSpace Complexity: O(1)\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (auto c : s)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\02.Max_nesting_depth_of_parenthesis.cpp",
      "verified": false,
      "needsReview": true
    },
    "roman-to-integer": {
      "id": "roman-to-integer",
      "title": "Roman to Integer",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "Given a Roman numeral as a string, convert it to an integer.\r\n\r\nExample 1:\r\n\r\nInput: s = \"III\"\r\nOutput: 3\r\nExplanation: III = 3.\r\nExample 2:\r\n\r\nInput: s = \"LVIII\"\r\nOutput: 58\r\nExplanation: L = 50, V= 5, III = 3.",
      "approach": "1. Create a map to store the values of each Roman symbol.\r\n2. Initialize `result` as the value of the first symbol in the input string.\r\n3. Iterate through each character `c` in the input string `s`, starting from the second character.\r\n    a. If the value of the current symbol is greater than the value of the previous symbol, subtract twice the value of the previous symbol from `result` and add the value of the current symbol.\r\n    b. Otherwise, add the value of the current symbol to `result`.\r\n4. Return `result` as the converted integer.\r\n\r\nTime Complexity: O(n), where n is the length of the input string `s`.\r\nSpace Complexity: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\03.Roman_to_Integer.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-atoi": {
      "id": "implement-atoi",
      "title": "Implement atoi",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\r\n\r\nThe algorithm for myAtoi(string s) is as follows:\r\n\r\nRead in and ignore any leading whitespace.\r\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\r\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\r\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\r\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\r\nReturn the integer as the final result.\r\nNote:\r\n\r\nOnly the space character ' ' is considered a whitespace character.\r\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"42\"\r\nOutput: 42\r\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\r\nStep 1: \"42\" (no characters read because there is no leading whitespace)\r\n         ^\r\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\r\n         ^\r\nStep 3: \"42\" (\"42\" is read in)\r\n           ^\r\nThe parsed integer is 42.\r\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\r\nExample 2:\r\n\r\nInput: s = \"   -42\"\r\nOutput: -42\r\nExplanation:\r\nStep 1: \"   -42\" (leading whitespace is read and ignored)\r\n            ^\r\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\r\n             ^\r\nStep 3: \"   -42\" (\"42\" is read in)\r\n               ^\r\nThe parsed integer is -42.\r\nSince -42 is in the range [-231, 231 - 1], the final result is -42.",
      "approach": "1. Initialize an index `i` to track the current position in the string.\r\n2. Skip any leading whitespace by incrementing `i` until a non-whitespace character is encountered.\r\n3. Check if the next character (if not at the end of the string) is `'-'` or `'+'`. Set a `sign` flag accordingly to determine the final result's sign.\r\n4. Read the consecutive digits until a non-digit character is encountered or the end of the input is reached. Convert these digits into an integer.\r\n5. Apply the sign to the integer obtained from the digits.\r\n6. If the integer is out of the 32-bit signed integer range, clamp it to the range [-231, 231 - 1].\r\n7. Return the final integer.\r\n\r\nCode:",
      "code": "*/\r\nint myAtoi(string s) {\r\n    int i = 0;\r\n    while (i < s.size() && s[i] == ' ')\r\n        i++;\r\n    if (i == s.size())\r\n        return 0;\r\n    bool sign = true; // indicates the number is positive\r\n\r\n    if (s[i] == '-') {\r\n        i++;\r\n        sign = false;\r\n    } else if (s[i] == '+')\r\n        i++;\r\n\r\n    long long ans = 0;\r\n    while (i < s.size() && (0 <= s[i] - '0' && s[i] - '0' <= 9)) {\r\n        long long digit = s[i] - '0';\r\n        ans = (ans * 10) + digit;\r\n        // handle overflow case\r\n        if (ans > INT_MAX && sign)\r\n            return INT_MAX;\r\n        else if (ans > INT_MAX)\r\n            return INT_MIN;\r\n        i++;\r\n    }\r\n    ans = sign ? ans : -1 * ans;\r\n    return (int) ans;\r\n}\r\n\r\n/*\r\n- Time Complexity: The function scans the input string once, resulting in a linear time complexity of O(n), where n is the length of the input string.\r\n- Space Complexity: The function uses a constant amount of extra space, resulting in constant space complexity, O(1).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "while (i < s.size()",
        "while (i < s.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\04.Implement_atoi.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-substrings-with-k-unique-characters": {
      "id": "count-the-number-of-substrings-with-k-unique-characters",
      "title": "Count the number of substrings with k unique characters",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "",
      "approach": "1. We can solve this problem using the sliding window technique.\r\n2. Initialize a variable ans to keep track of the count of substrings with exactly k distinct characters.\r\n3. Create an unordered_map mp to store the count of characters in the current window.\r\n4. Initialize two pointers i and j to mark the start and end of the window, both initially pointing to the start of the string.\r\n5. Iterate j from the start to the end of the string:\r\n   - Increment the count of the current character s[j] in mp.\r\n   - If the number of distinct characters in mp exceeds k, move the start pointer i towards the right until the number of distinct characters becomes k again.\r\n   - Update the ans by adding the length of the current window (j - i + 1) to it.\r\n6. Return the value of ans.\r\n\r\nCode:",
      "code": "*/\r\n\r\nlong long int substrAtmostK(string s, int k) {\r\n    long long int ans = 0;\r\n    unordered_map<char, int> mp;\r\n    int i = 0;\r\n    for (int j = 0; j < s.size(); j++) {\r\n        mp[s[j]]++;\r\n        \r\n        while (mp.size() > k) {\r\n            mp[s[i]]--;\r\n            if (mp[s[i]] == 0)\r\n                mp.erase(s[i]);\r\n            i++;\r\n        }\r\n        \r\n        ans += j - i + 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nlong long int substrCount(string s, int k) {\r\n    long long int atmostk = substrAtmostK(s, k);\r\n    long long int atmostk_1 = substrAtmostK(s, k - 1);\r\n    return atmostk - atmostk_1;\r\n}\r\n\r\n/*Time Complexity: O(N), where N is the length of the input string.\r\nSpace Complexity: O(K), where K is the number of distinct characters.*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [
        "unordered_map<char, int>",
        "for (int j = 0; j < s.size()",
        "while (mp.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\05.Count_the_number_of_substrings_with_k_unique_characters.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-palindromic-substring": {
      "id": "longest-palindromic-substring",
      "title": "Longest palindromic substring",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "Given a string `s`, the task is to find the longest palindromic substring in `s`.\r\n\r\nExample 1:\r\nInput: s = \"babad\"\r\nOutput: \"bab\"\r\nExplanation: \"aba\" is also a valid answer.\r\n\r\nExample 2:\r\nInput: s = \"cbbd\"\r\nOutput: \"bb\"",
      "approach": "1. We define a helper function `expandFromCenter` that takes a string `s`, and two indices `start` and `end` as input.\r\n2. The function expands from the center and checks if the substring from `start` to `end` is a palindrome.\r\n3. If the length of the current palindrome is greater than the maximum length seen so far (`maxLen`), we update the maximum length and the corresponding start and end indices (`ans_start` and `ans_end`).\r\n4. We iterate over each character of the string `s` and consider it as a potential center for the palindrome.\r\n5. We call `expandFromCenter` twice for each character - once for considering odd-length palindromes and once for even-length palindromes.\r\n6. Finally, we return the substring of `s` that corresponds to the longest palindromic substring.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid expandFromCenter(string s, int start, int end, int& ans_start, int& ans_end, int& maxLen) {\r\n    while (start >= 0 && end < s.size() && s[start] == s[end]) {\r\n        if (end - start + 1 > maxLen) {\r\n            ans_start = start;\r\n            ans_end = end;\r\n            maxLen = end - start + 1;\r\n        }\r\n        start--;\r\n        end++;\r\n    }\r\n}\r\n\r\nstring longestPalindrome(string s) {\r\n    string ans = \"\";\r\n    int maxLen = 0, ans_start = -1, ans_end = -1;\r\n    for (int i = 0; i < s.size(); i++) {\r\n        // For odd length palindromes\r\n        expandFromCenter(s, i, i, ans_start, ans_end, maxLen);\r\n        // For even length palindromes\r\n        expandFromCenter(s, i - 1, i, ans_start, ans_end, maxLen);\r\n    }\r\n    return (maxLen == 0) ? \"\" : s.substr(ans_start, ans_end - ans_start + 1);\r\n}\r\n\r\n/*\r\nTime Complexity: O(n^2), where n is the length of the input string `s`. The nested loops iterate over all possible pairs of indices.\r\nSpace Complexity: O(1), as we are using a constant amount of extra space.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [
        "for (int i = 0; i < s.size()",
        "while (start >= 0 && end < s.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\06.Longest_palindromic_substring.cpp",
      "verified": false,
      "needsReview": true
    },
    "sum-of-beauty-of-all-substrings": {
      "id": "sum-of-beauty-of-all-substrings",
      "title": "Sum of beauty of all substrings",
      "category": "strings",
      "difficulty": "medium",
      "problemStatement": "The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.\r\n\r\nGiven a string `s`, you need to calculate the sum of beauty for all of its substrings. The beauty of a substring is defined as the difference between the highest and lowest frequency of any character in the substring.\r\n\r\nWrite a function `beautySum` that takes a string `s` as input and returns the sum of beauty for all substrings.\r\n\r\nExample:\r\n\r\nInput: s = \"aabcb\"\r\nOutput: 5\r\nExplanation: The substrings with non-zero beauty are [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"], each with beauty equal to 1.\r\n\r\nInput: s = \"aabcbaa\"\r\nOutput: 17",
      "approach": "1. Initialize a variable `ans` to store the total beauty sum.\r\n2. Iterate over the string `s` with the first loop, starting from index `i`.\r\n   - Initialize a frequency array `freq` of size 26, initialized with zeros.\r\n   - Iterate over the string `s` with the second loop, starting from index `j` equal to `i`.\r\n      - Increment the frequency of the character `s[j]` in the `freq` array.\r\n      - Calculate the difference between the highest and lowest frequencies in the `freq` array and add it to `ans`.\r\n3. Return the value of `ans` as the final result.",
      "code": "*/\r\nint get_maxmin(vector<int>& freq){\r\n    int maxi = INT_MIN, mini = INT_MAX;\r\n    for(auto it:freq){\r\n        maxi = max(maxi,it);\r\n        if(it!=0)\r\n            mini = min(mini,it);\r\n    }\r\n    return (mini==INT_MAX)?0:maxi-mini;\r\n}    \r\n\r\nint beautySum(string s) {\r\n    int ans = 0;\r\n    // 2 loops to generate all substrings\r\n    for(int i=0; i<s.size(); i++){\r\n        vector<int>freq(26,0);\r\n        for(int j=i; j<s.size(); j++){\r\n            freq[s[j]-'a']++;\r\n            int maxmin = get_maxmin(freq);\r\n            ans += maxmin;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime complexity :- for generating all substrings is O(n^2), where n is the length of the string `s`. For each substring, we calculate the difference between the highest and lowest frequencies, which takes O(26) or O(1) time since there are 26 lowercase alphabets. Therefore, the overall time complexity is O(n^2).\r\nSpace complexity :- O(26) or O(1) since we use a constant-sized frequency array to store the counts of characters.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(auto it:freq)",
        "for(int i=0; i<s.size()",
        "for(int j=i; j<s.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\03.Strings\\2.Medium\\07.Sum_of_beauty_of_all_substrings.cpp",
      "verified": false,
      "needsReview": true
    },
    "intro-to-linked-list": {
      "id": "intro-to-linked-list",
      "title": "Intro to linked list",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Construct the linked list from arr and return the head of the linked list.\r\n\r\nExample 1:\r\n\r\nInput:\r\nn = 5\r\narr = [1,2,3,4,5]\r\nOutput:\r\n1 2 3 4 5\r\nExplanation: Linked list for the given array will be 1->2->3->4->5.\r\nExample 2:\r\n\r\nInput:\r\nn = 2\r\narr = [2,4]\r\nOutput:\r\n2 4\r\nExplanation: Linked list for the given array will be 2->4.",
      "approach": "- \r\nThe approach to construct a linked list from an array is as follows:\r\n\r\n1. Create the head node of the linked list using the first element of the array.\r\n2. Initialize a current pointer to the head node.\r\n3. Traverse the array starting from the second element.\r\n4. For each element in the array, create a new node and assign the element as its data.\r\n5. Set the `next` pointer of the current node to the newly created node.\r\n6. Update the current pointer to the newly created node.\r\n7. Repeat steps 4-6 until all elements in the array are processed.\r\n8. Return the head node of the constructed linked list.",
      "code": "*/\r\n\r\nNode* constructLL(vector<int>& arr) {\r\n    Node* head = new Node(arr[0]);\r\n    Node* curr = head;\r\n    for(int i=1; i<arr.size(); i++){\r\n        curr->next = new Node(arr[i]);\r\n        curr = curr->next;\r\n    }\r\n    return head;\r\n}\r\n\r\n/*\r\nTIME COMPLEXITY:- O(n)\r\nSPACE COMPLEXITY:- O(n)\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "vector<int>",
        "for(int i=1; i<arr.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\1. Single Linked List\\01.Intro_to_linked_list.cpp",
      "verified": false,
      "needsReview": true
    },
    "inserting-node-to-linked-list": {
      "id": "inserting-node-to-linked-list",
      "title": "Inserting node to linked list",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Create a link list of size N according to the given input literals. Each integer input is accompanied by an indicator which can either be 0 or 1. If it is 0, insert the integer in the beginning of the link list. If it is 1, insert the integer at the end of the link list. \r\nHint: When inserting at the end, make sure that you handle NULL explicitly.\r\n\r\nExample 1:\r\n\r\nInput:\r\nLinkedList: 9->0->5->1->6->1->2->0->5->0\r\nOutput: 5 2 9 5 6\r\nExplanation:\r\nLength of Link List = N = 5\r\n9 0 indicated that 9 should be\r\ninserted in the beginning. Modified\r\nLink List = 9.\r\n5 1 indicated that 5 should be\r\ninserted in the end. Modified Link\r\nList = 9,5.\r\n6 1 indicated that 6 should be\r\ninserted in the end. Modified Link\r\nList = 9,5,6.\r\n2 0 indicated that 2 should be\r\ninserted in the beginning. Modified\r\nLink List = 2,9,5,6.\r\n5 0 indicated that 5 should be\r\ninserted in the beginning. Modified\r\nLink List = 5,2,9,5,6. \r\nFinal linked list = 5, 2, 9, 5, 6.\r\n\r\nExample 2:\r\n\r\nInput:\r\nLinkedList: 5->1->6->1->9->1\r\nOutput: 5 6 9\r\n\r\nThe approach to solving this problem is as follows:\r\n\r\n1. Initialize an empty linked list by setting the `head` pointer to `NULL`.\r\n2. Iterate through the given input literals.\r\n3. If the indicator is 0, insert the integer at the beginning of the linked list by calling the `insertAtBeginning` function. This function creates a new node with the given integer value and inserts it at the beginning of the linked list.\r\n4. If the indicator is 1, insert the integer at the end of the linked list by calling the `insertAtEnd` function. This function creates a new node with the given integer value and inserts it at the end of the linked list.\r\n5. After iterating through all the input literals, the resulting linked list will be the desired output.\r\n\r\nTime complexity of this approach is O(N), where N is the number of input literals, as we need to iterate through all the literals to construct the linked list.\r\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the pointers and temporary variables.",
      "approach": "to solving this problem is as follows:\r\n\r\n1. Initialize an empty linked list by setting the `head` pointer to `NULL`.\r\n2. Iterate through the given input literals.\r\n3. If the indicator is 0, insert the integer at the beginning of the linked list by calling the `insertAtBeginning` function. This function creates a new node with the given integer value and inserts it at the beginning of the linked list.\r\n4. If the indicator is 1, insert the integer at the end of the linked list by calling the `insertAtEnd` function. This function creates a new node with the given integer value and inserts it at the end of the linked list.\r\n5. After iterating through all the input literals, the resulting linked list will be the desired output.\r\n\r\nTime complexity of this approach is O(N), where N is the number of input literals, as we need to iterate through all the literals to construct the linked list.\r\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the pointers and temporary variables.",
      "code": "*/\r\n\r\nNode *insertAtBegining(Node *head, int x) {\r\n    if(head==NULL)\r\n        return new Node(x);\r\n    Node* temp = new Node(x);\r\n    temp->next = head;\r\n    return temp;    \r\n}\r\n\r\n\r\n//Function to insert a node at the end of the linked list.\r\nNode *insertAtEnd(Node *head, int x)  {\r\n    if(head==NULL)\r\n        return new Node(x);\r\n    Node* curr = head;\r\n    while(curr->next){\r\n        curr = curr->next;\r\n    }\r\n    curr->next = new Node(x);\r\n    return head;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "while(curr->next)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\1. Single Linked List\\02.Inserting_node_to_linked_list.cpp",
      "verified": false,
      "needsReview": true
    },
    "deleting-node-in-linked-list": {
      "id": "deleting-node-in-linked-list",
      "title": "Deleting node in linked list",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Given a singly linked list and an integer x.Delete xth node from the singly linked list.\r\n\r\nExample 1:\r\n\r\nInput: 1 -> 3 -> 4 \r\n       x = 3\r\nOutput: 1 -> 3\r\nExplanation:\r\nAfter deleting the node at 3rd\r\nposition (1-base indexing), the\r\nlinked list is as 1 -> 3. \r\nExample 2:\r\n\r\nInput: 1 -> 5 -> 2 -> 9 \r\nx = 2\r\nOutput: 1 -> 2 -> 9\r\nExplanation: \r\nAfter deleting the node at 2nd\r\nposition (1-based indexing), the\r\nlinked list is as 1 -> 2 -> 9.",
      "approach": "- \r\n1. If the given position is 1, it means the node to be deleted is the first node. In this case, we simply update the head pointer to the next node and return the new head.\r\n2. Initialize a counter `cnt` to 1 and a pointer `curr` to the head of the linked list.\r\n3. Traverse the linked list by moving the `curr` pointer to the next node until the counter `cnt` reaches the position just before the node to be deleted.\r\n4. Once we reach the position just before the node to be deleted, we update the `next` pointer of the current node to skip the next node and point to the node after it.\r\n5. Return the head pointer of the modified linked list.\r\n\r\n\r\n\r\nTime complexity of this approach is O(N), where N is the number of nodes in the linked list. We may need to traverse the linked list until we reach the desired position.\r\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the counter variable and the temporary pointer.",
      "code": "*/\r\n\r\nNode* deleteNode(Node *head,int x)\r\n{\r\n    if(x==1)\r\n        return head->next;\r\n    \r\n    int cnt = 1;\r\n    Node* curr = head;\r\n    while(cnt<x-1){\r\n        cnt++;\r\n        curr = curr->next;\r\n    }\r\n    curr->next = curr->next->next;\r\n    return head;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while(cnt<x-1)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\1. Single Linked List\\03.Deleting_node_in_linked_list.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-nodes-linked-list": {
      "id": "count-the-number-of-nodes-linked-list",
      "title": "Count the number of nodes linked list",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Given a singly linked list. The task is to find the length of the linked list, where length is defined as the number of nodes in the linked list.\r\n\r\nExample 1:\r\n\r\nInput:\r\nLinkedList: 1->2->3->4->5\r\nOutput: 5\r\nExplanation: Count of nodes in the \r\nlinked list is 5, which is its length.\r\nExample 2:\r\n\r\nInput:\r\nLinkedList: 2->4->6->7->5->1->0\r\nOutput: 7\r\nExplanation: Count of nodes in the\r\nlinked list is 7. Hence, the output\r\nis 7.",
      "approach": "-\r\n\r\n1. Initialize a variable `cnt` to 0 to keep track of the count.\r\n2. Start with the `curr` pointer pointing to the head of the linked list.\r\n3. Iterate through the linked list by moving the `curr` pointer to the next node in each iteration.\r\n4. Increment the count `cnt` by 1 for each node encountered.\r\n5. Continue the iteration until the `curr` pointer becomes NULL, indicating the end of the linked list.\r\n6. Return the final count `cnt` as the result.\r\n\r\nTime complexity of this approach is O(N), where N is the number of nodes in the linked list. We need to visit each node once to count them.\r\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the count variable and the temporary pointer.",
      "code": "*/\r\n\r\nint getCount(struct Node* head){\r\n    int cnt = 0;\r\n    Node* curr = head;\r\n    while(curr){\r\n        cnt++;\r\n        curr = curr->next;\r\n    }\r\n    return cnt;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while(curr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\1. Single Linked List\\04.Count_the_number_of_nodes_linked_list.cpp",
      "verified": false,
      "needsReview": true
    },
    "search-element-in-linked-list": {
      "id": "search-element-in-linked-list",
      "title": "Search element in linked list",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Given a linked list of n nodes and a key , the task is to check if the key is present in the linked list or not.\r\n\r\nExample:\r\n\r\nInput:\r\nn = 4\r\n1->2->3->4\r\nKey = 3\r\nOutput:\r\nTrue\r\nExplanation:\r\n3 is present in Linked List, so the function returns true.\r\n\r\nAPPROCACH:-\r\nJust traverse the entire Linked List and if node's data matches with the target return true else return false.\r\n\r\nTIME COMPLEXITY:- O(N)\r\nSPACE COMPLEXITY:- O(1)",
      "approach": "",
      "code": "*/\r\nbool searchKey(int n, struct Node* head, int key) {\r\n    struct Node* curr = head;\r\n    while(curr){\r\n        if(curr->data == key)\r\n            return true;\r\n        curr = curr->next;\r\n    }\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while(curr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\1. Single Linked List\\05.Search_element_in_linked_list.cpp",
      "verified": false,
      "needsReview": true
    },
    "introduction-to-double-ll": {
      "id": "introduction-to-double-ll",
      "title": "Introduction to Double LL",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Given a doubly linked list of n elements. The task is to reverse the doubly linked list.\r\n\r\nExample 1:\r\n\r\nInput:\r\nLinkedList: 3 <--> 4 <--> 5\r\nOutput: 5 4 3\r\nExample 2:\r\n\r\nInput:\r\nLinkedList: 75 <--> 122 <--> 59 <--> 196\r\nOutput: 196 59 122 75",
      "approach": "-\r\n1. Initialize two pointers `curr` and `nxt` to traverse the linked list. Set `curr` to the head of the linked list.\r\n2. In each iteration, store the next node in the `nxt` pointer to avoid losing the reference to the next node.\r\n3. Swap the `next` and `prev` pointers of the current node (`curr`).\r\n4. Check if the `prev` pointer of the current node (`curr->prev`) is `NULL`, which indicates that `curr` is the last node of the original linked list. If so, update the `ans` pointer to point to `curr` (the new head of the reversed linked list).\r\n5. Move the `curr` pointer to the previous node (`curr = curr->prev`) using the stored `nxt` pointer.\r\n6. Repeat steps 2-5 until `curr` becomes `NULL`, indicating that we have reached the end of the original linked list.\r\n7. Return the `ans` pointer, which now points to the head of the reversed linked list.\r\n\r\nTime complexity of this approach is O(N), where N is the number of nodes in the doubly linked list. We need to traverse the entire list once to reverse the links.\r\nSpace complexity is O(1) as we are using a constant amount of extra space to store temporary pointers during the reversal process.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\2.Doubly Linked List\\01.Introduction_to_Double_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "insert-node-in-dll": {
      "id": "insert-node-in-dll",
      "title": "Insert node in DLL",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "Given a doubly-linked list, a position p, and an integer x. The task is to add a new node with value x at the position just after pth node in the doubly linked list.\r\n\r\nExample 1:\r\n\r\nInput:\r\nLinkedList: 2<->4<->5\r\np = 2, x = 6 \r\nOutput: 2 4 5 6\r\nExplanation: p = 2, and x = 6. So, 6 is\r\ninserted after p, i.e, at position 3\r\n(0-based indexing).\r\nExample 2:\r\n\r\nInput:\r\nLinkedList: 1<->2<->3<->4\r\np = 0, x = 44\r\nOutput: 1 44 2 3 4\r\nExplanation: p = 0, and x = 44 . So, 44\r\nis inserted after p, i.e, at position 1\r\n(0-based indexing).",
      "approach": "-\r\nThe approach to adding a node at a specific position in a doubly linked list is as follows:\r\n\r\n1. Initialize a counter `cnt` to 0 and a pointer `curr` to the head of the linked list.\r\n2. Traverse the linked list using the `curr` pointer until the `cnt` is less than the specified position.\r\n3. Increment the `cnt` by 1 and move the `curr` pointer to the next node in each iteration.\r\n4. Once the `cnt` reaches the desired position, create a new node with the given data.\r\n5. Set the `next` pointer of the new node to the next node of the current node (`curr->next`) and the `prev` pointer of the new node to the current node (`curr`).\r\n6. Update the `next` pointer of the current node (`curr->next`) to point to the new node.\r\n7. If the new node is inserted in the middle of the list, update the `prev` pointer of the next node (`nxt`) to point to the new node.\r\n8. The new node is successfully inserted into the linked list.\r\n\r\nTime complexity of this approach is O(N), where N is the number of nodes in the doubly linked list. In the worst case, we may need to traverse the entire list to reach the desired position.\r\nSpace complexity is O(1) as we are using a constant amount of extra space to store temporary pointers during the insertion process.",
      "code": "*/\r\n\r\nvoid addNode(Node *head, int pos, int data)\r\n{\r\n   int cnt = 0;\r\n   Node* curr = head;\r\n   while(cnt<pos){\r\n       curr = curr->next;\r\n       cnt++;\r\n   }\r\n   Node* nxt = curr->next;\r\n   curr->next = new Node(data);\r\n   curr->next->prev = curr;\r\n   curr->next->next = nxt;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "while(cnt<pos)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\2.Doubly Linked List\\02.Insert_node_in_DLL.cpp",
      "verified": false,
      "needsReview": true
    },
    "delete-node-in-dll": {
      "id": "delete-node-in-dll",
      "title": "Delete node in DLL",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "",
      "approach": "-\r\n1. The function `deleteNode` takes in two parameters: `head_ref`, which is a pointer to the head of the doubly linked list, and `x`, which represents the position of the node to be deleted.\r\n2. The variable `temp` is initialized as the `head_ref`, which is a pointer to the head node of the linked list.\r\n3. If `x` is equal to 1, it means the node to be deleted is the head node. In this case, the `temp` pointer is moved to the next node, and the new `temp` pointer is returned as the new head of the linked list. This effectively deletes the original head node.\r\n4. If `x` is greater than 1, the code enters a loop that iterates `x-1` times. This loop moves the `temp` pointer to the node just before the position to be deleted.\r\n5. After the loop, the variable `previous` is assigned the value of `temp`, which represents the node just before the position to be deleted.\r\n6. The `previous->next` pointer is adjusted to skip over the node to be deleted by assigning it the value of `temp->next->next`.\r\n7. The `temp->prev` pointer is adjusted to point to the `previous` node, updating the backward link.\r\n8. Finally, the updated `head_ref` is returned.",
      "code": "*/\r\nNode* deleteNode(Node *head_ref, int x) {\r\n  Node* temp = head_ref;\r\n  \r\n  // If the node to be deleted is the head node\r\n  if (x == 1) {\r\n    temp = temp->next;\r\n    return temp;\r\n  }\r\n  \r\n  // Traverse to the node just before the position to be deleted\r\n  for (int i = 1; i < (x - 1); i++) {\r\n    temp = temp->next;\r\n  }\r\n  \r\n  // Store the previous and next nodes of the node to be deleted\r\n  Node* previous = temp;\r\n  previous->next = temp->next->next;\r\n  temp->prev = previous;\r\n  \r\n  return head_ref;\r\n}\r\n\r\n/*\r\nTime Complexity:\r\n- If the node to be deleted is the head node (position 1), the code performs a constant number of operations, resulting in a time complexity of O(1).\r\n- If the node to be deleted is at any other position, the code traverses the linked list until it reaches the node just before the position to be deleted. This traversal requires visiting at most (x-1) nodes, where x is the position of the node to be deleted. Therefore, the time complexity in this case is O(x).\r\nSpace Complexity:\r\n- The code uses a constant amount of extra space for variables (`temp`, `previous`). Hence, the space complexity is O(1).\r\nIn summary, the time complexity of the provided code is O(1) when deleting the head node and O(x) when deleting any other node, where x is the position of the node to be deleted. The space complexity is O(1).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (int i = 1; i < (x - 1)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\2.Doubly Linked List\\03.Delete_node_in_DLL.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-dll": {
      "id": "reverse-dll",
      "title": "Reverse DLL",
      "category": "linked-list",
      "difficulty": "unknown",
      "problemStatement": "",
      "approach": "-\r\n1. The function `reverseDLL` takes in one parameter: `head`, which is a pointer to the head of the doubly linked list.\r\n2. The variable `curr` is initialized with the `head` pointer, which represents the current node being processed.\r\n3. The variable `ans` is initialized as `NULL`. It will store the new head of the reversed linked list.\r\n4. The code enters a `while` loop, which continues until `curr` becomes `NULL`, indicating that all nodes have been processed.\r\n5. Inside the loop, the variable `nxt` is assigned the value of `curr->next`, which represents the next node in the original list.\r\n6. The next and previous pointers of the current node (`curr->next` and `curr->prev`) are swapped to reverse the links.\r\n7. The `if` condition checks if `curr->prev` is `NULL`, indicating that `curr` is the last node in the original list (now the first node in the reversed list). In this case, the `ans` pointer is updated to store the new head of the reversed list.\r\n8. The `curr` pointer is updated to `curr->prev`, which moves it to the previous node in the original list.\r\n9. After the loop, the `ans` pointer now holds the new head of the reversed list. It is returned as the result.",
      "code": "*/\r\nNode* reverseDLL(Node *head) {\r\n    Node* curr = head;\r\n    Node* ans = NULL;\r\n    while(curr) {\r\n        Node* nxt = curr->next;\r\n        curr->next = curr->prev;\r\n        curr->prev = nxt;\r\n        if(curr->prev == NULL)\r\n            ans = curr;\r\n        curr = curr->prev;\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nTime Complexity:\r\n- The code iterates over each node of the doubly linked list exactly once, performing a constant number of operations for each node. Therefore, the time complexity is O(n), where n is the number of nodes in the linked list.\r\nSpace Complexity:\r\n- The code uses a constant amount of extra space for variables (`curr`, `nxt`, `ans`). Hence, the space complexity is O(1).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while(curr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\2.Doubly Linked List\\04.Reverse_DLL.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-mid-of-ll": {
      "id": "find-mid-of-ll",
      "title": "Find mid of LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a singly linked list, return the middle node of the linked list.\r\nIf there are two middle nodes, return the second middle node.\r\n\r\nExample 1:\r\nInput: head = [1,2,3,4,5]\r\nOutput: [3,4,5]\r\nExplanation: The middle node of the list is node 3.\r\n\r\nExample 2:\r\nInput: head = [1,2,3,4,5,6]\r\nOutput: [4,5,6]\r\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.",
      "approach": "-> To find the middle node of a linked list, we can use the two-pointer technique.\r\n-> Initialize two pointers, slow and fast, to the head of the linked list.\r\n-> Move the slow pointer one step at a time and the fast pointer two steps at a time.\r\n-> When the fast pointer reaches the end of the list, the slow pointer will be at the middle node.\r\n-> If the total number of nodes in the list is even, there will be two middle nodes, and the slow pointer will be at the first middle node.\r\n-> To return the second middle node, we need to move the slow pointer one more step.\r\n-> Finally, return the node pointed to by the slow pointer.",
      "code": "ListNode* middleNode(ListNode* head) {\r\n    ListNode* slow = head;\r\n    ListNode* fast = head;\r\n    \r\n    while (fast && fast->next) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n    }\r\n    \r\n    return slow;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "while (fast && fast->next)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\01.Find_mid_of_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-ll": {
      "id": "reverse-ll",
      "title": "Reverse LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.\r\n\r\nExample 1:\r\nInput: head = [1,2,3,4,5]\r\nOutput: [5,4,3,2,1]\r\n\r\nExample 2:\r\nInput: head = [1,2]\r\nOutput: [2,1]",
      "approach": "To reverse a singly linked list, we can use an iterative approach.\r\nInitialize three pointers: prev as NULL, curr as head, and frwd as NULL.\r\nIterate through the linked list until curr becomes NULL:\r\n    - Store the next node of curr in frwd.\r\n    - Set the next of curr to prev, reversing the link.\r\n    - Move prev and curr one step forward.\r\n    - Move curr to the next node (frwd) to continue the iteration.\r\nReturn prev, which will be the new head of the reversed list.",
      "code": "ListNode* reverseList(ListNode* head) {\r\n    ListNode* prev = NULL;\r\n    ListNode* curr = head;\r\n    while (curr) {\r\n        ListNode* frwd = curr->next;\r\n        curr->next = prev;\r\n        prev = curr;\r\n        curr = frwd;\r\n    }\r\n    return prev;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "while (curr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\02.Reverse_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "detect-loop-in-ll": {
      "id": "detect-loop-in-ll",
      "title": "Detect loop in LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\r\n\r\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\r\n\r\nReturn true if there is a cycle in the linked list. Otherwise, return false.\r\n\r\nExample 1:\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\r\n\r\nExample 2:\r\nInput: head = [1,2], pos = 0\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
      "approach": "To determine if a linked list has a cycle, we can use the two-pointer technique.\r\nInitialize two pointers, slow and fast, to the head of the linked list.\r\nMove the slow pointer one step at a time and the fast pointer two steps at a time.\r\nIf the linked list has a cycle, the fast pointer will eventually catch up to the slow pointer.\r\nIn other words, if there is a cycle, the two pointers will meet at some point.\r\nIf the fast pointer reaches the end of the list (i.e., it becomes NULL or reaches a node with a NULL next pointer), then there is no cycle in the linked list.\r\nReturn true if the two pointers meet (indicating a cycle), and false otherwise.",
      "code": "bool hasCycle(ListNode *head) {\r\n    ListNode* slow = head;\r\n    ListNode* fast = head;\r\n\r\n    while (fast && fast->next) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n        if (slow == fast)\r\n            return true;\r\n    }\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "while (fast && fast->next)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\03.Detect_loop_in_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "start-of-cycle-in-ll": {
      "id": "start-of-cycle-in-ll",
      "title": "Start of cycle in LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\r\n\r\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\r\n\r\nDo not modify the linked list.\r\n\r\nExample 1:\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: tail connects to node index 1\r\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\r\n\r\nExample 2:\r\nInput: head = [1,2], pos = 0\r\nOutput: tail connects to node index 0\r\nExplanation: There is a cycle in the linked list, where tail connects to the first node.",
      "approach": "To find the node where the cycle begins in a linked list, we can use the Floyd's cycle-finding algorithm, also known as the \"tortoise and hare\" algorithm.\r\nInitialize two pointers, slow and fast, to the head of the linked list.\r\nMove the slow pointer one step at a time and the fast pointer two steps at a time.\r\nIf the linked list has a cycle, the fast pointer will eventually catch up to the slow pointer.\r\nIn other words, if there is a cycle, the two pointers will meet at some point.\r\nOnce the two pointers meet, move one of the pointers back to the head of the linked list.\r\nThen, move both pointers one step at a time until they meet again.\r\nThe point at which they meet is the node where the cycle begins.\r\nReturn this node.\r\nIf the fast pointer reaches the end of the list (i.e., it becomes NULL or reaches a node with a NULL next pointer), then there is no cycle in the linked list, and we can return NULL.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\04.Start_of_cycle_in_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-nodes-in-loop": {
      "id": "count-nodes-in-loop",
      "title": "Count nodes in loop",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given a linked list of size N. The task is to complete the function countNodesinLoop() that checks whether a given Linked List contains a loop or not and if the loop is present then return the count of nodes in a loop or else return 0. C is the position of the node to which the last node is connected. If it is 0 then no loop.\r\n\r\nExample 1:\r\nInput: N = 10\r\nvalue[]={25,14,19,33,10,21,39,90,58,45}\r\nC = 4\r\nOutput: 7\r\nExplanation: The loop is 45->33. So\r\nlength of loop is 33->10->21->39->\r\n90->58->45 = 7. The number 33 is\r\nconnected to the last node to form the\r\nloop because according to the input the\r\n4th node from the beginning(1 based\r\nindex) will be connected to the last\r\nnode for the loop.\r\n\r\nExample 2:\r\nInput: N = 2\r\nvalue[] = {1,0}\r\nC = 1\r\nOutput: 2\r\nExplanation: The length of the loop\r\nis 2.",
      "approach": "To detect a loop in a linked list, we can use the Floyd's cycle-finding algorithm, also known as the \"tortoise and hare\" algorithm.\r\nInitialize two pointers, slow and fast, to the head of the linked list.\r\nMove the slow pointer one step at a time and the fast pointer two steps at a time.\r\nIf the linked list has a loop, the fast pointer will eventually catch up to the slow pointer.\r\nIn other words, if there is a loop, the two pointers will meet at some point.\r\nOnce the two pointers meet, move one of the pointers back to the meeting point and start counting the number of nodes in the loop.\r\nContinue moving the pointer until it reaches the meeting point again, counting the nodes along the way.\r\nReturn the count of nodes in the loop.\r\nIf the fast pointer reaches the end of the list (i.e., it becomes NULL or reaches a node with a NULL next pointer), then there is no loop in the linked list, and we can return 0.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\05.Count_nodes_in_loop.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-for-palindrome-ll": {
      "id": "check-for-palindrome-ll",
      "title": "Check for palindrome LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\r\n\r\nExample 1:\r\nInput: head = [1,2,2,1]\r\nOutput: true\r\n\r\nExample 2:\r\nInput: head = [1,2]\r\nOutput: false",
      "approach": "To determine if a linked list is a palindrome, we can follow these steps:\r\n1. Find the middle node of the linked list using the slow and fast pointer technique.\r\n2. Reverse the second half of the linked list.\r\n3. Compare the first half of the original linked list with the reversed second half.\r\n4. If all nodes match, the linked list is a palindrome.\r\n5. If any node does not match, the linked list is not a palindrome.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\06.Check_for_palindrome_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "odd-even-ll": {
      "id": "odd-even-ll",
      "title": "Odd even LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\r\n\r\nExample 1:\r\nInput: head = [1,2,3,4,5]\r\nOutput: [1,3,5,2,4]\r\n\r\nExample 2:\r\nInput: head = [2,1,3,5,6,4,7]\r\nOutput: [2,3,6,7,1,5,4]",
      "approach": "To group nodes with odd indices together followed by nodes with even indices, we can follow these steps:\r\n1. Initialize two pointers, `odd` and `even`, to the first and second nodes respectively.\r\n2. Save the starting node of the even list as `evenHead`.\r\n3. Iterate while `odd->next` and `even` are not NULL.\r\n4. Connect the odd list with the next odd node (`odd->next = even->next`).\r\n5. Move the `odd` pointer to the next odd node (`odd = odd->next`).\r\n6. Connect the even list with the next even node (`even->next = odd->next`).\r\n7. Move the `even` pointer to the next even node (`even = even->next`).\r\n8. Connect the end of the odd list with the starting node of the even list (`odd->next = evenHead`).\r\n9. Return the head of the modified list.\r\n\r\nThis approach reorders the linked list in place without using any extra space.\r\n\r\nTIME COMPLEXITY: O(N)\r\nSPACE COMPLEXITY: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\07.Odd_even_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "delete-nth-node-from-back": {
      "id": "delete-nth-node-from-back",
      "title": "Delete nth node from back",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\r\n\r\nExample 1:\r\nInput: head = [1,2,3,4,5], n = 2\r\nOutput: [1,2,3,5]\r\n\r\nExample 2:\r\nInput: head = [1], n = 1\r\nOutput: []\r\n\r\nExample 3:\r\nInput: head = [1,2], n = 1\r\nOutput: [1]",
      "approach": "To remove the nth node from the end of the linked list, we can follow these steps:\r\n1. Initialize two pointers, `left` and `right`, to the head of the linked list.\r\n2. Move the `right` pointer n nodes ahead.\r\n3. If `right` becomes NULL, it means the first node needs to be removed. Return head->next.\r\n4. Iterate until `right->next` becomes NULL.\r\n5. Move both `left` and `right` pointers one node ahead in each iteration.\r\n6. Once `right->next` becomes NULL, `left` will be pointing to the (n-1)th node from the end.\r\n7. Update `left->next` to skip the nth node from the end.\r\n8. Return the head of the modified linked list.\r\n\r\nTIME COMPLEXITY: O(N)\r\nSPACE COMPLEXITY: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\08.Delete_nth_node_from_back.cpp",
      "verified": false,
      "needsReview": true
    },
    "delete-mid-of-ll": {
      "id": "delete-mid-of-ll",
      "title": "Delete mid of LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\r\n\r\nExample:\r\nInput: head = [1,3,4,7,1,2,6]\r\nOutput: [1,3,4,1,2,6]\r\nExplanation:\r\nThe above figure represents the given linked list. The indices of the nodes are written below.\r\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\r\nWe return the new list after removing this node.",
      "approach": "To delete the middle node of a linked list, we can use the slow and fast pointer technique.\r\n1. Initialize three pointers: slow, fast, and prev.\r\n2. Move the slow pointer one step at a time and the fast pointer two steps at a time.\r\n3. Keep track of the previous node using the prev pointer.\r\n4. When the fast pointer reaches the end of the linked list, the slow pointer will be at the middle node.\r\n5. Update the next pointer of the previous node to skip the middle node.\r\n6. Return the head of the modified linked list.\r\n\r\nTIME COMPLEXITY: O(N)\r\nSPACE COMPLEXITY: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\09.Delete_mid_of_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "sort-ll": {
      "id": "sort-ll",
      "title": "Sort LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given the head of a linked list, return the list after sorting it in ascending order.\r\n\r\nExample:\r\nInput: head = [4,2,1,3]\r\nOutput: [1,2,3,4]",
      "approach": "To sort a linked list, we can use the merge sort algorithm.\r\n1. Implement a function to merge two sorted linked lists.\r\n2. Implement a function to recursively divide the linked list into two halves.\r\n3. Apply merge sort on each half.\r\n4. Merge the sorted halves using the merge function.\r\n5. Return the head of the sorted linked list.\r\n\r\nTIME COMPLEXITY: O(NlogN)\r\nSPACE COMPLEXITY: O(logN) - Recursive stack space",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "divide-conquer"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\10.Sort_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "sort-0-1-2-in-ll": {
      "id": "sort-0-1-2-in-ll",
      "title": "Sort 0 1 2 in LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "Given a linked list of N nodes where nodes can contain values 0s, 1s, and 2s only. \r\nThe task is to segregate 0s, 1s, and 2s in the linked list such that all zeros segregate to the head side, 2s at the end of the linked list, and 1s in the middle of 0s and 2s.\r\n\r\nExample:\r\nInput:\r\nN = 8\r\nvalue[] = {1,2,2,1,2,0,2,2}\r\nOutput: 0 1 1 2 2 2 2 2\r\nExplanation: All the 0s are segregated to the left end of the linked list, 2s to the right end of the list, and 1s in between.",
      "approach": "Count the number of 0s, 1s, and 2s in the linked list.\r\nTraverse the linked list and overwrite the nodes with 0s, 1s, and 2s based on their counts.\r\n\r\nTIME COMPLEXITY: O(N)\r\nSPACE COMPLEXITY: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\11.Sort_0_1_2_in_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "add-1-to-ll": {
      "id": "add-1-to-ll",
      "title": "Add 1 to LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "A number N is represented in a linked list such that each digit corresponds to a node in the linked list. \r\nYou need to add 1 to the number represented by the linked list.",
      "approach": "To add 1 to the number represented by the linked list, we can reverse the linked list, perform the addition, and then reverse it back.\r\nFirst, reverse the linked list.\r\nTraverse the reversed linked list while keeping track of the carry.\r\nAdd 1 to the least significant digit (head) and update the carry if necessary.\r\nContinue traversing the linked list, adding the carry to each digit and updating the carry.\r\nIf there is still a remaining carry after traversing the linked list, create a new node with the carry as its value and append it to the end of the linked list.\r\nReverse the linked list again to restore its original order.\r\n\r\nTIME COMPLEXITY: O(N), where N is the length of the linked list.\r\nSPACE COMPLEXITY: O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\12.Add_1_to_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "add-two-ll": {
      "id": "add-two-ll",
      "title": "Add two LL",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "You are given two non-empty linked lists representing two non-negative integers. \r\nThe digits are stored in reverse order, and each of their nodes contains a single digit. \r\nAdd the two numbers and return the sum as a linked list.",
      "approach": "Traverse both linked lists simultaneously, starting from the heads.\r\nAt each step, add the corresponding digits from both linked lists along with the carry (initialized as 0).\r\nCreate a new node with the sum%10 and update the carry as sum/10.\r\nMove to the next nodes in both linked lists.\r\nContinue this process until both linked lists are traversed completely and there is no carry left.\r\nIf one linked list is shorter than the other, consider its remaining digits as 0.\r\nIf there is still a remaining carry, create a new node with the carry and append it to the result linked list.\r\nReturn the head of the result linked list.\r\n\r\nTIME COMPLEXITY: O(max(N, M)), where N and M are the lengths of the two input linked lists.\r\nSPACE COMPLEXITY: O(max(N, M)), as the length of the result linked list can be at most max(N, M)+1.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\3.Medium Problems of LL\\13.Add_two_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "delete-nodes-from-dll": {
      "id": "delete-nodes-from-dll",
      "title": "Delete nodes from dll",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "**\r\n\r\nYou are given the head of a doubly Linked List and a key. Your task is to delete all occurrences of the given key and return the new doubly Linked List.\r\n\r\n**Example:**\r\n\r\nInput: \r\n2 <-> 2 <-> 10 <-> 8 <-> 4 <-> 2 <-> 5 <-> 2\r\nKey: 2\r\nOutput: \r\n10 <-> 8 <-> 4 <-> 5\r\nExplanation: \r\nAll occurrences of 2 have been deleted.\r\n\r\n**",
      "approach": "**\r\n\r\nTo delete all occurrences of the given key from a doubly linked list, we can traverse the list and check each node's data. If the data matches the key, we handle three cases: deleting the first node, deleting the last node, and deleting a middle node. We update the pointers accordingly to remove the node from the list.\r\n\r\n**TIME COMPLEXITY:** The time complexity is O(N), where N is the number of nodes in the doubly linked list.\r\n\r\n**SPACE COMPLEXITY:** The space complexity is O(1) since we are modifying the given linked list in-place without using any extra space.\r\n\r\n**CODE:*",
      "code": "**/\r\n\r\nvoid deleteAllOccurOfX(struct Node** head_ref, int x) {\r\n    Node* curr = *head_ref;\r\n    while (curr) {\r\n        if (curr->data == x) {\r\n            // First node\r\n            if (!curr->prev) {\r\n                *head_ref = curr->next;\r\n                curr->next->prev = NULL\r\n            }\r\n            // Last node\r\n            else if (!curr->next) {\r\n                curr->prev->next = curr->next;\r\n            }\r\n            // Middle node\r\n            else {\r\n                curr->next->prev = curr->prev;\r\n                curr->prev->next = curr->next;\r\n            }\r\n        }\r\n        curr = curr->next;\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while (curr)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\4.Medium Problems of DLL\\01.Delete_nodes_from_dll.cpp",
      "verified": false,
      "needsReview": true
    },
    "pair-sum-in-dll": {
      "id": "pair-sum-in-dll",
      "title": "Pair sum in dll",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "",
      "approach": "1. Initialize two pointers, `start` and `end`, pointing to the beginning and end of the doubly linked list, respectively.\r\n2. While the `start` pointer's data is less than the `end` pointer's data:\r\n   - Calculate the sum of the data at the `start` and `end` pointers.\r\n   - If the sum is equal to the target value, add the pair (start->data, end->data) to the result vector and move both the `start` and `end` pointers.\r\n   - If the sum is less than the target value, move the `start` pointer to the next node.\r\n   - If the sum is greater than the target value, move the `end` pointer to the previous node.\r\n3. Return the result vector containing all the pairs whose sum is equal to the target.\r\n\r\nTime Complexity: O(N), where N is the number of nodes in the doubly linked list.\r\nSpace Complexity: O(1).\r\n\r\nCODE:",
      "code": "*/\r\nvector<pair<int, int>> findPairsWithGivenSum(Node *head, int target)\r\n{\r\n    vector<pair<int, int>> ans;\r\n    Node* start = head;\r\n    Node* end = head;\r\n    while (end->next) {\r\n        end = end->next;\r\n    }\r\n    while (start->data < end->data) {\r\n        int sum = start->data + end->data;\r\n        if (sum == target) {\r\n            ans.push_back({ start->data, end->data });\r\n            start = start->next;\r\n            end = end->prev;\r\n        }\r\n        else if (sum < target) {\r\n            start = start->next;\r\n        }\r\n        else {\r\n            end = end->prev;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<pair<int, int>",
        "vector<pair<int, int>",
        "while (end->next)",
        "while (start->data < end->data)",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\4.Medium Problems of DLL\\02.Pair_sum_in_dll.cpp",
      "verified": false,
      "needsReview": true
    },
    "remove-duplicates-from-dll": {
      "id": "remove-duplicates-from-dll",
      "title": "Remove duplicates from dll",
      "category": "linked-list",
      "difficulty": "medium",
      "problemStatement": "",
      "approach": "1. Initialize a variable `dupli` with the value of the head node.\r\n2. Start from the next node, `curr`, and iterate until the end of the linked list.\r\n3. For each node, check if its data is equal to `dupli`.\r\n   - If it is equal, remove the node by updating the `next` and `prev` pointers of its neighboring nodes.\r\n   - Continue removing all consecutive nodes with the same value.\r\n4. If `curr` is not null, update `dupli` with the data of `curr`.\r\n5. Repeat steps 3-4 until the end of the linked list is reached.\r\n6. Return the head of the modified linked list.\r\n\r\nTime Complexity: O(N), where N is the number of nodes in the linked list.\r\nSpace Complexity: O(1).\r\n\r\nCODE:",
      "code": "*/\r\nNode* removeDuplicates(Node* head)\r\n{\r\n    int dupli = head->data;\r\n    Node* curr = head->next;\r\n\r\n    while (curr) {\r\n        while (curr && curr->data == dupli) {\r\n            if (curr->next)\r\n                curr->next->prev = curr->prev;\r\n            curr->prev->next = curr->next;\r\n            curr = curr->next;\r\n        }\r\n        if (curr) {\r\n            dupli = curr->data;\r\n            curr = curr->next;\r\n        }\r\n    }\r\n    return head;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "while (curr)",
        "while (curr && curr->data == dupli)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\4.Medium Problems of DLL\\03.Remove_duplicates_from_dll.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-k-node-in-groups": {
      "id": "reverse-k-node-in-groups",
      "title": "Reverse k node in groups",
      "category": "linked-list",
      "difficulty": "hard",
      "problemStatement": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.",
      "approach": "The idea is to reverse the nodes of the linked list in groups of size k.\r\nFirst, we need to check if there are at least k nodes remaining in the linked list. If not, we return the head as it is.\r\nNext, we reverse the first k nodes of the linked list. To do this, we maintain three pointers: prev, curr, and frwd.\r\nWe iterate through the first k nodes and at each step, we reverse the links between the nodes.\r\nAfter reversing the first k nodes, prev becomes the new head, and curr becomes the new tail of the reversed group.\r\nWe recursively call the function on the remaining linked list starting from frwd (which points to the (k+1)-th node).\r\nFinally, we update the next pointer of the original head to point to the reversed group obtained from the recursive call.\r\n\r\nTIME COMPLEXITY: O(N), where N is the number of nodes in the linked list.\r\nSPACE COMPLEXITY: O(1).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\5.Hard Promblems of LL\\01.Reverse_k_node_in_groups.cpp",
      "verified": false,
      "needsReview": true
    },
    "rotate-ll-k-times": {
      "id": "rotate-ll-k-times",
      "title": "Rotate LL k times",
      "category": "linked-list",
      "difficulty": "hard",
      "problemStatement": "Given the head of a linked list, rotate the list to the right by k places.",
      "approach": "To rotate the linked list to the right by k places, we need to perform the following steps:\r\n1. Find the length of the linked list and connect the last node to the head to form a circular linked list.\r\n2. Calculate the actual number of rotations by taking the modulus of k with the length of the linked list.\r\n3. Traverse to the (length - k - 1)th node, which will be the new tail of the rotated list.\r\n4. Set the new head as the next node of the (length - k - 1)th node and disconnect it from the rest of the list.\r\n5. Return the new head.\r\n\r\nTIME COMPLEXITY: O(N), where N is the number of nodes in the linked list.\r\nSPACE COMPLEXITY: O(1).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\5.Hard Promblems of LL\\02.Rotate_LL_k_times.cpp",
      "verified": false,
      "needsReview": true
    },
    "copy-ll-with-random-pointers": {
      "id": "copy-ll-with-random-pointers",
      "title": "Copy LL with random pointers",
      "category": "linked-list",
      "difficulty": "hard",
      "problemStatement": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\r\n\r\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\r\n\r\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\r\n\r\nReturn the head of the copied linked list.\r\n\r\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\r\n\r\nval: an integer representing Node.val\r\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\r\nYour code will only be given the head of the original linked list.\r\n\r\nExample 1:\r\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\n\r\nExample 2:\r\nInput: head = [[1,1],[2,1]]\r\nOutput: [[1,1],[2,1]]",
      "approach": "To create a deep copy of a linked list with random pointers, we can follow these steps:\r\n1. Traverse the original linked list and create a new node for each node in the original list. Insert the new node between the original node and its next node.\r\n2. Set the random pointer of the new node by mapping it to the corresponding random node in the original list.\r\n3. Separate the original list and the copied list by updating the next pointers of nodes in both lists.\r\n4. Return the head of the copied list.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of this approach is O(n) since we traverse the original list once to create the copied list.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is also O(n) because we create a new node for each node in the original list.\r\n\r\nCODE:",
      "code": "*/\r\nNode* copyRandomList(Node* head) {\r\n    if (head == NULL)\r\n        return head;\r\n\r\n    // inserting dupli node in between\r\n    Node* orig = head;\r\n    while (orig) {\r\n        Node* temp = orig->next;\r\n        orig->next = new Node(orig->val);\r\n        orig->next->next = temp;\r\n        orig = orig->next->next;\r\n    }\r\n    // setting random pointers\r\n    orig = head;\r\n    while (orig) {\r\n        if (orig->random && orig->next)\r\n            orig->next->random = orig->random->next;\r\n        orig = orig->next->next;\r\n    }\r\n    // setting next pointers and dettaching duplicate nodes from the original list\r\n    orig = head;\r\n    Node* ans = orig->next;\r\n    while (orig && orig->next) {\r\n        Node* temp = orig->next->next;\r\n        if (orig->next->next)\r\n            orig->next->next = orig->next->next->next;\r\n        orig->next = temp;\r\n        orig = orig->next;\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [
        "while (orig)",
        "while (orig)",
        "while (orig && orig->next)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\5.Hard Promblems of LL\\03.Copy_LL_with_random_pointers.cpp",
      "verified": false,
      "needsReview": true
    },
    "flatten-ll": {
      "id": "flatten-ll",
      "title": "Flatten LL",
      "category": "linked-list",
      "difficulty": "hard",
      "problemStatement": "**\r\n\r\nGiven a Linked List of size N, where every node represents a sub-linked-list and contains two pointers:\r\n(i) a next pointer to the next node,\r\n(ii) a bottom pointer to a linked list where this node is the head.\r\nEach of the sub-linked lists is in sorted order.\r\nFlatten the Link List such that all the nodes appear in a single level while maintaining the sorted order.\r\n\r\nNote: The flattened list will be printed using the bottom pointer instead of the next pointer.\r\n\r\n**",
      "approach": "**\r\n\r\nTo flatten the linked list, we can use a recursive approach. The idea is to flatten the list from right to left. Starting from the last node, we recursively flatten the sublist pointed by the bottom pointer and merge it with the current node. We continue this process until we reach the head of the original linked list. Finally, we return the flattened list.\r\n\r\n**TIME COMPLEXITY:** The time complexity is O(N), where N is the total number of nodes in the linked list.\r\n\r\n**SPACE COMPLEXITY:** The space complexity is O(1) since we are modifying the given linked list in-place without using any extra space.\r\n\r\n**CODE:*",
      "code": "**/\r\n\r\nNode* merge(Node* head1, Node* head2)  \r\n{  \r\n    if (head1 == NULL)\r\n        return head2;\r\n    if (head2 == NULL)\r\n        return head1;\r\n    if (head1->data < head2->data) {\r\n        head1->bottom = merge(head1->bottom, head2);\r\n        return head1;\r\n    }\r\n    else {\r\n        head2->bottom = merge(head1, head2->bottom);\r\n        return head2;\r\n    }\r\n}\r\n\r\nNode* flatten(Node* root)\r\n{\r\n    if (root == NULL)\r\n        return root;\r\n\r\n    Node* left = root;\r\n    Node* right = flatten(root->next);\r\n    root->next = NULL;\r\n    left = merge(left, right);\r\n    return left;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\04.Linked List\\5.Hard Promblems of LL\\04.Flatten_LL.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-atoi-via-recursion": {
      "id": "implement-atoi-via-recursion",
      "title": "Implement atoi via recursion",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "",
      "approach": "1. We start from the last character of the string and recursively convert each digit to an integer.\r\n2. We use a helper function `getnum` that takes the index `i` and the string `str` as arguments.\r\n3. The base case is when `i` becomes negative, in which case we return 0.\r\n4. For each digit, we convert it to an integer by subtracting the ASCII value of '0'.\r\n5. We check if the digit is within the range of 0 to 9. If it is, we recursively call `getnum` for the previous index `i-1`.\r\n   - If the recursive call returns a valid number (`prev != 1e9`), we multiply it by 10 and add the current digit.\r\n   - Otherwise, we return a large value `1e9` to indicate an invalid conversion.\r\n6. In the main `atoi` function, we initialize `i` to the index of the last character in the string (`str.size()-1`).\r\n7. We call the `getnum` function with `i` and `str`.\r\n8. If the result (`ans`) is equal to `1e9`, it means the conversion was invalid, so we return -1.\r\n9. If the first character of the string is '-', we return the negative value of `ans`.\r\n10. Otherwise, we return `ans`.\r\n\r\nTime Complexity: O(N), where N is the length of the string.\r\nSpace Complexity: O(N), where N is the length of the string (due to the recursive calls).\r\n\r\nCODE:",
      "code": "*/\r\nint getnum(int i, string& str)\r\n{\r\n    if (i < 0)\r\n        return 0;\r\n\r\n    if (i == 0) {\r\n        if (str[i] == '-')\r\n            return 0;\r\n\r\n        int digit = str[i] - '0';\r\n        if (0 <= digit && digit <= 9) {\r\n            int prev = getnum(i - 1, str);\r\n            if (prev != 1e9)\r\n                return (prev * 10) + digit;\r\n        }\r\n        return 1e9;\r\n    }\r\n\r\n    int digit = str[i] - '0';\r\n    if (0 <= digit && digit <= 9) {\r\n        int prev = getnum(i - 1, str);\r\n        if (prev != 1e9)\r\n            return (prev * 10) + digit;\r\n    }\r\n    return 1e9;\r\n}\r\n\r\nint atoi(string str)\r\n{\r\n    int i = str.size() - 1;\r\n    int ans = getnum(i, str);\r\n    if (ans == 1e9)\r\n        return -1;\r\n    if (str[0] == '-')\r\n        return -1 * ans;\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\1.Get Strong Hold\\01.Implement_atoi_via_recursion.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-good-numbers": {
      "id": "count-good-numbers",
      "title": "Count good numbers",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\r\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\r\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.\r\n\r\nExample 1:\r\nInput: n = 1\r\nOutput: 5\r\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".\r\n\r\nExample 2:\r\nInput: n = 4\r\nOutput: 400\r\n\r\nExample 3:\r\nInput: n = 50\r\nOutput: 564908303",
      "approach": "- We can observe that for a good digit string of length n, each digit can be either even or a prime number (2, 3, 5, or 7).\r\n- For odd indices, there are 4 choices (2, 3, 5, or 7) since they must be prime.\r\n- For even indices, there are 5 choices (0, 2, 4, 6, or 8) since they must be even.\r\n- We can use a recursive approach to count the number of good digit strings.\r\n- The base case is when n = 1, in which case there are 5 possible digit strings (0, 2, 4, 6, or 8).\r\n- For even lengths (n % 2 == 0), we multiply the count of good digit strings of length n-1 by 4 (since there are 4 choices for odd indices).\r\n- For odd lengths (n % 2 != 0), we multiply the count of good digit strings of length n-1 by 5 (since there are 5 choices for even indices).\r\n- We return the result modulo 10^9 + 7 to handle large outputs.\r\n\r\nTime Complexity: O(n) (due to the recursive calls)\r\nSpace Complexity: O(n) (due to the recursive calls)\r\n\r\nCODE:",
      "code": "*/\r\n\r\nconst long long mod = 1e9 + 7;\r\n\r\nint countGoodNumbers(long long n) {\r\n    // Base case\r\n    if (n == 1)\r\n        return 5;\r\n\r\n    if (n % 2 == 0)\r\n        return (countGoodNumbers(n - 1) % mod * 4 % mod);\r\n    else\r\n        return (countGoodNumbers(n - 1) % mod * 5 % mod);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\1.Get Strong Hold\\02.Count_good_numbers.cpp",
      "verified": false,
      "needsReview": true
    },
    "reverse-stack-using-recursion": {
      "id": "reverse-stack-using-recursion",
      "title": "Reverse stack using recursion",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Reverse a given stack of 'N' integers using recursion.\r\nNote: You are not allowed to use any extra space other than the internal stack space used due to recursion.\r\n\r\nExample:\r\nInput: [1,2,3,4,5]\r\nOutput: [5,4,3,2,1]",
      "approach": "To reverse a stack using recursion without using any extra space, we can follow the following steps:\r\n1. Create a helper function called 'insertAtBottom' that takes an element and a stack as parameters.\r\n2. The 'insertAtBottom' function inserts the given element at the bottom of the stack using recursion.\r\n   - If the stack is empty, push the element to the stack and return.\r\n   - Otherwise, pop the top element from the stack and recursively call 'insertAtBottom' with the element and the modified stack.\r\n     After the recursive call, push the popped element back to the stack.\r\n3. Create the main function called 'reverseStack' that reverses the given stack using recursion.\r\n   - Base case: If the stack is empty, return.\r\n   - Otherwise, pop the top element from the stack and recursively call 'reverseStack' on the modified stack.\r\n     After the recursive call, call the 'insertAtBottom' function with the popped element and the modified stack.\r\n4. The 'reverseStack' function will reverse the stack in place using recursion and the 'insertAtBottom' function.\r\n\r\nTime Complexity: O(N^2) (due to multiple recursive calls)\r\nSpace Complexity: O(N) (due to the internal stack space used for recursion)\r\n\r\nCODE:",
      "code": "*/\r\nvoid insertAtBottom(int ele, stack<int>& stack) {\r\n    if (stack.empty()) {\r\n        stack.push(ele);\r\n        return;\r\n    }\r\n\r\n    int temp = stack.top();\r\n    stack.pop();\r\n    insertAtBottom(ele, stack);\r\n    stack.push(temp);\r\n}\r\n\r\nvoid reverseStack(stack<int>& stack) {\r\n    if (stack.empty())\r\n        return;\r\n\r\n    int first = stack.top();\r\n    stack.pop();\r\n    reverseStack(stack);\r\n    insertAtBottom(first, stack);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [
        "stack<int>",
        "stack<int>",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\1.Get Strong Hold\\03.Reverse_stack_using_recursion.cpp",
      "verified": false,
      "needsReview": true
    },
    "sort-stack-using-recursion": {
      "id": "sort-stack-using-recursion",
      "title": "Sort stack using recursion",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a stack, the task is to sort it such that the top of the stack has the greatest element.\r\n\r\nExample 1:\r\nInput:\r\nStack: 3 2 1\r\nOutput: 3 2 1\r\n\r\nExample 2:\r\nInput:\r\nStack: 11 2 32 3 41\r\nOutput: 41 32 11 3 2",
      "approach": "To sort a stack in descending order, we can follow the following steps:\r\n1. Create a helper function called 'placeAtCorrectPos' that takes an element and a stack as parameters.\r\n2. The 'placeAtCorrectPos' function places the given element at the correct position in the stack using recursion.\r\n   - If the stack is empty or the top element of the stack is less than the given element, push the element to the stack and return.\r\n   - Otherwise, pop the top element from the stack and recursively call 'placeAtCorrectPos' with the element and the modified stack.\r\n     After the recursive call, push the popped element back to the stack.\r\n3. Create the main function called 'sortSt' that sorts the stack in descending order using recursion.\r\n   - Base case: If the stack is empty, return.\r\n   - Otherwise, pop the top element from the stack and recursively call 'sortSt' on the modified stack.\r\n     After the recursive call, call the 'placeAtCorrectPos' function with the popped element and the modified stack.\r\n4. The 'sortSt' function will sort the stack in descending order using recursion and the 'placeAtCorrectPos' function.\r\n\r\nTime Complexity: O(N^2) (due to multiple recursive calls)\r\nSpace Complexity: O(N) (due to the internal stack space used for recursion)\r\n\r\nCODE:",
      "code": "*/\r\nvoid placeAtCorrectPos(int ele, stack<int>& st) {\r\n\tif (st.empty() || st.top() < ele) {\r\n\t\tst.push(ele);\r\n\t\treturn;\r\n\t}\r\n\r\n\tint first = st.top();\r\n\tst.pop();\r\n\tplaceAtCorrectPos(ele, st);\r\n\tst.push(first);\r\n}\r\n\r\nvoid sortSt(stack<int>& st) {\r\n\tif (st.empty())\r\n\t\treturn;\r\n\r\n\tint first = st.top();\r\n\tst.pop();\r\n\tsortSt(st);\r\n\tplaceAtCorrectPos(first, st);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [
        "stack<int>",
        "stack<int>",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\1.Get Strong Hold\\04.Sort_stack_using_recursion.cpp",
      "verified": false,
      "needsReview": true
    },
    "genereate-all-valid-parenthesis": {
      "id": "genereate-all-valid-parenthesis",
      "title": "Genereate all valid parenthesis",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n\r\nExample 1:\r\nInput: n = 3\r\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\r\n\r\nExample 2:\r\nInput: n = 1\r\nOutput: [\"()\"]",
      "approach": "To generate all combinations of well-formed parentheses, we can use a recursive approach. We can start with an empty string and keep track of the number of open parentheses and close parentheses used so far.\r\n1. Create a helper function called 'solve' that takes a vector of strings, a string representing the current combination, the count of open parentheses, the count of close parentheses, and the total number of pairs of parentheses as parameters.\r\n2. In the 'solve' function:\r\n   - If both the counts of open parentheses and close parentheses are equal to the total number of pairs of parentheses, add the current combination to the vector of strings.\r\n   - If the count of open parentheses is less than or equal to the total number of pairs of parentheses, recursively call 'solve' by appending an open parenthesis to the current combination and incrementing the count of open parentheses.\r\n   - If the count of open parentheses is greater than the count of close parentheses, recursively call 'solve' by appending a close parenthesis to the current combination and incrementing the count of close parentheses.\r\n3. Create the main function called 'generateParenthesis' that generates all combinations of well-formed parentheses using the 'solve' function.\r\n   - Create an empty vector of strings to store the combinations.\r\n   - Call the 'solve' function with an empty string, count of open parentheses as 0, count of close parentheses as 0, and the total number of pairs of parentheses as 'n'.\r\n   - Return the vector of strings containing all the combinations.\r\n\r\nTime Complexity: O(2^N * N), where N is the given number of pairs of parentheses.\r\nSpace Complexity: O(N), where N is the given number of pairs of parentheses (for the recursion stack and storing combinations).\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid solve(vector<string>& ans, string s, int open, int close, int n) {\r\n\tif (open == n && close == n){\r\n\t\tans.push_back(s);\r\n        return;\r\n    }\r\n\r\n\tif (open <= n)\r\n\t\tsolve(ans, s + '(', open + 1, close, n);\r\n\tif (open > close)\r\n\t\tsolve(ans, s + ')', open, close + 1, n);\r\n}\r\n\r\nvector<string> generateParenthesis(int n) {\r\n\tvector<string> ans;\r\n\tsolve(ans, \"\", 0, 0, n);\r\n\treturn ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<string>",
        "vector<string>",
        "vector<string>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\01.Genereate all valid parenthesis.cpp",
      "verified": false,
      "needsReview": true
    },
    "power-set": {
      "id": "power-set",
      "title": "Power set",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums of unique elements, return all possible subsets (the power set).\r\n\r\nExample 1:\r\nInput: nums = [1,2,3]\r\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\r\n\r\nExample 2:\r\nInput: nums = [0]\r\nOutput: [[],[0]]",
      "approach": "To generate all possible subsets, we can use a recursive backtracking approach.\r\n1. Create a helper function called 'solve' that takes a vector of vectors to store the subsets, a vector to store the current subset, the input array 'nums', and the current index as parameters.\r\n2. In the 'solve' function:\r\n   - If the current index is equal to the size of the input array 'nums', add the current subset to the vector of vectors.\r\n   - Otherwise, do the following:\r\n     - Include the element at the current index in the current subset by pushing it into the vector.\r\n     - Recursively call the 'solve' function with the updated current subset and increment the current index.\r\n     - Exclude the element at the current index from the current subset by popping it from the vector.\r\n     - Recursively call the 'solve' function with the updated current subset and increment the current index.\r\n3. Create the main function called 'subsets' that generates all possible subsets using the 'solve' function.\r\n   - Create an empty vector of vectors to store the subsets.\r\n   - Create an empty vector to store the current subset.\r\n   - Call the 'solve' function with the empty vector of vectors, empty current subset, input array 'nums', and index 0.\r\n   - Return the vector of vectors containing all the subsets.\r\n\r\nTime Complexity: O(2^N), where N is the size of the input array 'nums'.\r\nSpace Complexity: O(N), where N is the size of the input array 'nums' (for the recursion stack and storing subsets).\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(vector<vector<int>>& ans, vector<int>& temp, vector<int>& nums, int index) {\r\n\tif (index == nums.size()) {\r\n\t\tans.push_back(temp);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Include the element at the current index\r\n\ttemp.push_back(nums[index]);\r\n\tsolve(ans, temp, nums, index + 1);\r\n\r\n\t// Exclude the element at the current index\r\n\ttemp.pop_back();\r\n\tsolve(ans, temp, nums, index + 1);\r\n}\r\n\r\nvector<vector<int>> subsets(vector<int>& nums) {\r\n\tvector<vector<int>> ans;\r\n\tvector<int> temp;\r\n\tsolve(ans, temp, nums, 0);\r\n\treturn ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\02.Power set.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-distinct-substrings": {
      "id": "count-distinct-substrings",
      "title": "Count distinct substrings",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a string consisting of lowercase English alphabets, the task is to find the number of distinct subsequences of the string. Note that the answer can be very large, so the output will be the answer modulo 10^9 + 7.\r\n\r\nExample:\r\nInput: s = \"gfg\"\r\nOutput: 7\r\nExplanation: The seven distinct subsequences are \"\", \"g\", \"f\", \"gf\", \"fg\", \"gg\", and \"gfg\".",
      "approach": "To find the number of distinct subsequences, we can use a recursive approach with backtracking.\r\n1. Create a set to store the distinct subsequences.\r\n2. Create a helper function called 'solve' that takes the input string 's', the current index, and a temporary string as parameters.\r\n3. In the 'solve' function:\r\n   - If the current index is equal to the size of the input string 's', insert the temporary string into the set of distinct subsequences.\r\n   - Otherwise, do the following:\r\n     - Include the character at the current index in the temporary string by appending it.\r\n     - Recursively call the 'solve' function with the updated temporary string and the next index.\r\n     - Exclude the character at the current index from the temporary string.\r\n     - Recursively call the 'solve' function with the updated temporary string and the next index.\r\n4. Create the main function called 'distinctSubsequences' that calculates the number of distinct subsequences.\r\n   - Initialize an empty string as the temporary string.\r\n   - Call the 'solve' function with the input string 's', index 0, and the empty temporary string.\r\n   - Return the size of the set of distinct subsequences modulo 10^9 + 7.\r\n\r\nTime Complexity: O(2^N), where N is the length of the input string 's'.\r\nSpace Complexity: O(2^N), where N is the length of the input string 's' (for storing the distinct subsequences in the set).\r\n\r\nCODE:",
      "code": "*/\r\nunordered_set<string> st;\r\n\r\nvoid solve(string& s, int index, string& temp) {\r\n\tif (index == s.size()) {\r\n\t\tst.insert(temp);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Include the character at the current index\r\n\ttemp.push_back(s[index]);\r\n\tsolve(s, index + 1, temp);\r\n\r\n\t// Exclude the character at the current index\r\n\ttemp.pop_back();\r\n\tsolve(s, index + 1, temp);\r\n}\r\n\r\nint distinctSubsequences(string s) {\r\n\tstring temp = \"\";\r\n\tsolve(s, 0, temp);\r\n\treturn st.size() % (int)(1e9 + 7);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "unordered_set<string>",
        ".insert(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\03.Count distinct substrings.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-subsets-with-sum-equal-to-k": {
      "id": "count-subsets-with-sum-equal-to-k",
      "title": "Count subsets with sum equal to k",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an array arr[] of non-negative integers and an integer sum, the task is to count all subsets of the given array with a sum equal to the given sum. The answer can be very large, so the output will be the answer modulo 10^9 + 7.\r\n\r\nExample:\r\nInput: N = 6, arr[] = {2, 3, 5, 6, 8, 10}, sum = 10\r\nOutput: 3\r\nExplanation: The subsets with a sum equal to 10 are {2, 3, 5}, {2, 8}, and {10}.",
      "approach": "To count the subsets with a given sum, we can use a recursive approach with backtracking.\r\n1. Create a helper function called 'solve' that takes the current index, the remaining sum, and the array as parameters.\r\n2. In the 'solve' function:\r\n   - If the remaining sum is 0, return 1 (found a subset with the given sum).\r\n   - If the index becomes 0 and the remaining sum is not 0, return 0 (no subset found with the given sum).\r\n   - Otherwise, do the following:\r\n     - Count the subsets that include the element at the current index by recursively calling the 'solve' function with the updated index and the remaining sum minus the element value.\r\n     - Count the subsets that exclude the element at the current index by recursively calling the 'solve' function with the updated index and the remaining sum.\r\n     - Return the sum of the counts from the include and exclude steps.\r\n3. Create the main function called 'perfectSum' that calculates the count of subsets with the given sum.\r\n   - Call the 'solve' function with the last index of the array, the given sum, and the array.\r\n   - Return the count modulo 10^9 + 7.\r\n\r\nTime Complexity: O(N * sum), where N is the size of the array and sum is the given sum.\r\nSpace Complexity: O(N * sum), where N is the size of the array and sum is the given sum (for recursion stack).\r\n\r\nCODE:",
      "code": "*/\r\nint solve(int index, int sum, int arr[]) {\r\n\tif (sum == 0) {\r\n\t\treturn 1;\r\n\t}\r\n\tif (index == 0) {\r\n\t\treturn (arr[0] == sum) ? 1 : 0;\r\n\t}\r\n\r\n\tint include = 0;\r\n\tif (arr[index] <= sum)\r\n\t\tinclude = solve(index - 1, sum - arr[index], arr); // include\r\n\r\n\tint exclude = solve(index - 1, sum, arr); // exclude\r\n\r\n\treturn (include + exclude) % (int)(1e9 + 7);\r\n}\r\n\r\nint perfectSum(int arr[], int n, int sum) {\r\n\tint cnt = solve(n - 1, sum, arr);\r\n\treturn cnt % (int)(1e9 + 7);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\04.Count subsets with sum equal to k.cpp",
      "verified": false,
      "needsReview": true
    },
    "subset-1": {
      "id": "subset-1",
      "title": "Subset 1",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a list arr of N integers, print the sums of all subsets in it.\r\n\r\nExample:\r\nInput:\r\nN = 2\r\narr[] = {2, 3}\r\nOutput:\r\n0 2 3 5\r\nExplanation:\r\nWhen no element is taken, the sum is 0.\r\nWhen only 2 is taken, the sum is 2.\r\nWhen only 3 is taken, the sum is 3.\r\nWhen elements 2 and 3 are taken, the sum is 2 + 3 = 5.",
      "approach": "To print the sums of all subsets, we can use a recursive approach with backtracking.\r\n1. Create a helper function called 'solve' that takes the current index, the current sum, the array, and a vector to store the sums as parameters.\r\n2. In the 'solve' function:\r\n   - If the current index is equal to the size of the array, add the current sum to the vector of sums and return.\r\n   - Otherwise, do the following:\r\n     - Include the element at the current index in the sum by recursively calling the 'solve' function with the updated index and the current sum plus the element value.\r\n     - Exclude the element at the current index from the sum by recursively calling the 'solve' function with the updated index and the current sum.\r\n3. Create the main function called 'subsetSums' that calculates and returns the vector of subset sums.\r\n   - Initialize an empty vector to store the subset sums.\r\n   - Call the 'solve' function with the initial index as 0, the initial sum as 0, the array, and the vector of subset sums.\r\n   - Sort the vector of subset sums in ascending order.\r\n   - Return the vector of subset sums.\r\n\r\nTime Complexity: O(2^N), where N is the size of the array.\r\nSpace Complexity: O(N), where N is the size of the array (for recursion stack and storing subset sums).\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(int index, int sum, vector<int>& arr, vector<int>& ans) {\r\n\tif (index == arr.size()) {\r\n\t\tans.push_back(sum);\r\n\t\treturn;\r\n\t}\r\n\r\n\tsolve(index + 1, sum + arr[index], arr, ans);\r\n\tsolve(index + 1, sum, arr, ans);\r\n}\r\n\r\nvector<int> subsetSums(vector<int> arr, int N) {\r\n\tvector<int> ans;\r\n\tint sum = 0;\r\n\tsolve(0, sum, arr, ans);\r\n\tsort(ans.begin(), ans.end());\r\n\treturn ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "sort(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\05.Subset 1.cpp",
      "verified": false,
      "needsReview": true
    },
    "subset-2": {
      "id": "subset-2",
      "title": "Subset 2",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\r\n\r\nExample:\r\nInput: nums = [1,2,2]\r\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\r\nExample:\r\nInput: nums = [0]\r\nOutput: [[],[0]]",
      "approach": "To find all possible subsets without duplicates, we can use a recursive backtracking approach.\r\n1. Sort the input array nums in non-decreasing order to handle duplicates.\r\n2. Create a helper function called 'solve' that takes the current index, the array nums, a temporary vector to store the current subset, and a vector of vector to store all subsets as parameters.\r\n3. In the 'solve' function:\r\n   - Add the current subset to the vector of subsets.\r\n   - Iterate from the current index to the end of the array:\r\n     - If the current index is greater than the starting index and the current element is the same as the previous element, skip the iteration to avoid duplicates.\r\n     - Add the current element to the current subset.\r\n     - Recursively call the 'solve' function with the updated index, the array nums, the current subset, and the vector of subsets.\r\n     - Remove the last added element from the current subset (backtracking).\r\n4. Create the main function called 'subsetsWithDup' that calculates and returns the vector of subsets without duplicates.\r\n   - Sort the input array nums.\r\n   - Initialize an empty vector to store the subsets.\r\n   - Call the 'solve' function with the initial index as 0, the array nums, an empty temporary vector, and the vector of subsets.\r\n   - Return the vector of subsets.\r\n\r\nTime Complexity: O(2^N), where N is the size of the input array nums. This is because there are 2^N possible subsets.\r\nSpace Complexity: O(N), where N is the size of the input array nums. This is the space required to store the subsets.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid solve(int index, vector<int>& nums, vector<int>& temp, vector<vector<int>>& ans){\r\n    if(index==nums.size()){\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n    // to include\r\n    temp.push_back(nums[index]);\r\n    solve(index+1,nums,temp,ans);\r\n    temp.pop_back();\r\n\r\n    // to remove duplicates\r\n    while(index+1<nums.size() && nums[index]==nums[index+1])\r\n        index++;\r\n\r\n    // to exclude\r\n    solve(index+1,nums,temp,ans);\r\n}\r\n\r\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\r\n\tsort(nums.begin(), nums.end());\r\n\tvector<vector<int>> ans;\r\n\tvector<int> temp;\r\n\tsolve(0, nums, temp, ans);\r\n\treturn ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "while(index+1<nums.size()",
        "sort(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\06.Subset 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "combination-sum-1": {
      "id": "combination-sum-1",
      "title": "Combination Sum 1",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\r\n\r\nExample:\r\nInput: candidates = [2,3,6,7], target = 7\r\nOutput: [[2,2,3],[7]]\r\nExplanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.",
      "approach": "To find all unique combinations that sum up to the target, we can use a recursive backtracking approach.\r\n1. Create a helper function called 'solve' that takes the current index, the array of candidates, the target sum, a temporary vector to store the current combination, and a vector of vector to store all combinations as parameters.\r\n2. In the 'solve' function:\r\n   - If the target sum is equal to 0, add the current combination to the vector of combinations.\r\n   - If the current index is equal to the size of the array, return.\r\n   - If the current candidate value is less than or equal to the target sum:\r\n     - Add the current candidate to the current combination.\r\n     - Recursively call the 'solve' function with the updated index, the same array of candidates, the reduced target sum by subtracting the current candidate value, the current combination, and the vector of combinations.\r\n     - Remove the last added candidate from the current combination (backtracking).\r\n   - Recursively call the 'solve' function with the updated index by incrementing it, the same array of candidates, the same target sum, the current combination, and the vector of combinations.\r\n3. Create the main function called 'combinationSum' that calculates and returns the vector of combinations.\r\n   - Initialize an empty vector to store the combinations.\r\n   - Sort the array of candidates in non-decreasing order to handle duplicates.\r\n   - Call the 'solve' function with the initial index as 0, the array of candidates, the target sum, an empty temporary vector, and the vector of combinations.\r\n   - Return the vector of combinations.\r\n\r\nTime Complexity: O(N^target), where N is the size of the array of candidates and target is the target sum. In the worst case, we may have to explore all possible combinations, which is exponential.\r\nSpace Complexity: O(target), as the maximum depth of the recursion tree is determined by the target sum.\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(int index, vector<int>& candidates, int target, vector<int>& temp, vector<vector<int>>& ans) {\r\n    if (target == 0) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    if (index == candidates.size() || target < 0)\r\n        return;\r\n\r\n    if (candidates[index] <= target) {\r\n        temp.push_back(candidates[index]);\r\n        solve(index, candidates, target - candidates[index], temp, ans);\r\n        temp.pop_back();\r\n    }\r\n\r\n    solve(index + 1, candidates, target, temp, ans);\r\n}\r\n\r\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\r\n    vector<vector<int>> ans;\r\n    sort(candidates.begin(), candidates.end());\r\n    vector<int> temp;\r\n    solve(0, candidates, target, temp, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "sort(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\07.Combination Sum 1.cpp",
      "verified": false,
      "needsReview": true
    },
    "combination-sum-2": {
      "id": "combination-sum-2",
      "title": "Combination Sum 2",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.\r\n\r\nExample:\r\nInput: candidates = [10,1,2,7,6,1,5], target = 8\r\nOutput: [[1,1,6],[1,2,5],[1,7],[2,6]]\r\nExplanation: The sum of the combinations [1,1,6], [1,2,5], [1,7], and [2,6] is equal to the target 8.",
      "approach": "To find all unique combinations that sum up to the target, we can use a recursive backtracking approach.\r\n1. Create a helper function called 'solve' that takes the current index, the target sum, the array of candidates, a temporary vector to store the current combination, and a vector of vector to store all combinations as parameters.\r\n2. Sort the array of candidates in non-decreasing order to handle duplicates.\r\n3. In the 'solve' function:\r\n   - If the target sum is equal to 0, add the current combination to the vector of combinations.\r\n   - If the current index is equal to the size of the array, return.\r\n   - If the current candidate value is less than or equal to the target sum:\r\n     - Add the current candidate to the current combination.\r\n     - Recursively call the 'solve' function with the updated index by incrementing it, the reduced target sum by subtracting the current candidate value, the same array of candidates, the current combination, and the vector of combinations.\r\n     - Remove the last added candidate from the current combination (backtracking).\r\n   - To handle duplicates, skip the candidates with the same value as the current candidate by incrementing the index until a different candidate is found.\r\n   - Recursively call the 'solve' function with the updated index by incrementing it, the same target sum, the same array of candidates, the current combination, and the vector of combinations.\r\n4. Create the main function called 'combinationSum2' that calculates and returns the vector of combinations.\r\n   - Initialize an empty vector to store the combinations.\r\n   - Call the 'solve' function with the initial index as 0, the target sum, the sorted array of candidates, an empty temporary vector, and the vector of combinations.\r\n   - Return the vector of combinations.\r\n\r\nTime Complexity: O(N * 2^N), where N is the size of the array of candidates. In the worst case, we may have to explore all possible combinations, which is exponential.\r\nSpace Complexity: O(target), as the maximum depth of the recursion tree is determined by the target sum.\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(int index, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& ans) {\r\n    if (target == 0) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    if (index == candidates.size() || target < 0)\r\n        return;\r\n\r\n    if (candidates[index] <= target) {\r\n        temp.push_back(candidates[index]);\r\n        solve(index + 1, target - candidates[index], candidates, temp, ans);\r\n        temp.pop_back();\r\n    }\r\n\r\n    while (index + 1 < candidates.size() && candidates[index] == candidates[index + 1])\r\n        index++;\r\n\r\n    solve(index + 1, target, candidates, temp, ans);\r\n}\r\n\r\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\r\n    vector<vector<int>> ans;\r\n    vector<int> temp;\r\n    sort(candidates.begin(), candidates.end());\r\n    solve(0, target, candidates, temp, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "while (index + 1 < candidates.size()",
        "sort(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\08.Combination Sum 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "combination-sum-3": {
      "id": "combination-sum-3",
      "title": "Combination Sum 3",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\r\n- Only numbers 1 through 9 are used.\r\n- Each number is used at most once.\r\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\r\n\r\nExample:\r\nInput: k = 3, n = 7\r\nOutput: [[1,2,4]]\r\nExplanation: 1 + 2 + 4 = 7. There are no other valid combinations.",
      "approach": "To find all valid combinations of k numbers that sum up to n, we can use a recursive backtracking approach.\r\n1. Create a helper function called 'solve' that takes the current index, the number of elements to choose (k), the target sum (tar), the array of available numbers (nums), a temporary vector to store the current combination, and a vector of vector to store all combinations as parameters.\r\n2. In the 'solve' function:\r\n   - If the target sum is equal to 0 and the size of the current combination is equal to k, add the current combination to the vector of combinations.\r\n   - If the current index is equal to the size of the array or the target sum is less than 0, return.\r\n   - If the current number is less than or equal to the target sum:\r\n     - Add the current number to the current combination.\r\n     - Recursively call the 'solve' function with the updated index by incrementing it, the same number of elements to choose (k), the reduced target sum by subtracting the current number, the same array of available numbers (nums), the current combination, and the vector of combinations.\r\n     - Remove the last added number from the current combination (backtracking).\r\n   - Recursively call the 'solve' function with the updated index by incrementing it, the same number of elements to choose (k), the same target sum, the same array of available numbers (nums), the current combination, and the vector of combinations.\r\n3. Create the main function called 'combinationSum3' that calculates and returns the vector of combinations.\r\n   - Initialize an array of available numbers containing numbers from 1 to 9.\r\n   - Initialize an empty vector to store the combinations.\r\n   - Call the 'solve' function with the initial index as 0, the number of elements to choose (k), the target sum (n), the array of available numbers, an empty temporary vector, and the vector of combinations.\r\n   - Return the vector of combinations.\r\n\r\nTime Complexity: O(2^9), as there are 9 available numbers and we have to explore all possible combinations.\r\nSpace Complexity: O(k), as the maximum depth of the recursion tree is determined by the number of elements to choose (k).\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(int i, int k, int tar, vector<int>& nums, vector<int>& temp, vector<vector<int>>& ans) {\r\n    if (tar == 0 && temp.size() == k) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    if (i == nums.size() || tar < 0)\r\n        return;\r\n\r\n    if (nums[i] <= tar) {\r\n        temp.push_back(nums[i]);\r\n        solve(i + 1, k, tar - nums[i], nums, temp, ans);\r\n        temp.pop_back();\r\n    }\r\n\r\n    solve(i + 1, k, tar, nums, temp, ans);\r\n}\r\n\r\nvector<vector<int>> combinationSum3(int k, int n) {\r\n    vector<int> nums;\r\n    for (int i = 1; i <= 9; i++) {\r\n        nums.push_back(i);\r\n    }\r\n\r\n    vector<vector<int>> ans;\r\n    vector<int> temp;\r\n    solve(0, k, n, nums, temp, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "for (int i = 1; i <= 9; i++)",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\09.Combination Sum 3.cpp",
      "verified": false,
      "needsReview": true
    },
    "letter-combinations-of-phone": {
      "id": "letter-combinations-of-phone",
      "title": "Letter combinations of phone",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\r\n\r\nExample:\r\nInput: digits = \"23\"\r\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
      "approach": "We can use a recursive backtracking approach to generate all possible letter combinations.\r\n1. Create a helper function called 'solve' that takes the current index, the input string of digits, a temporary string to store the current combination, the vector to store all combinations, and a mapping vector that maps each digit to its corresponding letters.\r\n2. In the 'solve' function:\r\n   - If the current index is equal to the size of the input string, add the current combination to the vector of combinations and return.\r\n   - Get the corresponding digit at the current index from the input string.\r\n   - Iterate through the letters associated with the current digit:\r\n     - Append the current letter to the temporary string.\r\n     - Recursively call the 'solve' function with the updated index by incrementing it, the same input string of digits, the updated temporary string, the vector of combinations, and the mapping vector.\r\n     - Remove the last added letter from the temporary string (backtracking).\r\n3. Create the main function called 'letterCombinations' that calculates and returns the vector of combinations.\r\n   - Check if the input string is empty. If so, return an empty vector.\r\n   - Initialize a mapping vector that maps each digit to its corresponding letters.\r\n   - Initialize an empty temporary string.\r\n   - Initialize an empty vector to store the combinations.\r\n   - Call the 'solve' function with the initial index as 0, the input string of digits, the temporary string, the vector of combinations, and the mapping vector.\r\n   - Return the vector of combinations.\r\n\r\nTime Complexity: O(3^N * 4^M), where N is the number of digits that map to 3 letters and M is the number of digits that map to 4 letters.\r\nSpace Complexity: O(N + M), where N is the number of digits that map to 3 letters and M is the number of digits that map to 4 letters.\r\n\r\nCODE:",
      "code": "*/\r\nvoid solve(int index, string digits, string& temp, vector<string>& ans, vector<string>& mp) {\r\n    if (index == digits.size()) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    int num = digits[index] - '0';\r\n    for (int i = 0; i < mp[num].size(); i++) {\r\n        temp.push_back(mp[num][i]);\r\n        solve(index + 1, digits, temp, ans, mp);\r\n        temp.pop_back();\r\n    }\r\n}\r\n\r\nvector<string> letterCombinations(string digits) {\r\n    if (digits.empty())\r\n        return {};\r\n\r\n    vector<string> mp{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\r\n    string temp = \"\";\r\n    vector<string> ans;\r\n    solve(0, digits, temp, ans, mp);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<string>",
        "vector<string>",
        "vector<string>",
        "for (int i = 0; i < mp[num].size()",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\2.Subsequences Pattern\\10.Letter combinations of phone.cpp",
      "verified": false,
      "needsReview": true
    },
    "palindrome-partioning": {
      "id": "palindrome-partioning",
      "title": "Palindrome partioning",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\r\n\r\nExample:\r\nInput: s = \"aab\"\r\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
      "approach": "We can use a recursive backtracking approach to generate all possible palindrome partitioning.\r\n1. Create a helper function called 'solve' that takes the current index, the input string 's', a temporary vector to store the current partition, and the vector to store all partitions.\r\n2. In the 'solve' function:\r\n   - If the current index is greater than or equal to the size of the input string 's', add the current partition to the vector of partitions and return.\r\n   - Iterate through all possible substrings starting from the current index to the end of the string.\r\n   - Check if the current substring is a palindrome by using a helper function 'isPalindrome'.\r\n   - If the current substring is a palindrome:\r\n     - Add the current substring to the temporary partition vector.\r\n     - Recursively call the 'solve' function with the updated index by incrementing it, the same input string 's', the updated temporary partition vector, and the vector of partitions.\r\n     - Remove the last added substring from the temporary partition vector (backtracking).\r\n3. Create the main function called 'partition' that calculates and returns the vector of partitions.\r\n   - Initialize an empty vector to store the partitions.\r\n   - Initialize an empty temporary vector to store the current partition.\r\n   - Call the 'solve' function with the initial index as 0, the input string 's', the temporary partition vector, and the vector of partitions.\r\n   - Return the vector of partitions.\r\n\r\nTime Complexity: O(N * 2^N), where N is the length of the input string 's'. In the worst case, we can have 2^N possible partitions, and for each partition, we need to check if each substring is a palindrome, which takes O(N) time.\r\nSpace Complexity: O(N), where N is the length of the input string 's'. The space is used for storing the temporary partition vector and the vector of partitions.\r\n\r\nCODE:",
      "code": "*/\r\nbool isPalindrome(string& palin){\r\n    int i = 0, j = palin.size() - 1;\r\n    while (i < j) {\r\n        if (palin[i] != palin[j])\r\n            return false;\r\n        i++;\r\n        j--;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid solve(int i, string& s, vector<string>& temp, vector<vector<string>>& ans) {\r\n    if (i >= s.size()) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    for (int p = i; p < s.size(); p++) {\r\n        string palin = s.substr(i, p - i + 1);\r\n        if (isPalindrome(palin)) {\r\n            temp.push_back(palin);\r\n            solve(p + 1, s, temp, ans);\r\n            temp.pop_back();\r\n        }\r\n    }\r\n}\r\n\r\nvector<vector<string>> partition(string s) {\r\n    vector<vector<string>> ans;\r\n    vector<string> temp;\r\n    solve(0, s, temp, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<string>",
        "vector<vector<string>",
        "vector<vector<string>",
        "for (int p = i; p < s.size()",
        "while (i < j)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\01.Palindrome partioning.cpp",
      "verified": false,
      "needsReview": true
    },
    "word-search-in-grid": {
      "id": "word-search-in-grid",
      "title": "Word search in grid",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\r\n\r\nExample 1:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\r\nOutput: true\r\n\r\nExample 3:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\r\nOutput: false",
      "approach": "We can use a backtracking approach to solve this problem.\r\n1. Create a helper function called 'solve' that takes the current row index, column index, letter index, the target word, and the board.\r\n2. In the 'solve' function:\r\n   - If the letter index is equal to the length of the target word, set the flag to true and return.\r\n   - Check if the current cell value is equal to the target letter.\r\n   - If it is, mark the current cell as visited (by changing its value to '!') and recursively call the 'solve' function for its neighboring cells (up, down, left, and right).\r\n   - After the recursive call, restore the original value of the current cell.\r\n3. Create the main function called 'exist' that calculates and returns true if the word exists in the grid, false otherwise.\r\n   - Initialize a flag variable to false.\r\n   - Iterate through each cell in the grid.\r\n   - If the current cell value is equal to the first letter of the target word, mark the current cell as visited (by changing its value to '!') and call the 'solve' function with the current cell's coordinates, letter index as 1, the target word, and the board.\r\n   - If the flag is true, return true (word exists in the grid).\r\n   - If the loop completes without finding the word, return false.\r\n   \r\nTime Complexity: O(M * N * 4^L), where M is the number of rows, N is the number of columns in the grid, and L is the length of the target word. In the worst case, we traverse the entire grid for each letter in the target word, and we have 4 choices (up, down, left, right) at each step.\r\nSpace Complexity: O(L), where L is the length of the target word. The space is used for the recursive call stack.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Note:- I'm making recursive call only for the potential grids rather than making call for the all four to reduce unwanted calls,\r\n// this makes code quite big but if you want to make it compact you could make call for all four cases and after call check if it's valid\r\n// just check the code of rat in maze for shorter code\r\n\r\nbool flag = false;\r\n\r\nvoid solve(int i, int j, int ltr, string& word, vector<vector<char>>& board) {\r\n    if (ltr == word.size()) {\r\n        flag = true;\r\n        return;\r\n    }\r\n\r\n    // left\r\n    if (j - 1 >= 0 && board[i][j - 1] == word[ltr]) {\r\n        board[i][j - 1] = '!';\r\n        solve(i, j - 1, ltr + 1, word, board);\r\n        board[i][j - 1] = word[ltr];\r\n    }\r\n    // right\r\n    if (j + 1 < board[0].size() && board[i][j + 1] == word[ltr]) {\r\n        board[i][j + 1] = '!';\r\n        solve(i, j + 1, ltr + 1, word, board);\r\n        board[i][j + 1] = word[ltr];\r\n    }\r\n    // top\r\n    if (i - 1 >= 0 && board[i - 1][j] == word[ltr]) {\r\n        board[i - 1][j] = '!';\r\n        solve(i - 1, j, ltr + 1, word, board);\r\n        board[i - 1][j] = word[ltr];\r\n    }\r\n    // bottom\r\n    if (i + 1 < board.size() && board[i + 1][j] == word[ltr]) {\r\n        board[i + 1][j] = '!';\r\n        solve(i + 1, j, ltr + 1, word, board);\r\n        board[i + 1][j] = word[ltr];\r\n    }\r\n}\r\n\r\nbool exist(vector<vector<char>>& board, string word) {\r\n    flag = false;\r\n\r\n    for (int i = 0; i < board.size(); i++) {\r\n        for (int j = 0; j < board[0].size(); j++) {\r\n            if (board[i][j] == word[0]) {\r\n                board[i][j] = '!';\r\n                solve(i, j, 1, word, board);\r\n                board[i][j] = word[0];\r\n                if (flag)\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<char>",
        "vector<vector<char>",
        "for (int i = 0; i < board.size()",
        "for (int j = 0; j < board[0].size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\02.Word search in grid.cpp",
      "verified": false,
      "needsReview": true
    },
    "rat-in-maze": {
      "id": "rat-in-maze",
      "title": "Rat in maze",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Consider a rat placed at (0, 0) in a square matrix of order N * N. It has to reach the destination at (N - 1, N - 1). Find all possible paths that the rat can take to reach from source to destination. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and rat cannot move to it while value 1 at a cell in the matrix represents that rat can be travel through it.\r\n\r\nExample 1:\r\n\r\nInput:\r\nN = 4\r\nm[][] = {{1, 0, 0, 0},\r\n         {1, 1, 0, 1}, \r\n         {1, 1, 0, 0},\r\n         {0, 1, 1, 1}}\r\nOutput:\r\nDDRDRR DRDDRR\r\nExplanation:\r\nThe rat can reach the destination at \r\n(3, 3) from (0, 0) by two paths - DRDDRR \r\nand DDRDRR, when printed in sorted order \r\nwe get DDRDRR DRDDRR.",
      "approach": "We can use a backtracking approach to find all possible paths.\r\n1. Create a helper function called 'solve' that takes the current row index, column index, a string representing the current path, a vector of strings to store the paths, the matrix, and the size of the matrix.\r\n2. In the 'solve' function:\r\n   - If the current position is the destination (N-1, N-1), add the current path to the vector of paths and return.\r\n   - Check if the current position is valid and not a blocked cell.\r\n   - Mark the current position as visited (by setting its value to 0) to avoid revisiting it.\r\n   - Recursively call the 'solve' function for the neighboring cells (left, right, up, down) with the updated path.\r\n   - After the recursive calls, restore the original value of the current position to allow other paths to visit it.\r\n3. Create the main function called 'findPath' that calculates and returns all possible paths from (0, 0) to (N-1, N-1).\r\n   - If the source cell or the destination cell is blocked, return an empty vector.\r\n   - Initialize an empty vector of strings to store the paths.\r\n   - Call the 'solve' function with the initial position (0, 0), an empty path string, the vector of paths, the matrix, and the size of the matrix.\r\n   - Return the vector of paths.\r\n   \r\nTime Complexity: O(3^(N^2)), where N is the size of the matrix. In the worst case, each cell can have three possible neighboring cells to explore.\r\nSpace Complexity: O(N^2), as we are using a vector of strings to store the paths.\r\n\r\nCODE:",
      "code": "*/\r\nbool isValid(int i, int j, vector<vector<int>>& m, int n) {\r\n    if (i < 0 || i >= n || j < 0 || j >= n || m[i][j] == 0)\r\n        return false;\r\n    return true;\r\n}\r\n\r\nvoid solve(int i, int j, string temp, vector<string>& ans, vector<vector<int>>& m, int n) {\r\n    if (i == n - 1 && j == n - 1) {\r\n        ans.push_back(temp);\r\n        return;\r\n    }\r\n\r\n    if (!isValid(i, j, m, n))\r\n        return;\r\n\r\n    m[i][j] = 0;\r\n\r\n    solve(i, j - 1, temp + 'L', ans, m, n);\r\n    solve(i, j + 1, temp + 'R', ans, m, n);\r\n    solve(i - 1, j, temp + 'U', ans, m, n);\r\n    solve(i + 1, j, temp + 'D', ans, m, n);\r\n\r\n    m[i][j] = 1;\r\n}\r\n\r\nvector<string> findPath(vector<vector<int>>& m, int n) {\r\n    if (m[0][0] == 0 || m[n - 1][n - 1] == 0)\r\n        return {};\r\n\r\n    vector<string> ans;\r\n    string temp = \"\";\r\n    solve(0, 0, temp, ans, m, n);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<string>",
        "vector<vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\03.Rat in maze.cpp",
      "verified": false,
      "needsReview": true
    },
    "m-coloring-problem": {
      "id": "m-coloring-problem",
      "title": "M coloring problem",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given an undirected graph and an integer M. The task is to determine if the graph can be colored with at most M colors such that no two adjacent vertices of the graph are colored with the same color. Here coloring of a graph means the assignment of colors to all vertices. Print 1 if it is possible to colour vertices and 0 otherwise.",
      "approach": "We can solve this problem using backtracking.\r\n1. Create a helper function called 'isPossible' that takes the graph, an array of colors assigned to vertices, the number of vertices, the color to be assigned, and the current vertex.\r\n   - Iterate through all the adjacent vertices of the current vertex.\r\n   - If an adjacent vertex is already colored with the same color, return false.\r\n   - If there is no conflict, continue checking other adjacent vertices.\r\n   - If all adjacent vertices have different colors or are uncolored, return true.\r\n2. Create another helper function called 'solve' that takes the graph, the number of colors, the number of vertices, an array of colors assigned to vertices, and the current vertex.\r\n   - If all vertices have been assigned colors, return true.\r\n   - Iterate through all possible colors from 1 to M.\r\n   - If it is possible to assign the current color to the current vertex without any conflict, assign the color and recursively call the 'solve' function for the next vertex.\r\n   - If the 'solve' function returns true, return true.\r\n   - If the 'solve' function returns false, try the next color.\r\n   - If no color can be assigned to the current vertex without any conflict, return false.\r\n3. Create the main function called 'graphColoring' that initializes an array of colors and calls the 'solve' function to check if it is possible to color the graph.\r\n   - If the 'solve' function returns true, return true.\r\n   - Otherwise, return false.\r\n\r\nTime Complexity: O(M^N), where M is the number of colors and N is the number of vertices in the graph. In the worst case, we have to try all possible color combinations for all vertices.\r\nSpace Complexity: O(N), as we are using an array of colors to store the assigned colors for each vertex.\r\n\r\nCODE:",
      "code": "*/\r\nbool isPossible(bool graph[101][101], int color[], int N, int col, int node) {\r\n    for (int k = 0; k < N; k++) {\r\n        if (k != node && graph[node][k] == 1 && color[k] == col)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nbool solve(bool graph[101][101], int m, int N, int color[], int node) {\r\n    if (node == N)\r\n        return true;\r\n\r\n    for (int i = 1; i <= m; i++) {\r\n        if (isPossible(graph, color, N, i, node)) {\r\n            color[node] = i;\r\n            if (solve(graph, m, N, color, node + 1))\r\n                return true;\r\n            color[node] = 0;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool graphColoring(bool graph[101][101], int m, int N) {\r\n    int color[N];\r\n    memset(color, 0, sizeof color);\r\n    if (solve(graph, m, N, color, 0))\r\n        return true;\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "for (int k = 0; k < N; k++)",
        "for (int i = 1; i <= m; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\04.M coloring problem.cpp",
      "verified": false,
      "needsReview": true
    },
    "n-queens": {
      "id": "n-queens",
      "title": "N queens",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\r\n * Given an integer n, return all distinct solutions to the n-queens puzzle.\r\n *\r\nExample 1:\r\n\r\n\r\nInput: n = 4\r\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\r\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\r\n\r\n *",
      "approach": "* 1. Use backtracking to solve the n-queens puzzle.\r\n * 2. Start with an empty chessboard and try placing queens in each row, ensuring that no two queens threaten each other.\r\n * 3. Use row, column, and diagonal constraints to validate the queen placements.\r\n * 4. If a valid configuration is found, add it to the list of solutions.\r\n *\r\n * Time Complexity: O(N!), where N is the input parameter representing the size of the chessboard.\r\n *   - In the worst case, there can be N! possible configurations to check.\r\n *   - However, with the pruning technique used in backtracking, the actual runtime is much less than N! in most cases.\r\n *\r\n * Space Complexity: O(N^2), where N is the input parameter representing the size of the chessboard.\r\n *   - The space is used to store the chessboard configuration and the auxiliary arrays for tracking the used columns and diagonals.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\05.N queens.cpp",
      "verified": false,
      "needsReview": true
    },
    "word-break": {
      "id": "word-break",
      "title": "Word Break",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\r\n * \r\n * Example:\r\n * Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\r\n * Output: true\r\n * Explanation: Return true because \"leetcode\" can be segmented as \"leet code\".\r\n *\r\n *",
      "approach": "* We can solve this problem using a recursive approach with backtracking.\r\n * 1. Start from the beginning of the string and try to find a word from the dictionary that matches a substring starting at the current index.\r\n * 2. If we find a match, recursively call the function on the remaining substring.\r\n * 3. Repeat this process until we reach the end of the string.\r\n * 4. If we can successfully break the string into words, we return true. Otherwise, we return false.\r\n *\r\n * Time Complexity: O(2^N), where N is the length of the string. In the worst case, we can have 2^N recursive calls.\r\n * Space Complexity: O(N), where N is the length of the string. The recursion stack can go up to N in the worst case.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\06.Word Break.cpp",
      "verified": false,
      "needsReview": true
    },
    "sudoku-solver": {
      "id": "sudoku-solver",
      "title": "Sudoku solver",
      "category": "recursion",
      "difficulty": "unknown",
      "problemStatement": "Write a program to solve a Sudoku puzzle by filling the empty cells.\r\n\r\nA sudoku solution must satisfy all of the following rules:\r\n- Each of the digits 1-9 must occur exactly once in each row.\r\n- Each of the digits 1-9 must occur exactly once in each column.\r\n- Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\r\n- The '.' character indicates empty cells.\r\n\r\nExample:\r\nInput:\r\n[\r\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\r\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\r\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\r\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\r\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\r\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\r\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\r\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\r\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\r\n]\r\n\r\nOutput:\r\n[\r\n  [\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\r\n  [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],\r\n  [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\r\n  [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\r\n  [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\r\n  [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],\r\n  [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\r\n  [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\r\n  [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]\r\n]",
      "approach": "We can solve the Sudoku puzzle using a backtracking approach.\r\n1. Iterate over each cell in the board.\r\n2. If the cell is empty (denoted by '.'), try placing a digit from 1 to 9.\r\n3. Check if the placement is valid by verifying that the digit does not already exist in the same row, column, or 3x3 sub-box.\r\n4. If the placement is valid, update the cell with the digit and move to the next cell recursively.\r\n5. If the placement is not valid or we have reached the end of the board, backtrack by undoing the placement and trying the next digit.\r\n6. Repeat this process until we have filled all the cells or found a valid solution.\r\n\r\nTime Complexity: The time complexity of the backtracking algorithm for solving a Sudoku puzzle is O(9^(m*n)), where m and n are the number of rows and columns in the board. In the worst case, we have to try all possible combinations.\r\nSpace Complexity: The space complexity is O(1) as we are using a constant amount of space for the board and temporary variables.",
      "code": "*/\r\n\r\nbool isValid(int row, int col, char digit, vector<vector<char>>& board) {\r\n    for (int i = 0; i < 9; i++) {\r\n        if (board[row][i] == digit)\r\n            return false;\r\n        if (board[i][col] == digit)\r\n            return false;\r\n        if (board[3 * (row / 3) + (i / 3)][3 * (col / 3) + (i % 3)] == digit)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nbool solve(vector<vector<char>>& board) {\r\n    for (int i = 0; i < board.size(); i++) {\r\n        for (int j = 0; j < board[0].size(); j++) {\r\n            if (board[i][j] == '.') {\r\n                for (char digit = '1'; digit <= '9'; digit++) {\r\n                    if (isValid(i, j, digit, board)) {\r\n                        board[i][j] = digit;\r\n                        if (solve(board))\r\n                            return true;\r\n                        board[i][j] = '.';\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<char>",
        "vector<vector<char>",
        "for (int i = 0; i < 9; i++)",
        "for (int i = 0; i < board.size()",
        "for (int j = 0; j < board[0].size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\05.Recursion\\3.Try Out All Combos\\07.Sudoku solver.cpp",
      "verified": false,
      "needsReview": true
    },
    "bit-manipulation": {
      "id": "bit-manipulation",
      "title": "Bit Manipulation",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a 32-bit unsigned integer num and an integer i, perform the following operations on the number:\r\n1. Get the ith bit.\r\n2. Set the ith bit.\r\n3. Clear the ith bit.\r\n\r\nNote: The bits are indexed from 1 instead of 0 (1-based indexing).\r\n\r\nExample:\r\nInput: 70, 3\r\nOutput: 1 70 66\r\nExplanation:\r\n- The bit at the 3rd position from the least significant bit (LSB) is 1. (1 0 0 0 1 1 0)\r\n- The value of the given number after setting the 3rd bit is 70.\r\n- The value of the given number after clearing the 3rd bit is 66. (1 0 0 0 0 1 0)",
      "approach": "1. Subtract 1 from i to adjust the index to 0-based.\r\n2. To get the ith bit, perform a bitwise AND operation between num and (1 << i). If the result is non-zero, the ith bit is set; otherwise, it is cleared.\r\n3. To set the ith bit, perform a bitwise OR operation between num and (1 << i).\r\n4. To clear the ith bit, perform a bitwise AND operation between num and the complement of (1 << i).\r\n\r\nCODE:",
      "code": "*/\r\nvoid bitManipulation(int num, int i) {\r\n    i = i - 1; // Adjusting index to 0-based\r\n    \r\n    // Get the ith bit\r\n    if (num & (1 << i))\r\n        cout << 1 << \" \";\r\n    else\r\n        cout << 0 << \" \";\r\n    \r\n    // Set the ith bit\r\n    int set = num | (1 << i);\r\n    cout << set << \" \";\r\n    \r\n    // Clear the ith bit\r\n    int clear = num & (~(1 << i));\r\n    cout << clear;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\01.Bit Manipulation.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-for-the-ith-bit": {
      "id": "check-for-the-ith-bit",
      "title": "Check for the ith bit",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a number N and a bit number K, check if the Kth index bit of N is set or not. A bit is called set if it is 1. The position of the set bit '1' should be indexed starting with 0 from the least significant bit (LSB) side in the binary representation of the number.\r\n\r\nExample:\r\nInput: N = 4, K = 0\r\nOutput: No\r\nExplanation: The binary representation of 4 is 100, in which the 0th index bit from the LSB is not set. So, return false.",
      "approach": "1. Perform a bitwise AND operation between N and (1 << K).\r\n2. If the result is non-zero, it means the Kth index bit is set (1); otherwise, it is not set (0).\r\n\r\nCODE:",
      "code": "*/\r\nbool checkKthBit(int n, int k) {\r\n    if (n & (1 << k))\r\n        return true;\r\n    return false;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\02.Check for the ith bit.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-for-odd-even": {
      "id": "check-for-odd-even",
      "title": "Check for odd even",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a positive integer N, determine whether it is odd or even.\r\n\r\nExample 1:\r\n\r\nInput:\r\nN = 1\r\nOutput:\r\nodd\r\nExplanation:\r\nThe number 1 is odd.",
      "approach": "To determine whether a positive integer N is odd or even, we can check the least significant bit (LSB) of N. \r\nIf the LSB is 1, the number is odd. If the LSB is 0, the number is even.\r\nWe can use the bitwise AND operation with 1 (N & 1) to check the LSB.\r\nIf the result is 1, we return \"odd\". If the result is 0, we return \"even\".\r\n\r\n\r\nCODE",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\03.Check for odd even.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-for-the-power-of-2": {
      "id": "check-for-the-power-of-2",
      "title": "Check for the power of 2",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given an integer n, return true if it is a power of two. Otherwise, return false.\r\n\r\nExample 1:\r\nInput: n = 1\r\nOutput: true\r\nExplanation: 2^0 = 1\r\n\r\nExample 2:\r\nInput: n = 16\r\nOutput: true\r\nExplanation: 2^4 = 16",
      "approach": "An integer n is a power of two if it has only one bit set (i.e., it is a power of 2).\r\nTo check if a number has only one bit set, we can use the bitwise AND operation with (n-1).\r\nIf the result is 0, then it is a power of two; otherwise, it is not.\r\n\r\n1. If n is less than or equal to 0, return false.\r\n2. Perform the bitwise AND operation between n and (n-1).\r\n3. If the result is 0, return true; otherwise, return false.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\04.Check for the power of 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "set-the-righmost-unset-bit": {
      "id": "set-the-righmost-unset-bit",
      "title": "Set the righmost unset bit",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a non-negative number N, set the rightmost unset bit in its binary representation. If there are no unset bits, leave the number as it is.\r\n\r\nExample:\r\nInput: N = 6\r\nOutput: 7\r\nExplanation:\r\nThe binary representation of 6 is 110.\r\nAfter setting the rightmost unset bit, it becomes 111 which is 7.\r\n\r\nInput: N = 15\r\nOutput: 15\r\nExplanation:\r\nThe binary representation of 15 is 1111.\r\nSince there are no unset bits, it remains the same.",
      "approach": "To set the rightmost unset bit in the binary representation of N, we can follow these steps:\r\n1. Check if N+1 is a power of 2. If it is, then N already has all bits set, so return N.\r\n2. Otherwise, perform the bitwise OR operation between N and (N+1). This will set the rightmost unset bit.\r\n3. Return the result.\r\n\r\n1. Check if N+1 is a power of 2 by using the isPowerOfTwo function.\r\n2. If it is, return N as it already has all bits set.\r\n3. Otherwise, perform the bitwise OR operation between N and (N+1) and return the result.\r\n\r\nCODE:",
      "code": "*/\r\nbool isPowerOfTwo(int n) {\r\n    if(n <= 0)\r\n        return false;\r\n    if(n & (n-1))\r\n        return false;\r\n    return true;\r\n}\r\n\r\nint setBit(int N)\r\n{\r\n    if(isPowerOfTwo(N+1))\r\n        return N;\r\n\r\n    int ans = (N | (N+1));\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\05.Set the righmost unset bit.cpp",
      "verified": false,
      "needsReview": true
    },
    "swap-two-numbers-without-temporary-variable": {
      "id": "swap-two-numbers-without-temporary-variable",
      "title": "Swap two numbers without temporary variable",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given two numbers a and b, swap their values without using a temporary variable and return them.\r\n\r\nExample:\r\nInput: a = 13, b = 9\r\nOutput: 9 13\r\nExplanation: After swapping, the values become 9 and 13.",
      "approach": "To swap two numbers a and b without using a temporary variable, we can use the XOR (^) operation.\r\n1. Set a = a XOR b, which XORs the binary representations of a and b and stores the result in a.\r\n2. Set b = a XOR b, which XORs the new value of a (after step 1) with the original value of b, and stores the result in b.\r\n3. Set a = a XOR b, which XORs the new value of a (after step 1) with the new value of b (after step 2), and stores the result in a.\r\n4. The values of a and b are swapped.\r\n\r\nCODE:",
      "code": "*/\r\npair<int, int> get(int a, int b){\r\n    a = a^b;\r\n    b = a^b; \r\n    a = a^b;\r\n    return {a, b};\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\06.Swap two numbers without temporary variable.cpp",
      "verified": false,
      "needsReview": true
    },
    "divide-two-numbers-using-bit-maipulation": {
      "id": "divide-two-numbers-using-bit-maipulation",
      "title": "Divide two numbers using bit maipulation",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given two integers dividend and divisor, find the quotient after dividing dividend by divisor without using multiplication, division, and mod operator.\r\n\r\nExample:\r\nInput: dividend = 10, divisor = 3\r\nOutput: 3\r\nExplanation: 10/3 gives a quotient of 3 and remainder of 1.",
      "approach": "To divide two integers without using multiplication, division, and mod operator, we can use a bitwise shifting approach.\r\n1. Initialize a variable ans as 0 to store the quotient.\r\n2. Check if the dividend and divisor have different signs to determine the sign of the quotient.\r\n3. Take the absolute values of the dividend and divisor to work with positive numbers.\r\n4. Iterate while the absolute value of the dividend is greater than or equal to the absolute value of the divisor:\r\n    a. Initialize a variable q as 1 to represent the current quotient digit.\r\n    b. Iterate while the absolute value of the dividend is greater than the absolute value of the divisor left-shifted by q:\r\n        i. Increment q.\r\n    c. Add (1 << (q - 1)) to the quotient ans.\r\n    d. Subtract the absolute value of the divisor left-shifted by (q - 1) from the absolute value of the dividend.\r\n5. Return the quotient ans, considering the sign based on the step 2.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint divideTwoInteger(int dividend, int divisor) {\r\n    if (dividend == divisor)\r\n        return 1;\r\n\r\n    bool isNegative = ((dividend < 0 && divisor >= 0) || (dividend >= 0 && divisor < 0));\r\n\r\n    int ans = 0;\r\n    int a = abs(dividend);\r\n    int b = abs(divisor);\r\n\r\n    while (a >= b) {\r\n        // at each stage we will find the greatest power of 2 which is smaller than the dividend\r\n        int q = 1;\r\n        while (a > (b << q))\r\n            q++;\r\n        ans += (1 << (q - 1));\r\n        a -= (b << (q - 1));\r\n    }\r\n\r\n    return (isNegative) ? -ans : ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while (a >= b)",
        "while (a > (b << q)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\07.Divide two numbers using bit maipulation.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-set-bit-from-numbers-1-to-n": {
      "id": "count-set-bit-from-numbers-1-to-n",
      "title": "Count set bit from numbers 1 to n",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "You are given a number N. Find the total count of set bits for all numbers from 1 to N (both inclusive).\r\n\r\nExample:\r\nInput: N = 4\r\nOutput: 5\r\nExplanation:\r\nFor numbers from 1 to 4:\r\n- For 1: 0 0 1 = 1 set bit\r\n- For 2: 0 1 0 = 1 set bit\r\n- For 3: 0 1 1 = 2 set bits\r\n- For 4: 1 0 0 = 1 set bit\r\nTherefore, the total set bits is 5.",
      "approach": "The approach to solve this problem is based on the observation that the count of set bits in the binary representation of a number `n` can be determined by the following formula:\r\ncountSetBits(n) = countSetBits(pow(2, x - 1) * x) + (n - pow(2, x) + 1) + countSetBits(n - pow(2, x))\r\n\r\nCODE:",
      "code": "*/\r\nint countSetBits(int n) {\r\n    if (n <= 1)\r\n        return n;\r\n    int x = log2(n); // Find the greatest power of 2 less than n\r\n    return (pow(2, x - 1) * x) + (n - pow(2, x) + 1) + countSetBits(n - pow(2, x));\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\1. Learn Bit Manipulation\\08.Count set bit from numbers 1 to n.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-bit-flips": {
      "id": "minimum-bit-flips",
      "title": "Minimum bit flips",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0. Given two integers start and goal, return the minimum number of bit flips required to convert start to goal.\r\n\r\nExample:\r\nInput: start = 10, goal = 7\r\nOutput: 3\r\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\r\n- Flip the first bit from the right: 1010 -> 1011.\r\n- Flip the third bit from the right: 1011 -> 1111.\r\n- Flip the fourth bit from the right: 1111 -> 0111.\r\nIt can be shown that we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
      "approach": "To find the minimum number of bit flips required to convert start to goal, we can iterate over each bit position from right to left and compare the corresponding bits in start and goal. If they are different, we increment a counter. Finally, we return the counter.\r\n\r\nCODE:",
      "code": "*/\r\nint minBitFlips(int start, int goal) {\r\n    int i = 0;\r\n    int cnt = 0;\r\n    while (i < 32) {\r\n        int startbit = (start >> i) & 1;\r\n        int goalbit = (goal >> i) & 1;\r\n        if (startbit != goalbit)\r\n            cnt++;\r\n        i++;\r\n    }\r\n    return cnt;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while (i < 32)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\2. Interview Problems\\01. Minimum bit flips.cpp",
      "verified": false,
      "needsReview": true
    },
    "exceptionally-odd": {
      "id": "exceptionally-odd",
      "title": "Exceptionally odd",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given an array of N positive integers where all numbers occur an even number of times except one number which occurs an odd number of times. Find the exceptional number.\r\n\r\nExample:\r\nInput: N = 7, Arr[] = {1, 2, 3, 2, 3, 1, 3}\r\nOutput: 3\r\nExplanation: Number 3 occurs three times, which is an odd number of times, while all other numbers occur an even number of times.",
      "approach": "To find the exceptional number, we can use the bitwise XOR operation. XORing a number with itself results in 0, so XORing all the numbers in the array will cancel out the even occurrences, leaving only the exceptional number in the result.\r\n\r\nCODE:",
      "code": "*/\r\nint getOddOccurrence(int arr[], int n) {\r\n    int xr = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        xr = xr ^ arr[i];\r\n    }\r\n    return xr;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for (int i = 0; i < n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\2. Interview Problems\\02. Exceptionally odd.cpp",
      "verified": false,
      "needsReview": true
    },
    "xor-of-numbers-from-l-to-r": {
      "id": "xor-of-numbers-from-l-to-r",
      "title": "XOR of numbers from L to R",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "You are given two integers L and R, your task is to find the XOR of elements of the range [L, R].\r\n\r\nExample:\r\n\r\nInput:\r\nL = 4, R = 8\r\nOutput:\r\n8\r\nExplanation:\r\n4 ^ 5 ^ 6 ^ 7 ^ 8 = 8",
      "approach": "The XOR of a range [L, R] can be calculated by XORing the XORs of the individual numbers in the range [1, L-1] and [1, R].\r\nWe can observe a pattern in the XOR values based on the remainders of the numbers divided by 4.\r\nUsing this pattern, we can calculate the XOR of a given number n by applying some conditions.\r\n\r\n1. If n % 4 == 0, the XOR value is n.\r\n2. If n % 4 == 1, the XOR value is 1.\r\n3. If n % 4 == 2, the XOR value is n+1.\r\n4. If n % 4 == 3, the XOR value is 0.\r\n\r\nBy calculating the XOR values for L-1 and R separately using the above pattern, we can XOR them to get the final result.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint calculateXOR(int n) {\r\n    if (n % 4 == 0)\r\n        return n;\r\n    if (n % 4 == 1)\r\n        return 1;\r\n    if (n % 4 == 2)\r\n        return n + 1;\r\n    if (n % 4 == 3)\r\n        return 0;\r\n}\r\n\r\nint findXOR(int L, int R) {\r\n    int uptol = calculateXOR(L - 1);\r\n    int uptor = calculateXOR(R);\r\n    return uptor ^ uptol;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The time complexity is O(1) as the calculations are based on simple arithmetic operations.\r\n- The space complexity is O(1) as no extra space is required.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\2. Interview Problems\\03. XOR of numbers from L to R.cpp",
      "verified": false,
      "needsReview": true
    },
    "prime-factors-of-number": {
      "id": "prime-factors-of-number",
      "title": "Prime factors of number",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a number N, find its unique prime factors in increasing order.\r\n\r\nExample:\r\nInput: N = 100\r\nOutput: 2 5\r\nExplanation: 2 and 5 are the unique prime factors of 100.",
      "approach": "To find the unique prime factors of a number N, we can iterate from 2 to sqrt(N) and check if each number divides N.\r\n1. Initialize an empty vector `ans` to store the prime factors.\r\n2. Iterate from 2 to sqrt(N):\r\n   - If `i` divides `N` (i.e., N % i == 0):\r\n     - Add `i` to `ans`.\r\n     - Divide `N` by `i` until it is no longer divisible by `i`.\r\n3. If `N` is still greater than 1, it means that `N` itself is a prime factor. Add it to `ans`.\r\n4. Return `ans`.\r\n\r\nCODE:",
      "code": "*/\r\nvector<int> AllPrimeFactors(int n) {\r\n    vector<int> ans;\r\n    for (int i = 2; i * i <= n; i++) {\r\n        if (n % i == 0) {\r\n            ans.push_back(i);\r\n            while (n % i == 0)\r\n                n /= i;\r\n        }\r\n    }\r\n    if (n > 1)\r\n        ans.push_back(n);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int i = 2; i * i <= n; i++)",
        "while (n % i == 0)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\3. Advanced Maths\\01. Prime factors of number.cpp",
      "verified": false,
      "needsReview": true
    },
    "all-divisors-of-number": {
      "id": "all-divisors-of-number",
      "title": "All divisors of number",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given an integer N, print all the divisors of N in ascending order.\r\n\r\nExample:\r\nInput: 20\r\nOutput: 1 2 4 5 10 20\r\nExplanation: 20 is completely divisible by 1, 2, 4, 5, 10, and 20.",
      "approach": "To print all the divisors of a number N, we can iterate from 1 to sqrt(N) and check if each number divides N.\r\n1. Initialize an empty vector `temp` to store the divisors greater than sqrt(N).\r\n2. Iterate from 1 to sqrt(N):\r\n   - If `i` divides `N` (i.e., N % i == 0):\r\n     - Print `i`.\r\n     - If N/i != i, it means N/i is a divisor. Add it to `temp`.(we are checking N/i != i because 6*6 = 36 so our divisor should be 1 time 6)\r\n3. Reverse the elements in `temp` vector.\r\n4. Print all the elements in `temp`.\r\n5. The divisors of N will be printed in ascending order.\r\n\r\nCODE:",
      "code": "*/\r\nvoid print_divisors(int n) {\r\n    vector<int> temp;\r\n    for (int i = 1; i * i <= n; i++) {\r\n        if (n % i == 0) {\r\n            cout << i << \" \";\r\n            if (n / i != i)\r\n                temp.push_back(n / i);\r\n        }\r\n    }\r\n    reverse(temp.begin(), temp.end());\r\n    for (auto it : temp)\r\n        cout << it << \" \";\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (int i = 1; i * i <= n; i++)",
        "for (auto it : temp)",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\3. Advanced Maths\\02. All divisors of number.cpp",
      "verified": false,
      "needsReview": true
    },
    "sieve-of-eratosthenes": {
      "id": "sieve-of-eratosthenes",
      "title": "Sieve of Eratosthenes",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given an integer n, return the number of prime numbers that are strictly less than n.\r\n\r\nExample:\r\nInput: n = 10\r\nOutput: 4\r\nExplanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.",
      "approach": "To count the number of prime numbers less than a given number n, we can use the Sieve of Eratosthenes algorithm.\r\n1. Create a boolean vector `primes` of size n+1 and initialize all elements to true. This vector will be used to mark numbers as prime or not.\r\n2. Initialize a variable `cnt` to count the number of primes.\r\n3. Iterate from 2 to n-1:\r\n   - If primes[i] is true (i.e., i is a prime number), increment `cnt`.\r\n   - Mark all multiples of i as false in the `primes` vector, as they are not prime.\r\n4. Return `cnt`, which will be the count of prime numbers less than n.\r\n\r\nCODE:",
      "code": "*/\r\nint countPrimes(int n) {\r\n    vector<bool> primes(n + 1, true);\r\n    int cnt = 0;\r\n    for (long long i = 2; i < n; i++) {\r\n        if (primes[i]) {\r\n            cnt++;\r\n            for (long long j = i * i; j <= n; j += i) {\r\n                primes[j] = false;\r\n            }\r\n        }\r\n    }\r\n    return cnt;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<bool>",
        "for (long long i = 2; i < n; i++)",
        "for (long long j = i * i; j <= n; j += i)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\3. Advanced Maths\\03. Sieve of Eratosthenes.cpp",
      "verified": false,
      "needsReview": true
    },
    "prime-factorization-using-sieve": {
      "id": "prime-factorization-using-sieve",
      "title": "Prime factorization using Sieve",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Given a positive number N, compute its prime factorization using the concept of Sieve.\r\n\r\nExample:\r\nInput: N = 12246\r\nOutput: 2 3 13 157\r\nExplanation: The prime factorization of 12246 is 2 * 3 * 13 * 157.",
      "approach": "To compute the prime factorization of a number N, we can use the concept of Sieve.\r\n1. Create a boolean vector `prime` of size N+1 and initialize all elements to true. This vector will be used to mark numbers as prime or not.\r\n2. Create an empty vector `ans` to store the prime factors of N.\r\n3. Iterate from 2 to sqrt(N):\r\n   - If prime[i] is true (i.e., i is a prime number):\r\n     - While N is divisible by i, add i to the `ans` vector and divide N by i.\r\n     - Mark all multiples of i as false in the `prime` vector, as they are not prime.\r\n4. If N is greater than 1, it means N is a prime number itself, so add N to the `ans` vector.\r\n5. Return the `ans` vector, which will contain the prime factors of N.\r\n\r\nCODE:",
      "code": "*/\r\nvector<int> findPrimeFactors(int n) {\r\n    vector<bool> prime(n + 1, true);\r\n    vector<int> ans;\r\n\r\n    for (int i = 2; i * i <= n; i++) {\r\n        if (prime[i]) {\r\n            while (n % i == 0) {\r\n                ans.push_back(i);\r\n                n /= i;\r\n            }\r\n            for (long long j = (long long)i * i; j <= n; j += i) {\r\n                prime[j] = false;\r\n            }\r\n        }\r\n    }\r\n    if (n > 1)\r\n        ans.push_back(n);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<bool>",
        "vector<int>",
        "for (int i = 2; i * i <= n; i++)",
        "for (long long j = (long long)",
        "while (n % i == 0)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\3. Advanced Maths\\04. Prime factorization using Sieve.cpp",
      "verified": false,
      "needsReview": true
    },
    "fast-power": {
      "id": "fast-power",
      "title": "Fast Power",
      "category": "bit-manipulation",
      "difficulty": "unknown",
      "problemStatement": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).\r\n\r\nExample:\r\nInput: x = 2.00000, n = 10\r\nOutput: 1024.00000",
      "approach": "To calculate x raised to the power n, we can use the concept of binary exponentiation.\r\n1. If n is 0, return 1, as any number raised to the power 0 is 1.\r\n2. Initialize a variable res to 1 to store the result.\r\n3. If n is negative, set isNegative flag to true and make n positive.\r\n4. Iterate until n becomes 0:\r\n   - If the least significant bit of n is 1 (i.e., n is odd), multiply res by x.\r\n   - Update x to x^2 by multiplying it with itself.\r\n   - Right-shift n by 1 to remove the least significant bit.\r\n5. If isNegative is true, return 1/res; otherwise, return res.\r\n\r\nCODE:",
      "code": "*/\r\ndouble myPow(double x, int n) {\r\n    if (n == 0)\r\n        return 1;\r\n    double res = 1;\r\n    bool isNegative = (n < 0);\r\n    n = abs(n);\r\n    while (n > 0) {\r\n        if (n & 1) { // Check if n is odd\r\n            res = res * x;\r\n        }\r\n        x = x * x; // Update x to x^2\r\n        n = n >> 1; // Right-shift n by 1\r\n    }\r\n    return (isNegative) ? 1 / res : res;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [
        "while (n > 0)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\06.Bit Manipulation\\3. Advanced Maths\\05. Fast Power.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-stack-using-array": {
      "id": "implement-stack-using-array",
      "title": "Implement stack using array",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Write a program to implement a Stack using Array. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.",
      "approach": "- We use a class `MyStack` to represent the stack.\r\n- The stack is implemented using an array `arr` and a top variable to keep track of the top element.\r\n- The class provides two member functions: `push(int)` to push an element onto the stack and `pop()` to pop an element from the stack.\r\n- The `push(int)` function increments the top and adds the element to the array at the current top index.\r\n- The `pop()` function checks if the stack is empty (top = -1), in which case it returns -1. Otherwise, it retrieves the element at the top index, decrements the top, and returns the element.\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass MyStack\r\n{\r\nprivate:\r\n    int arr[1000];\r\n    int top;\r\n\r\npublic:\r\n    MyStack() { top = -1; }\r\n    int pop();\r\n    void push(int);\r\n};\r\n\r\nvoid MyStack::push(int x)\r\n{\r\n    top++;\r\n    arr[top] = x;\r\n}\r\n\r\nint MyStack::pop()\r\n{\r\n    if (top == -1) {\r\n        return -1;\r\n    }\r\n    int ans = arr[top];\r\n    top--;\r\n    return ans;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The time complexity of both `push()` and `pop()` operations is O(1) since they involve constant-time operations like incrementing/decrementing the top and accessing/modifying the array elements.\r\n- The space complexity is O(1) since the array has a fixed size and does not depend on the number of elements pushed into the stack.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\01. Implement stack using array.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-queue-using-array": {
      "id": "implement-queue-using-array",
      "title": "Implement queue using array",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Implement a Queue using an Array. Queries in the Queue are of the following type:\r\n(i) 1 x   (a query of this type means pushing 'x' into the queue)\r\n(ii) 2     (a query of this type means to pop an element from the queue and print the popped element)",
      "approach": "- We use a class `MyQueue` to represent the queue.\r\n- The queue is implemented using an array `arr`, a front variable to keep track of the front element, and a rear variable to keep track of the next available position to insert an element.\r\n- The class provides two member functions: `push(int)` to push an element into the queue and `pop()` to pop an element from the front of the queue.\r\n- The `push(int)` function inserts the element at the rear index and increments the rear.\r\n- The `pop()` function checks if the queue is empty (rear == front), in which case it returns -1. Otherwise, it retrieves the element at the front index, increments the front, and returns the element.\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass MyQueue {\r\nprivate:\r\n    int arr[100005];\r\n    int front;\r\n    int rear;\r\n\r\npublic:\r\n    MyQueue() { front = 0; rear = 0; }\r\n    void push(int);\r\n    int pop();\r\n};\r\n\r\nvoid MyQueue::push(int x)\r\n{\r\n    arr[rear] = x;\r\n    rear++;\r\n}\r\n\r\nint MyQueue::pop()\r\n{\r\n    if (rear == front)\r\n        return -1;\r\n    int ans = arr[front];\r\n    front++;\r\n    return ans;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The time complexity of both `push()` and `pop()` operations is O(1) since they involve constant-time operations like accessing/modifying array elements and incrementing/decrementing front/rear indices.\r\n- The space complexity is O(N) where N is the maximum number of elements that can be stored in the queue (in this case, 100005) since we use an array to store the queue elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\02. Implement queue using array.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-stack-using-queue": {
      "id": "implement-stack-using-queue",
      "title": "Implement stack using queue",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Implement a Stack using one queue.",
      "approach": "- We use the class `QueueStack` to represent the stack.\r\n- The stack is implemented using one queue `q`.\r\n- The `push(int)` function inserts an element into `q`.\r\n- The `pop()` function transfers `n-1` elements from front of `q` to it's back and returns the last element from `q` as the popped element.\r\n\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass QueueStack {\r\nprivate:\r\n    std::queue<int> q;\r\n\r\npublic:\r\n    void push(int x);\r\n    int pop();\r\n};\r\n\r\nvoid QueueStack::push(int x)\r\n{\r\n    q.push(x);\r\n}\r\n\r\nint QueueStack::pop()\r\n{\r\n    if (q.empty())\r\n        return -1;\r\n\r\n    for(int i=0; i<q.size()-1; i++){\r\n        int temp = q.front();\r\n        q.pop();\r\n        q.push(temp);\r\n    }\r\n\r\n    int popped = q.front();\r\n    q.pop();\r\n\r\n    return popped;\r\n}\r\n\r\n\r\n/*\r\nComplexity Analysis:\r\n- The `push()` operation has a time complexity of O(1) since we only need to enqueue an element into `q`.\r\n- The `pop()` operation has a time complexity of O(N) in the worst case, where N is the number of elements in `q`.\r\n- The space complexity is O(N), where N is the total number of elements stored in the queue.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "queue<int>",
        "for(int i=0; i<q.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\03. Implement stack using queue.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-queue-using-stacks": {
      "id": "implement-queue-using-stacks",
      "title": "Implement queue using stacks",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Implement a Queue using two stacks s1 and s2.",
      "approach": "- We use the class `Queue` to represent the queue.\r\n- The queue is implemented using two stacks `input` and `output`.\r\n- The `enqueue(int)` function inserts an element into `input` stack.\r\n- The `dequeue()` function transfers elements from `input` stack to `output` stack if `output` is empty, and returns the top element from `output` stack as the dequeued element.\r\n- To transfer elements from `input` to `output`, we pop each element from the top of `input` and push it into `output`.\r\n- After transferring elements, we pop the top element from `output` as the dequeued element.\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass Queue {\r\nprivate:\r\n    std::stack<int> input;\r\n    std::stack<int> output;\r\n\r\npublic:\r\n    void enqueue(int x);\r\n    int dequeue();\r\n};\r\n\r\nvoid Queue::enqueue(int x) {\r\n    input.push(x);\r\n}\r\n\r\nint Queue::dequeue() {\r\n    if (input.empty() && output.empty())\r\n        return -1;\r\n\r\n    if (output.empty()) {\r\n        while (!input.empty()) {\r\n            int temp = input.top();\r\n            input.pop();\r\n            output.push(temp);\r\n        }\r\n    }\r\n\r\n    int dequeued = output.top();\r\n    output.pop();\r\n\r\n    return dequeued;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The `enqueue()` operation has a time complexity of O(1) since we only need to push an element into the `input` stack.\r\n- The `dequeue()` operation has a time complexity of O(1) by amortized analysis.\r\n- The space complexity is O(N), where N is the total number of elements stored in the two stacks.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<int>",
        "stack<int>",
        "while (!input.empty()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\04. Implement queue using stacks.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-stack-using-linked-list": {
      "id": "implement-stack-using-linked-list",
      "title": "Implement stack using linked list",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You have a linked list and you have to implement the functionalities push and pop of stack using this given linked list. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.",
      "approach": "- We use the class `MyStack` to represent the stack implemented using a linked list.\r\n- The stack is implemented using a singly linked list where each node represents an element in the stack.\r\n- The `push(int)` function inserts an element at the top of the stack by creating a new node and updating the `next` pointer to point to the current top.\r\n- The `pop()` function removes the top element from the stack by updating the `top` pointer to the next node and returning the data of the removed node.\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass MyStack {\r\nprivate:\r\n    struct StackNode {\r\n        int data;\r\n        StackNode* next;\r\n\r\n        StackNode(int x) : data(x), next(NULL) {}\r\n    };\r\n\r\n    StackNode* top;\r\n\r\npublic:\r\n    MyStack() : top(NULL) {}\r\n    void push(int x);\r\n    int pop();\r\n};\r\n\r\nvoid MyStack::push(int x) {\r\n    StackNode* temp = new StackNode(x);\r\n    temp->next = top;\r\n    top = temp;\r\n}\r\n\r\nint MyStack::pop() {\r\n    if (!top)\r\n        return -1;\r\n\r\n    int popped = top->data;\r\n    StackNode* temp = top;\r\n    top = top->next;\r\n\r\n    return popped;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The `push()` operation has a time complexity of O(1) since we only need to create a new node and update the `top` pointer.\r\n- The `pop()` operation has a time complexity of O(1) since we only need to update the `top` pointer and delete the node.\r\n- The space complexity is O(N), where N is the total number of elements stored in the stack (linked list).\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\05. Implement stack using linked list.cpp",
      "verified": false,
      "needsReview": true
    },
    "valid-parenthesis": {
      "id": "valid-parenthesis",
      "title": "Valid Parenthesis",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\r\n\r\nAn input string is valid if:\r\n- Open brackets must be closed by the same type of brackets.\r\n- Open brackets must be closed in the correct order.\r\n- Every close bracket has a corresponding open bracket of the same type.\r\n\r\nExample:\r\nInput: s = \"()\"\r\nOutput: true",
      "approach": "- We can use a stack to keep track of the opening brackets.\r\n- Whenever we encounter an opening bracket, we push it onto the stack.\r\n- If we encounter a closing bracket, we check if it matches the top of the stack.\r\n- If the closing bracket matches the top of the stack, we pop the top element from the stack.\r\n- If at any point the closing bracket does not match the top of the stack or the stack is empty, the string is not valid.\r\n- Finally, if the stack is empty after processing all characters, the string is valid.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isValid(string& s) {\r\n    stack<char> st;\r\n    \r\n    for (char c : s) {\r\n        if (c == '(' || c == '[' || c == '{') {\r\n            st.push(c);\r\n        } \r\n        else {\r\n            if (st.empty())\r\n                return false;\r\n            \r\n            char open = st.top();\r\n            if ((open == '(' && c == ')') || (open == '[' && c == ']') || (open == '{' && c == '}')) {\r\n                st.pop();\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return st.empty();\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The code iterates through the input string once, so the time complexity is O(n), where n is the length of the input string.\r\n- The space complexity is O(n) as we use a stack to store the opening brackets.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<char>",
        "for (char c : s)",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\06. Valid Parenthesis.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-min-stack": {
      "id": "implement-min-stack",
      "title": "Implement min stack",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\nImplement the MinStack class.\r\nMinStack() initializes the stack object.\r\nvoid push(int val) pushes the element val onto the stack.\r\nvoid pop() removes the element on the top of the stack.\r\nint top() gets the top element of the stack.\r\nint getMin() retrieves the minimum element in the stack.\r\nYou must implement a solution with O(1) time complexity for each function.\r\n\r\nExample:\r\nInput:\r\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\r\n[[],[-2],[0],[-3],[],[],[],[]]\r\nOutput:\r\n[null,null,null,null,-3,null,0,-2]\r\nExplanation:\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin(); // return -3\r\nminStack.pop();\r\nminStack.top();    // return 0\r\nminStack.getMin(); // return -2",
      "approach": "- We can use an auxiliary stack to keep track of the difference of an element from the minimum element at each step.\r\n- When pushing an element, we push the difference of an element from the minimum element at that time.\r\n- When popping an element, we check stack top if it's -ve it means that this element is the minimum so we update the mini as we popping the current minimum.\r\n- To get the top element, we add the current minimum to the top element of the main stack.\r\n- To get the minimum element, we simply return the current minimum.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass MinStack {\r\nprivate:\r\n    stack<long long> st;\r\n    int mini;\r\npublic:\r\n    MinStack() {\r\n        mini = -1;\r\n    }\r\n    \r\n    void push(int val) {\r\n        if (st.empty()) {\r\n            st.push(0);\r\n            mini = val;\r\n        } else {\r\n            st.push((long long)val - mini);// to handle overflow case\r\n            mini = min(val, mini);\r\n        }\r\n    }\r\n    \r\n    void pop() {\r\n        if (st.top() < 0)\r\n            mini = mini - st.top();\r\n        st.pop();\r\n    }\r\n    \r\n    int top() {\r\n        int ans = -1;\r\n        if (st.top() < 0)\r\n            ans = mini;\r\n        else\r\n            ans = mini + st.top();\r\n        return ans;\r\n    }\r\n    \r\n    int getMin() {\r\n        return mini;\r\n    }\r\n};\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- All the operations (push, pop, top, getMin) have O(1) time complexity as we are performing constant-time operations on the stack.\r\n- The space complexity is O(n) as we use an auxiliary stack to store the minimum elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<long long>",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\1. Learning\\07. Implement min stack.cpp",
      "verified": false,
      "needsReview": true
    },
    "infix-to-postfix": {
      "id": "infix-to-postfix",
      "title": "Infix to postfix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an infix expression in the form of string str, convert it to a postfix expression.\r\n\r\nInfix expression: The expression of the form a op b. When an operator is in-between every pair of operands.\r\nPostfix expression: The expression of the form a b op. When an operator is followed for every pair of operands.\r\nNote: The order of precedence is: ^ greater than * equals to / greater than + equals to -.\r\n\r\nExample:\r\nInput: str = \"a+b*(c^d-e)^(f+g*h)-i\"\r\nOutput: abcd^e-fgh*+^*+i-\r\nExplanation:\r\nAfter converting the infix expression into postfix expression, the resultant expression will be abcd^e-fgh*+^*+i-",
      "approach": "- We can use a stack to convert the infix expression to postfix.\r\n- We iterate through each character of the input string.\r\n- If the character is an operand (letter or digit), we append it to the output string.\r\n- If the character is an opening parenthesis '(', we push it onto the stack.\r\n- If the character is a closing parenthesis ')', we pop elements from the stack and append them to the output string until we encounter an opening parenthesis. We also discard the opening parenthesis from the stack.\r\n- If the character is an operator, we compare its precedence with the top element of the stack. If the top element has higher precedence, we pop it and append it to the output string. We repeat this process until we find an operator with lower precedence or an opening parenthesis. Then we push the current operator onto the stack.\r\n- After iterating through all characters, we pop any remaining elements from the stack and append them to the output string.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nstring infixToPostfix(string s) {\r\n    string ans = \"\";\r\n    unordered_map<char, int> precedence;\r\n    precedence['^'] = 3;\r\n    precedence['*'] = 2;\r\n    precedence['/'] = 2;\r\n    precedence['+'] = 1;\r\n    precedence['-'] = 1;\r\n    \r\n    stack<char> st;\r\n    \r\n    for (int i = 0; i < s.size(); i++) {\r\n        if (('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z') || ('0' <= s[i] && s[i] <= '9')) {\r\n            ans.push_back(s[i]);\r\n        } else if (s[i] == '(') {\r\n            st.push(s[i]);\r\n        } else if (s[i] == ')') {\r\n            while (!st.empty() && st.top() != '(') {\r\n                ans.push_back(st.top());\r\n                st.pop();\r\n            }\r\n            st.pop();\r\n        } else {\r\n            while (!st.empty() && st.top() != '(' && precedence[st.top()] >= precedence[s[i]]) {\r\n                ans.push_back(st.top());\r\n                st.pop();\r\n            }\r\n            st.push(s[i]);\r\n        }\r\n    }\r\n    \r\n    while (!st.empty()) {\r\n        ans.push_back(st.top());\r\n        st.pop();\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the infixToPostfix function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operators.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<char, int>",
        "stack<char>",
        "for (int i = 0; i < s.size()",
        "while (!st.empty()",
        "while (!st.empty()",
        "while (!st.empty()",
        ".push_back(",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\01. Infix to postfix.cpp",
      "verified": false,
      "needsReview": true
    },
    "infix-to-prefix": {
      "id": "infix-to-prefix",
      "title": "Infix to prefix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an infix expression in the form of string str. Convert this infix expression to postfix expression.\r\n\r\nInfix expression: The expression of the form a op b. When an operator is in-between every pair of operands.\r\nPostfix expression: The expression of the form a b op. When an operator is followed for every pair of operands.\r\nNote: The order of precedence is: ^ greater than * equals to / greater than + equals to -.\r\n\r\nExample:\r\nInput: str = \"((A-(B/C))*((A/K)-L))\"\r\nOutput: \"*-A/BC-/AKL\"\r\nExplanation:\r\nAfter converting the infix expression into prefix expression, the resultant expression will be *-A/BC-/AKL.",
      "approach": "- We can use a stack to convert the infix expression to postfix.\r\n- We iterate through each character of the input string from right to left.\r\n- If the character is an alphanumeric character, we append it to the output string.\r\n- If the character is an closing parenthesis '(', we push it onto the stack.\r\n- If the character is a opening parenthesis ')', we pop operators from the stack and append them to the output string until we encounter an closing parenthesis '('.\r\n- If the character is an operator, we compare its precedence with the top of the stack and pop operators with higher or equal precedence and append them to the output string. Then we push the current operator onto the stack.\r\n- After iterating through all characters, we pop any remaining operators from the stack and append them to the output string.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nstring infixToPostfix(string s) {\r\n    string ans = \"\";\r\n    unordered_map<char, int> precedence;\r\n    precedence['^'] = 3;\r\n    precedence['*'] = 2;\r\n    precedence['/'] = 2;\r\n    precedence['+'] = 1;\r\n    precedence['-'] = 1;\r\n\r\n    stack<char> st;\r\n\r\n    for (int i = s.size() - 1; i >= 0; i--) {\r\n        if (('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z') || ('0' <= s[i] && s[i] <= '9')) {\r\n            ans.push_back(s[i]);\r\n        } else if (s[i] == ')') {\r\n            st.push(s[i]);\r\n        } else if (s[i] == '(') {\r\n            while (!st.empty() && st.top() != ')') {\r\n                ans.push_back(st.top());\r\n                st.pop();\r\n            }\r\n            st.pop(); // Pop the closing parenthesis ')'\r\n        } else {\r\n            while (!st.empty() && st.top() != ')' && precedence[st.top()] >= precedence[s[i]]) {\r\n                ans.push_back(st.top());\r\n                st.pop();\r\n            }\r\n            st.push(s[i]);\r\n        }\r\n    }\r\n\r\n    while (!st.empty()) {\r\n        ans.push_back(st.top());\r\n        st.pop();\r\n    }\r\n\r\n    reverse(ans.begin(), ans.end());\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the infixToPostfix function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operators.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<char, int>",
        "stack<char>",
        "for (int i = s.size()",
        "while (!st.empty()",
        "while (!st.empty()",
        "while (!st.empty()",
        ".push_back(",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\02. Infix to prefix.cpp",
      "verified": false,
      "needsReview": true
    },
    "prefix-to-infix": {
      "id": "prefix-to-infix",
      "title": "Prefix to infix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You are given a string S of size N that represents the prefix form of a valid mathematical expression. Convert it to its infix form.\r\n\r\nExample:\r\nInput: \r\n*-A/BC-/AKL\r\nOutput: \r\n((A-(B/C))*((A/K)-L))\r\nExplanation: \r\nThe above output is its valid infix form.",
      "approach": "- We can use a stack to convert the prefix expression to infix.\r\n- We iterate through each character of the input string in reverse order.\r\n- If the character is an operand (letter or digit), we push it onto the stack.\r\n- If the character is an operator, we pop two operands from the stack, concatenate them with the operator and enclosing parentheses, and push the result back onto the stack.\r\n- After iterating through all characters, the top of the stack will contain the final infix expression.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nstring preToInfix(string pre_exp) {\r\n    stack<string> st;\r\n    \r\n    for (int i = pre_exp.size() - 1; i >= 0; i--) {\r\n        char ch = pre_exp[i];\r\n        \r\n        if (('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') || ('0' <= ch && ch <= '9')) {\r\n            string temp = \"\";\r\n            temp += ch;\r\n            st.push(temp);\r\n        } else {\r\n            string a = st.top();\r\n            st.pop();\r\n            string b = st.top();\r\n            st.pop();\r\n            \r\n            string temp = \"(\" + a + ch + b + \")\";\r\n            st.push(temp);\r\n        }\r\n    }\r\n    \r\n    return st.top();\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the preToInfix function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operands.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<string>",
        "for (int i = pre_exp.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\03. Prefix to infix.cpp",
      "verified": false,
      "needsReview": true
    },
    "prefix-to-postfix": {
      "id": "prefix-to-postfix",
      "title": "Prefix to postfix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You are given a string that represents the prefix form of a valid mathematical expression. Convert it to its postfix form.\r\n\r\nExample:\r\nInput: \r\n*-A/BC-/AKL\r\nOutput: \r\nABC/-AK/L-*\r\nExplanation: \r\nThe above output is its valid postfix form.",
      "approach": "- We can use a stack to convert the prefix expression to postfix.\r\n- We iterate through each character of the input string in reverse order.\r\n- If the character is an alphanumeric character, we push it onto the stack.\r\n- If the character is an operator, we pop two operands from the stack, concatenate them with the operator, and push the result back onto the stack.\r\n- After iterating through all characters, the top of the stack will contain the final postfix expression.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isAlphaNumeric(char ch) {\r\n    return ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') || ('0' <= ch && ch <= '9');\r\n}\r\n\r\nstring preToPost(string pre_exp) {\r\n    stack<string> st;\r\n    \r\n    for (int i = pre_exp.size() - 1; i >= 0; i--) {\r\n        char ch = pre_exp[i];\r\n        \r\n        if (isAlphaNumeric(ch)) {\r\n            string temp = \"\";\r\n            temp += ch;\r\n            st.push(temp);\r\n        } else {\r\n            string a = st.top();\r\n            st.pop();\r\n            string b = st.top();\r\n            st.pop();\r\n            \r\n            string temp = a + b + ch;\r\n            st.push(temp);\r\n        }\r\n    }\r\n    \r\n    return st.top();\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the preToPost function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operands.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<string>",
        "for (int i = pre_exp.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\04. Prefix to postfix.cpp",
      "verified": false,
      "needsReview": true
    },
    "postfix-to-infix": {
      "id": "postfix-to-infix",
      "title": "Postfix to infix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You are given a string that represents the postfix form of a valid mathematical expression. Convert it to its infix form.\r\n\r\nExample:\r\nInput:\r\nab*c+ \r\nOutput: \r\n((a*b)+c)\r\nExplanation: \r\nThe above output is its valid infix form.",
      "approach": "- We can use a stack to convert the postfix expression to infix.\r\n- We iterate through each character of the input string.\r\n- If the character is an alphanumeric character, we push it onto the stack.\r\n- If the character is an operator, we pop two operands from the stack, concatenate them with the operator in the proper order (operand1 + operator + operand2), and push the result back onto the stack.\r\n- After iterating through all characters, the top of the stack will contain the final infix expression.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isAlphaNumeric(char ch) {\r\n    return ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') || ('0' <= ch && ch <= '9');\r\n}\r\n\r\nstring postToInfix(string exp) {\r\n    stack<string> st;\r\n    \r\n    for (int i = 0; i < exp.size(); i++) {\r\n        char ch = exp[i];\r\n        \r\n        if (isAlphaNumeric(ch)) {\r\n            string temp = \"\";\r\n            temp += ch;\r\n            st.push(temp);\r\n        } else {\r\n            string a = st.top();\r\n            st.pop();\r\n            string b = st.top();\r\n            st.pop();\r\n            \r\n            st.push(\"(\" + b + ch + a + \")\");\r\n        }\r\n    }\r\n    \r\n    return st.top();\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the postToInfix function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operands.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<string>",
        "for (int i = 0; i < exp.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\05. Postfix to infix.cpp",
      "verified": false,
      "needsReview": true
    },
    "postfix-to-prefix": {
      "id": "postfix-to-prefix",
      "title": "Postfix to prefix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You are given a string that represents the postfix form of a valid mathematical expression. Convert it to its prefix form.\r\n\r\nExample:\r\nInput: \r\nABC/-AK/L-*\r\nOutput: \r\n*-A/BC-/AKL\r\nExplanation: \r\nThe above output is its valid prefix form.",
      "approach": "- We can use a stack to convert the postfix expression to prefix.\r\n- We iterate through each character of the input string.\r\n- If the character is an alphanumeric character, we push it onto the stack.\r\n- If the character is an operator, we pop two operands from the stack, concatenate them with the operator in the proper order (operator + operand2 + operand1), and push the result back onto the stack.\r\n- After iterating through all characters, the top of the stack will contain the final prefix expression.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isAlphaNumeric(char ch) {\r\n    return ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') || ('0' <= ch && ch <= '9');\r\n}\r\n\r\nstring postToPre(string post_exp) {\r\n    stack<string> st;\r\n    \r\n    for (int i = 0; i < post_exp.size(); i++) {\r\n        char ch = post_exp[i];\r\n        \r\n        if (isAlphaNumeric(ch)) {\r\n            string temp = \"\";\r\n            temp += ch;\r\n            st.push(temp);\r\n        } else {\r\n            string a = st.top();\r\n            st.pop();\r\n            string b = st.top();\r\n            st.pop();\r\n            \r\n            string temp = ch + b + a;\r\n            st.push(temp);\r\n        }\r\n    }\r\n    \r\n    return st.top();\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the postToPre function is O(N), where N is the length of the input string.\r\n- We iterate through each character once, and the operations performed inside the loop are all constant time.\r\n- The space complexity is O(N) as we use a stack to store operands.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<string>",
        "for (int i = 0; i < post_exp.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\2. Infix, Postfix, and Prefix\\06. Postfix to prefix.cpp",
      "verified": false,
      "needsReview": true
    },
    "next-greater-element": {
      "id": "next-greater-element",
      "title": "Next Greater Element",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\r\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\r\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\r\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\r\n\r\nExample:\r\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\r\nOutput: [-1,3,-1]\r\nExplanation: The next greater element for each value of nums1 is as follows:\r\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\r\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\r\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
      "approach": "- We can solve this problem using a stack and a hashmap.\r\n- First, we iterate through the `nums2` array from right to left.\r\n- For each element, we pop elements from the stack that are smaller than or equal to the current element and store the next greater element for each popped element in the hashmap.\r\n- Finally, we iterate through the `nums1` array and retrieve the next greater element from the hashmap if it exists, otherwise assign -1.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid nextGstack(vector<int>& nums, unordered_map<int, int>& mp) {\r\n    stack<int> st;\r\n    for (int i = nums.size() - 1; i >= 0; i--) {\r\n        while (!st.empty() && st.top() <= nums[i]) {\r\n            st.pop();\r\n        }\r\n        if (!st.empty())\r\n            mp[nums[i]] = st.top();\r\n\r\n        st.push(nums[i]);\r\n    }\r\n}\r\n\r\nvector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\r\n    unordered_map<int, int> mp;\r\n    nextGstack(nums2, mp);\r\n\r\n    vector<int> ans(nums1.size(), -1);\r\n\r\n    for (int i = 0; i < nums1.size(); i++) {\r\n        if (mp.find(nums1[i]) != mp.end())\r\n            ans[i] = mp[nums1[i]];\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nComplexity Analysis:\r\n- The time complexity of the `nextGreaterElement` function is O(N + M), where N is the size of `nums1` and M is the size of `nums2`.\r\n- The `nextGstack` function has a time complexity of O(M), where M is the size of `nums2`.\r\n- The space complexity is O(N), where N is the size of `nums1`, to store the result in the `ans` vector and the `mp` hashmap.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "monotonic-stack",
        "trie"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "unordered_map<int, int>",
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "for (int i = nums.size()",
        "for (int i = 0; i < nums1.size()",
        "while (!st.empty()",
        ".find(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\01. Next Greater Element.cpp",
      "verified": false,
      "needsReview": true
    },
    "next-greater-element-2": {
      "id": "next-greater-element-2",
      "title": "Next Greater Element 2",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given a circular integer array `nums` (i.e., the next element of `nums[nums.length - 1]` is `nums[0]`), return the next greater number for every element in `nums`.\r\n\r\nThe next greater number of a number `x` is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\r\n\r\nExample:\r\n\r\nInput: `nums = [1,2,1]`\r\nOutput: `[2,-1,2]`\r\nExplanation: The first 1's next greater number is 2. The number 2 doesn't have a next greater number. The second 1's next greater number needs to be searched circularly, which is also 2.",
      "approach": "To find the next greater number for each element in a circular array, we can utilize a stack. \r\nWe iterate through the array in reverse order to handle the circular nature of the array. \r\nFor each element, we compare it with the elements in the stack. \r\nIf an element in the stack is smaller than or equal to the current element, we pop it from the stack since it cannot be the next greater number.\r\nThe top of the stack at each iteration will hold the next greater element for the corresponding element in the array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// NOTE:- we could also implement this via two for loops from n-1 to 0, instead of a single loop of 2*n to 0; cause the complexity remains the same\r\n\r\nvector<int> nextGreaterElements(vector<int>& nums) {\r\n    vector<int> ans(nums.size(), -1);\r\n    stack<int> st;\r\n\r\n    for (int i = 2 * nums.size() - 1; i >= 0; i--) {\r\n        while (!st.empty() && nums[st.top()] <= nums[i % nums.size()])\r\n            st.pop();\r\n        \r\n        if (!st.empty())\r\n            ans[i % nums.size()] = nums[st.top()];\r\n        \r\n        st.push(i % nums.size());\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(N), where N is the size of the input array `nums`. We iterate through the array twice: once to find the next greater element in the first pass and once to handle the circular nature of the array in the second pass.\r\n- The space complexity is O(N) as we use a stack to store the indices of elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "monotonic-stack"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "for (int i = 2 * nums.size()",
        "while (!st.empty()",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\02. Next Greater Element 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "previous-smaller-element": {
      "id": "previous-smaller-element",
      "title": "Previous Smaller Element",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an array `a` of integers of length `n`, find the nearest smaller number for every element such that the smaller element is on the left side. If no smaller element is present on the left, print -1.\r\n\r\nExample:\r\n\r\nInput: n = 3\r\na = {1, 6, 2}\r\nOutput: -1 1 1\r\nExplanation: There is no number at the left of 1. The smaller number than 6 and 2 is 1.",
      "approach": "To find the nearest smaller number on the left for each element, we can utilize a stack. \r\nWe iterate through the array from left to right. For each element, we compare it with the elements in the stack. \r\nIf an element in the stack is greater than or equal to the current element, we pop it from the stack since it cannot be the nearest smaller number on the left. \r\nThe top of the stack at each iteration will hold the nearest smaller number on the left for the corresponding element in the array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> leftSmaller(int n, int arr[]) {\r\n    stack<int> st;\r\n    vector<int> ans(n, -1);\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        while (!st.empty() && st.top() >= arr[i])\r\n            st.pop();\r\n\r\n        if (!st.empty())\r\n            ans[i] = st.top();\r\n\r\n        st.push(arr[i]);\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(N), where N is the length of the input array `a`. We iterate through the array once.\r\n- The space complexity is O(N) as we use a stack to store the elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "for (int i = 0; i < n; i++)",
        "while (!st.empty()",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\03. Previous Smaller Element.cpp",
      "verified": false,
      "needsReview": true
    },
    "trapping-rainwater": {
      "id": "trapping-rainwater",
      "title": "Trapping Rainwater",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "approach": "To calculate the trapped water, we can use the two-pointer approach. We initialize two pointers, one at the beginning of the array (`left`) and another at the end of the array (`right`). We also maintain two variables, `leftMax` and `rightMax`, to keep track of the maximum bar height encountered from the left and right side, respectively.\r\n\r\n1. Initialize `left` to 0 and `right` to the last index of the array.\r\n2. Initialize `leftMax` and `rightMax` to the minimum integer value (`INT_MIN`).\r\n3. Initialize `ans` (trapped water) to 0.\r\n4. Iterate while `left` is less than or equal to `right`:\r\n    a. If `height[left]` is less than `height[right]`:\r\n        - Update `leftMax` if `height[left]` is greater than the current `leftMax`.\r\n        - Calculate the amount of water trapped at the current `left` index by subtracting `height[left]` from `leftMax` and add it to `ans`.\r\n        - Increment `left` by 1.\r\n    b. Else:\r\n        - Update `rightMax` if `height[right]` is greater than the current `rightMax`.\r\n        - Calculate the amount of water trapped at the current `right` index by subtracting `height[right]` from `rightMax` and add it to `ans`.\r\n        - Decrement `right` by 1.\r\n5. Return the final value of `ans`.\r\n\r\nCODE:",
      "code": "*/\r\nint trap(vector<int>& height) {\r\n    int leftMax = INT_MIN;\r\n    int rightMax = INT_MIN;\r\n    int left = 0, right = height.size()-1;\r\n    int ans = 0;\r\n\r\n    while(left <= right) {\r\n        if(height[left] < height[right]) {\r\n            if(height[left] > leftMax)\r\n                leftMax = height[left];\r\n            else\r\n                ans += leftMax - height[left];\r\n            left++;\r\n        } else {\r\n            if(height[right] > rightMax)\r\n                rightMax = height[right];\r\n            else\r\n                ans += rightMax - height[right];\r\n            right--;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(N), where N is the number of elements in the `height` array. We iterate through the array once.\r\n- The space complexity is O(1) as we only use a constant amount of extra space to store variables.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "while(left <= right)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\04. Trapping Rainwater.cpp",
      "verified": false,
      "needsReview": true
    },
    "sum-of-subarray-minimum": {
      "id": "sum-of-subarray-minimum",
      "title": "Sum of subarray minimum",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
      "approach": "To find the sum of the minimums of all subarrays, we can use the concept of previous smaller and next smaller elements for each element in the array.\r\n1. Define two helper functions:\r\n   - `prevSmaller(arr)`: Returns an array that contains the index of the previous smaller element for each element in `arr`. If no smaller element exists, the index is set to -1.\r\n   - `nextSmaller(arr)`: Returns an array that contains the index of the next smaller element for each element in `arr`. If no smaller element exists, the index is set to the length of the array.\r\n2. Initialize a variable `ans` to 0 to store the final sum.\r\n3. Iterate over each element `arr[i]` in the array:\r\n   a. Calculate the number of subarrays in which `arr[i]` is the minimum element.\r\n      - The number of subarrays with `arr[i]` as the minimum element on the left side is `i - prevS[i]`.\r\n      - The number of subarrays with `arr[i]` as the minimum element on the right side is `nextS[i] - i`.\r\n   b. Add `(leftElements * rightElements * arr[i]) % mod` to `ans`, where `mod` is `1e9 + 7`.\r\n4. Return the final value of `ans` as the sum of minimums of all subarrays modulo `1e9 + 7`.\r\n\r\nCODE:",
      "code": "*/\r\nvector<int> prevSmaller(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), -1);\r\n    for(int i = 0; i < arr.size(); i++){\r\n        while(!st.empty() && arr[st.top()] > arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> nextSmaller(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), arr.size());\r\n    for(int i = arr.size()-1; i >= 0; i--){\r\n        while(!st.empty() && arr[st.top()] >= arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nint sumSubarrayMins(vector<int>& arr) {\r\n    vector<int> prevS = prevSmaller(arr);\r\n    vector<int> nextS = nextSmaller(arr);\r\n    long long ans = 0;\r\n    int mod = 1e9 + 7;\r\n\r\n    for(int i = 0; i < arr.size(); i++){\r\n        long long leftElements = i - prevS[i];\r\n        long long rightElements = nextS[i] - i;\r\n        // this formula is arrived by mathematical calculation\r\n        ans += ((leftElements % mod) * (rightElements % mod) * (arr[i] % mod)) % mod;\r\n    }\r\n\r\n    return (int)ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(N), where N is the number of elements in the array `arr`. We iterate through the array twice to calculate the previous smaller and next smaller elements.\r\n- The space complexity is O(N) as we use additional space to store the previous smaller and next smaller elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "monotonic-stack"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "stack<int>",
        "for(int i = 0; i < arr.size()",
        "for(int i = arr.size()",
        "for(int i = 0; i < arr.size()",
        "while(!st.empty()",
        "while(!st.empty()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\05. Sum of subarray minimum.cpp",
      "verified": false,
      "needsReview": true
    },
    "sum-of-range-of-all-subarray": {
      "id": "sum-of-range-of-all-subarray",
      "title": "Sum of range of all subarray",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray. Return the sum of all subarray ranges of nums.",
      "approach": "To find the sum of all subarray ranges, we can use the concept of previous smaller, next smaller, previous greater, and next greater elements for each element in the array.\r\n1. Define four helper functions:\r\n   - `prevSmaller(arr)`: Returns an array that contains the index of the previous smaller element for each element in `arr`. If no smaller element exists, the index is set to -1.\r\n   - `nextSmaller(arr)`: Returns an array that contains the index of the next smaller element for each element in `arr`. If no smaller element exists, the index is set to the length of the array.\r\n   - `prevGreater(arr)`: Returns an array that contains the index of the previous greater element for each element in `arr`. If no greater element exists, the index is set to -1.\r\n   - `nextGreater(arr)`: Returns an array that contains the index of the next greater element for each element in `arr`. If no greater element exists, the index is set to the length of the array.\r\n2. Initialize a variable `ans` to 0 to store the final sum.\r\n3. Iterate over each element `arr[i]` in the array:\r\n   a. Calculate the number of subarrays where `arr[i]` is the minimum element:\r\n      - The number of subarrays with `arr[i]` as the minimum element on the left side is `i - prevS[i]`.\r\n      - The number of subarrays with `arr[i]` as the minimum element on the right side is `nextS[i] - i`.\r\n   b. Calculate the number of subarrays where `arr[i]` is the maximum element:\r\n      - The number of subarrays with `arr[i]` as the maximum element on the left side is `i - prevG[i]`.\r\n      - The number of subarrays with `arr[i]` as the maximum element on the right side is `nextG[i] - i`.\r\n   c. Update `ans` by adding `(maxleftElements * maxrightElements * arr[i]) - (minleftElements * minrightElements * arr[i])`.\r\n4. Return the final value of `ans` as the sum of all subarray ranges.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// NOTE:- The code could be more concise if done in double traversal but I find this more intuitive\r\nvector<int> prevSmaller(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), -1);\r\n    for(int i = 0; i < arr.size(); i++){\r\n        while(!st.empty() && arr[st.top()] > arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> nextSmaller(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), arr.size());\r\n    for(int i = arr.size()-1; i >= 0; i--){\r\n        while(!st.empty() && arr[st.top()] >= arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> prevGreater(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), -1);\r\n    for(int i = 0; i < arr.size(); i++){\r\n        while(!st.empty() && arr[st.top()] < arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> nextGreater(vector<int>& arr){\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), arr.size());\r\n    for(int i = arr.size()-1; i >= 0; i--){\r\n        while(!st.empty() && arr[st.top()] <= arr[i])\r\n            st.pop();\r\n        if(!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nlong long subArrayRanges(vector<int>& arr) {\r\n    vector<int> prevS = prevSmaller(arr);\r\n    vector<int> nextS = nextSmaller(arr);\r\n    vector<int> prevG = prevGreater(arr);\r\n    vector<int> nextG = nextGreater(arr);\r\n    long long ans = 0;\r\n\r\n    for(int i = 0; i < arr.size(); i++){\r\n        long long minleftElements = i - prevS[i];\r\n        long long minrightElements = nextS[i] - i;\r\n        long long maxleftElements = i - prevG[i];\r\n        long long maxrightElements = nextG[i] - i;\r\n        ans += (maxleftElements * maxrightElements * arr[i]) - (minleftElements * minrightElements * arr[i]);\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(N), where N is the number of elements in the array `arr`. We iterate through the array multiple times to calculate the previous smaller, next smaller, previous greater, and next greater elements.\r\n- The space complexity is O(N) as we use additional space to store the previous smaller, next smaller, previous greater, and next greater elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "monotonic-stack"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "stack<int>",
        "stack<int>",
        "for(int i = 0; i < arr.size()",
        "for(int i = arr.size()",
        "for(int i = 0; i < arr.size()",
        "while(!st.empty()",
        "while(!st.empty()",
        "while(!st.empty()",
        ".push(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\06. Sum of range of all subarray.cpp",
      "verified": false,
      "needsReview": true
    },
    "remove-k-elements": {
      "id": "remove-k-elements",
      "title": "Remove K elements",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given string num representing a non-negative integer num, and an integer k,\r\nreturn the smallest possible integer after removing k digits from num.\r\n\r\nExample:\r\nInput: num = \"1432219\", k = 3\r\nOutput: \"1219\"\r\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
      "approach": "The idea is to use a stack to build the smallest number by removing larger digits.\r\nWe iterate through each digit in num and compare it with the digits in the stack.\r\nIf the current digit is smaller than the top of the stack, we pop elements from the stack\r\nuntil either the stack is empty or the top of the stack is smaller than or equal to the current digit.\r\nAfter processing all the digits, we remove any remaining digits from the stack to satisfy the required k digits to remove.\r\nFinally, we construct the result by popping elements from the stack and reverse it to get the correct order.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\07. Remove K elements.cpp",
      "verified": false,
      "needsReview": true
    },
    "largest-rectangle-in-histogram": {
      "id": "largest-rectangle-in-histogram",
      "title": "Largest Rectangle in Histogram",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1,\r\nreturn the area of the largest rectangle in the histogram.\r\n\r\nExample:\r\nInput: heights = [2,1,5,6,2,3]\r\nOutput: 10\r\nExplanation: The above is a histogram where the width of each bar is 1.\r\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
      "approach": "To find the largest rectangle area, we can use the concept of a stack.\r\nThe idea is to maintain a stack of indices of the heights in non-decreasing order.\r\nFor each height, we compare it with the top of the stack.\r\nIf the current height is greater than the top of the stack, we push its index onto the stack.\r\nOtherwise, we keep popping elements from the stack and calculate the area using the popped index as the right boundary.\r\nThe left boundary can be obtained from the new top of the stack.\r\nBy doing this, we ensure that the heights in the stack are always in non-decreasing order.\r\nFinally, we calculate the area for each popped element and update the maximum area found so far.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nvector<int> prevSmaller(vector<int>& arr) {\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), -1);\r\n    for (int i = 0; i < arr.size(); i++) {\r\n        while (!st.empty() && arr[st.top()] > arr[i])\r\n            st.pop();\r\n        if (!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvector<int> nextSmaller(vector<int>& arr) {\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), arr.size());\r\n    for (int i = arr.size() - 1; i >= 0; i--) {\r\n        while (!st.empty() && arr[st.top()] >= arr[i])\r\n            st.pop();\r\n        if (!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\nint largestRectangleArea(vector<int>& heights) {\r\n    vector<int> prev = prevSmaller(heights);\r\n    vector<int> next = nextSmaller(heights);\r\n\r\n    int ans = INT_MIN;\r\n    for (int i = 0; i < heights.size(); i++) {\r\n        ans = max(ans, (next[i] - prev[i] - 1) * heights[i]);\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n), where n is the number of elements in the heights array.\r\n  This is because we iterate through the array once to calculate the previous and next smaller elements.\r\n- The space complexity is O(n) as well since we use two additional arrays to store the previous and next smaller elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "monotonic-stack"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "stack<int>",
        "for (int i = 0; i < arr.size()",
        "for (int i = arr.size()",
        "for (int i = 0; i < heights.size()",
        "while (!st.empty()",
        "while (!st.empty()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\08. Largest Rectangle in Histogram.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximal-rectangle-in-binary-matrix": {
      "id": "maximal-rectangle-in-binary-matrix",
      "title": "Maximal Rectangle in binary matrix",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given a binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
      "approach": "To solve this problem, we can use a variation of the Largest Rectangle in Histogram problem.\r\n1. First, we will calculate the heights of the histogram for each row in the matrix.\r\n   - If the current element is '1', we increment the height of the histogram at that column by 1.\r\n   - If the current element is '0', we reset the height of the histogram at that column to 0.\r\n2. For each row, we calculate the largest rectangle area using the heights calculated in step 1.\r\n   - We use the largestRectangleArea function, which calculates the largest rectangle area in a histogram.\r\n   - The histogram heights are the heights of the current row up to that column.\r\n3. Finally, we return the maximum area obtained from step 2.\r\n\r\nExample:\r\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\r\nOutput: 6\r\nExplanation: The maximal rectangle is shown in the above picture.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Helper function to calculate the previous smaller element index for each element in an array\r\nvector<int> prevSmaller(vector<int>& arr) {\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), -1);\r\n    for (int i = 0; i < arr.size(); i++) {\r\n        while (!st.empty() && arr[st.top()] > arr[i])\r\n            st.pop();\r\n        if (!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\n// Helper function to calculate the next smaller element index for each element in an array\r\nvector<int> nextSmaller(vector<int>& arr) {\r\n    stack<int> st;\r\n    vector<int> ans(arr.size(), arr.size());\r\n    for (int i = arr.size() - 1; i >= 0; i--) {\r\n        while (!st.empty() && arr[st.top()] >= arr[i])\r\n            st.pop();\r\n        if (!st.empty())\r\n            ans[i] = st.top();\r\n        st.push(i);\r\n    }\r\n    return ans;\r\n}\r\n\r\n// Function to calculate the largest rectangle area in a histogram represented by heights\r\nint largestRectangleArea(vector<int>& heights) {\r\n    vector<int> prev = prevSmaller(heights);\r\n    vector<int> next = nextSmaller(heights);\r\n\r\n    int ans = INT_MIN;\r\n    for (int i = 0; i < heights.size(); i++) {\r\n        ans = max(ans, (next[i] - prev[i] - 1) * heights[i]);\r\n    }\r\n    return ans;\r\n}\r\n\r\n// Function to find the largest rectangle area in a binary matrix\r\nint maximalRectangle(vector<vector<char>>& matrix) {\r\n    if (matrix.empty() || matrix[0].empty())\r\n        return 0;\r\n\r\n    int rows = matrix.size();\r\n    int cols = matrix[0].size();\r\n    vector<int> prev(cols, 0);\r\n    int maxArea = 0;\r\n\r\n    for (int i = 0; i < rows; i++) {\r\n        vector<int> curr(cols, 0);\r\n        for (int j = 0; j < cols; j++) {\r\n            if (matrix[i][j] == '1')\r\n                curr[j] = prev[j] + 1;\r\n        }\r\n\r\n        int rowArea = largestRectangleArea(curr);\r\n        maxArea = max(maxArea, rowArea);\r\n\r\n        prev = curr;\r\n    }\r\n\r\n    return maxArea;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Let n be the total number of elements in the matrix, and m be the number of columns.\r\n- The time complexity of the solution is O(n*m) because we iterate through each element of the matrix once.\r\n- The space complexity is O(m) since we use additional arrays to store the heights and indices during the calculation.\r\n  However, the space complexity can be considered O(1) if we modify the input matrix directly.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "monotonic-stack"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "stack<int>",
        "for (int i = 0; i < arr.size()",
        "for (int i = arr.size()",
        "for (int i = 0; i < heights.size()",
        "while (!st.empty()",
        "while (!st.empty()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\09. Maximal Rectangle in binary matrix.cpp",
      "verified": false,
      "needsReview": true
    },
    "asteroids-collision": {
      "id": "asteroids-collision",
      "title": "Asteroids Collision",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "We are given an array of integers representing asteroids in a row. Each asteroid moves at the same speed.\r\nIf two asteroids meet, the smaller one will explode. If both are the same size, both will explode.\r\nFind out the state of the asteroids after all collisions.",
      "approach": "To solve this problem, we can use a stack to simulate the asteroid collisions.\r\n1. We iterate through each asteroid in the given array.\r\n2. For each asteroid, we check if it will collide with the asteroids in the stack.\r\n   - If the current asteroid is moving to the right (positive direction), we simply push it onto the stack.\r\n   - If the current asteroid is moving to the left (negative direction), we compare its size with the asteroids in the stack.\r\n     - If the stack is empty or the top asteroid in the stack is also moving to the left, we push the current asteroid onto the stack.\r\n     - If the top asteroid in the stack is moving to the right and its size is smaller than the current asteroid, we pop the top asteroid from the stack and continue the comparison.\r\n     - If the top asteroid in the stack is moving to the right and its size is equal to or greater than the current asteroid, we do not push the current asteroid onto the stack and continue to the next asteroid.\r\n3. After processing all the asteroids, the remaining asteroids in the stack represent the final state after collisions.\r\n\r\nExample:\r\nInput: asteroids = [5,10,-5]\r\nOutput: [5,10]\r\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> asteroidCollision(vector<int>& asteroids) {\r\n    stack<int> st;\r\n    for (int i = 0; i < asteroids.size(); i++) {\r\n        int siz = abs(asteroids[i]);\r\n        while (!st.empty() && (st.top() > 0 && asteroids[i] < 0) && (st.top() < siz)) {\r\n            st.pop();\r\n        }\r\n        // Check if same size asteroids collide\r\n        if (!st.empty() && (st.top() > 0 && asteroids[i] < 0) && st.top() == siz) {\r\n            st.pop();\r\n        }\r\n        else if (st.empty() || !(st.top() > 0 && asteroids[i] < 0)) {\r\n            st.push(asteroids[i]);\r\n        }\r\n    }\r\n    vector<int> ans;\r\n    while (!st.empty()) {\r\n        ans.push_back(st.top());\r\n        st.pop();\r\n    }\r\n    reverse(ans.begin(), ans.end());\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Let n be the number of asteroids in the given array.\r\n- The time complexity of the solution is O(n) because we iterate through each asteroid once.\r\n- The space complexity is O(n) because in the worst case, all asteroids can be stored in the stack.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "stack<int>",
        "for (int i = 0; i < asteroids.size()",
        "while (!st.empty()",
        "while (!st.empty()",
        ".push_back(",
        ".push(",
        ".pop(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\3. Monotonic Stack and Queue\\10. Asteroids Collision.cpp",
      "verified": false,
      "needsReview": true
    },
    "sliding-window-maximum": {
      "id": "sliding-window-maximum",
      "title": "Sliding window maximum",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers nums and a sliding window of size k, we need to find the maximum element in each sliding window as it moves from left to right.",
      "approach": "To solve this problem, we can use a deque (double-ended queue) to store the indices of elements in the current sliding window.\r\n1. We iterate through the first k elements and keep track of the maximum element by maintaining the following property:\r\n   - The deque stores the indices of elements in non-increasing order of their corresponding values in the nums array.\r\n   - If the current element is greater than or equal to the element at the back of the deque, we remove elements from the back until this condition is satisfied.\r\n   - This ensures that the front element of the deque is always the maximum element in the sliding window.\r\n2. After processing the first k elements, we start from the (k+1)th element and continue the following steps:\r\n   - If the index at the front of the deque is less than or equal to i-k, it means the maximum element in the previous sliding window is no longer valid. So, we remove it from the deque.\r\n   - Similar to step 1, we remove elements from the back of the deque until the current element is greater than or equal to the element at the back.\r\n   - Add the index of the current element to the deque.\r\n   - Add the maximum element (front of the deque) to the result for the current sliding window.\r\n3. Repeat step 2 until we process all elements in the nums array.\r\n\r\nExample:\r\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\r\nOutput: [3,3,5,5,6,7]\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n    deque<int> dq;\r\n    vector<int> ans;\r\n    \r\n    for (int i = 0; i < k; i++) {\r\n        while (!dq.empty() && nums[dq.back()] <= nums[i])\r\n            dq.pop_back();\r\n        dq.push_back(i);\r\n    }\r\n    \r\n    ans.push_back(nums[dq.front()]);\r\n    \r\n    for (int i = k; i < nums.size(); i++) {\r\n        if (dq.front() <= i - k)\r\n            dq.pop_front();\r\n        \r\n        while (!dq.empty() && nums[dq.back()] <= nums[i])\r\n            dq.pop_back();\r\n        \r\n        dq.push_back(i);\r\n        ans.push_back(nums[dq.front()]);\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Let n be the number of elements in the nums array.\r\n- The time complexity of the solution is O(n) because we iterate through each element once.\r\n- The space complexity is O(k) because the deque stores at most k elements at any given time.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "sliding-window"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < k; i++)",
        "for (int i = k; i < nums.size()",
        "while (!dq.empty()",
        "while (!dq.empty()",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\4. Implementation\\01. Sliding window maximum.cpp",
      "verified": false,
      "needsReview": true
    },
    "stock-span-problem": {
      "id": "stock-span-problem",
      "title": "Stock span problem",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Design an algorithm to calculate the span of a stock's price for the current day based on the price history.",
      "approach": "To solve this problem, we can use a stack to store the prices along with their corresponding spans.\r\n1. Initialize an empty stack and a variable to keep track of the current day (let's call it 'cnt').\r\n2. For each price, do the following:\r\n   - While the stack is not empty and the price at the top of the stack is less than or equal to the current price, pop elements from the stack.\r\n   - Calculate the span for the current price using the following formula:\r\n     - If the stack is empty, the span is cnt + 1.\r\n     - Otherwise, the span is cnt - stack.top().second, where stack.top().second represents the day corresponding to the price at the top of the stack.\r\n   - Push the current price along with its span (pair<int, int>) onto the stack.\r\n   - Increment the 'cnt' variable.\r\n3. Return the calculated spans.\r\n\r\nExample:\r\nInput: [100, 80, 60, 70, 60, 75, 85]\r\nOutput: [1, 1, 1, 2, 1, 4, 6]\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass StockSpanner {\r\npublic:\r\n    stack<pair<int, int>> st;\r\n    int cnt;\r\n\r\n    StockSpanner() {\r\n        cnt = 0;\r\n    }\r\n    \r\n    int next(int price) {\r\n        while (!st.empty() && st.top().first <= price)\r\n            st.pop();\r\n        \r\n        int ans = 1;\r\n        \r\n        if (!st.empty())\r\n            ans = cnt - st.top().second;\r\n        else\r\n            ans = cnt + 1;\r\n        \r\n        st.push({price, cnt});\r\n        cnt++;\r\n        \r\n        return ans;\r\n    }\r\n};\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity for each 'next' operation is O(1) on average because each price is pushed and popped from the stack at most once.\r\n- The space complexity is O(n), where n is the number of prices, because the stack can store at most n elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "stack<pair<int, int>",
        "while (!st.empty()",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\4. Implementation\\02. Stock span problem.cpp",
      "verified": false,
      "needsReview": true
    },
    "celebrity-problem": {
      "id": "celebrity-problem",
      "title": "Celebrity Problem",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Given a square NxN matrix representing people at a party, determine if there is a celebrity in the party. A celebrity is defined as a person who is known to all but does not know anyone at the party.",
      "approach": "To solve this problem, we can use a stack to keep track of potential celebrity candidates.\r\n1. Initially, push all the people (indices) onto the stack.\r\n2. While the stack size is greater than 1, do the following:\r\n   - Pop two people 'a' and 'b' from the stack.\r\n   - Check if 'a' knows 'b' and 'b' does not know 'a'. If true, push 'b' back onto the stack.\r\n   - Check if 'b' knows 'a' and 'a' does not know 'b'. If true, push 'a' back onto the stack.\r\n3. After the above loop, if the stack is empty, there is no celebrity, so return -1.\r\n4. Otherwise, get the potential celebrity from the top of the stack.\r\n5. Check if the potential celebrity is known by everyone else and does not know anyone else.\r\n   - If true, return the potential celebrity index.\r\n   - If false, return -1.\r\n\r\nExample:\r\nInput: N = 3, M[][] = {{0, 1, 0}, {0, 0, 0}, {0, 1, 0}}\r\nOutput: 1\r\nExplanation: Both person 0 and person 2 know person 1. Therefore, person 1 is the celebrity.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool knows(int a, int b, vector<vector<int>>& M) {\r\n    return M[a][b];\r\n}\r\n\r\nint celebrity(vector<vector<int>>& M, int n) {\r\n    stack<int> st;\r\n    for (int i = 0; i < n; i++) {\r\n        st.push(i);\r\n    }\r\n\r\n    while (st.size() > 1) {\r\n        int a = st.top();\r\n        st.pop();\r\n        int b = st.top();\r\n        st.pop();\r\n\r\n        if (knows(a, b, M) && !knows(b, a, M))\r\n            st.push(b);\r\n        else if (knows(b, a, M) && !knows(a, b, M))\r\n            st.push(a);\r\n    }\r\n\r\n    if (st.empty())\r\n        return -1;\r\n\r\n    int potentialCeleb = st.top();\r\n\r\n    // Check if the potential celebrity is known by everyone else and does not know anyone else\r\n    for (int i = 0; i < n; i++) {\r\n        if (i != potentialCeleb && (M[i][potentialCeleb] == 0 || M[potentialCeleb][i] == 1))\r\n            return -1;\r\n    }\r\n\r\n    return potentialCeleb;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity is O(N) because each person is pushed onto and popped from the stack at most once.\r\n- The space complexity is O(N) because the stack can store at most N elements.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "stack<int>",
        "for (int i = 0; i < n; i++)",
        "for (int i = 0; i < n; i++)",
        "while (st.size()",
        ".push(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\4. Implementation\\03. Celebrity Problem.cpp",
      "verified": false,
      "needsReview": true
    },
    "lru-cache": {
      "id": "lru-cache",
      "title": "LRU Cache",
      "category": "stack-queue",
      "difficulty": "unknown",
      "problemStatement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\r\n\r\n\r\nExample:\r\nLRUCache lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // cache is {1=1}\r\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\r\nlRUCache.get(1);    // return 1\r\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\r\nlRUCache.get(2);    // returns -1 (not found)\r\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\r\nlRUCache.get(1);    // return -1 (not found)\r\nlRUCache.get(3);    // return 3\r\nlRUCache.get(4);    // return 4",
      "approach": "To implement the LRU cache, we can use a combination of a hash map and a doubly linked list.\r\n- The hash map will store the key-value pairs, where the key is the cache key and the value is a pointer to the corresponding node in the linked list.\r\n- The doubly linked list will maintain the order of the recently used keys, where the front of the list represents the most recently used key and the back of the list represents the least recently used key.\r\n\r\nIMPLEMENTATION:\r\n1. Initialize the LRU cache with the given capacity.\r\n2. Implement the get(key) function:\r\n   - If the key exists in the cache, move the corresponding node to the front of the list (indicating it is the most recently used).\r\n   - Return the value of the key if it exists, otherwise return -1.\r\n3. Implement the put(key, value) function:\r\n   - If the key already exists in the cache, update its value and move the corresponding node to the front of the list.\r\n   - If the key does not exist:\r\n     - If the cache is full, remove the least recently used key (from the back of the list) and remove its entry from the hash map.\r\n     - Add the new key-value pair to the front of the list and insert its entry into the hash map.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass LRUCache {\r\nprivate:\r\n    int capacity;\r\n    unordered_map<int, list<pair<int, int>>::iterator> addr;\r\n    list<pair<int, int>> lru;\r\n\r\npublic:\r\n    LRUCache(int capacity) {\r\n        this->capacity = capacity;\r\n    }\r\n\r\n    int get(int key) {\r\n        if (addr.find(key) == addr.end())\r\n            return -1; // Key not found\r\n\r\n        auto keyPos = addr[key];\r\n        lru.splice(lru.begin(), lru, keyPos);\r\n        return lru.front().second;\r\n    }\r\n\r\n    void put(int key, int value) {\r\n        // If the key already exists, update its value and move it to the front\r\n        if (addr.find(key) != addr.end()) {\r\n            auto keyPos = addr[key];\r\n            lru.splice(lru.begin(), lru, keyPos);\r\n            lru.front().second = value;\r\n            return;\r\n        }\r\n\r\n        // If the capacity is full, remove the least recently used key\r\n        if (addr.size() == capacity) {\r\n            int backKey = lru.back().first;\r\n            lru.pop_back();\r\n            addr.erase(backKey);\r\n        }\r\n\r\n        lru.push_front({key, value});\r\n        addr[key] = lru.begin();\r\n    }\r\n};\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of both the get() and put() operations is O(1) since we use a hash map to achieve constant time access and update.\r\n- The space complexity is O(capacity) since the cache can store at most 'capacity' key-value pairs.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "backtracking"
      ],
      "fingerprint": [
        "unordered_map<int, list<pair<int, int>",
        ".find(",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\07.Stack and Queues\\4. Implementation\\04. LRU Cache.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-substring-without-repeating-characters": {
      "id": "longest-substring-without-repeating-characters",
      "title": "Longest Substring Without Repeating Characters",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "Given a string s, find the length of the longest substring without repeating characters.",
      "approach": "- We can use a sliding window approach to solve this problem.\r\n- We maintain a window that contains only unique characters.\r\n- We use a hash map to store the frequency of characters in the current window.\r\n- We iterate through the string and expand the window by adding one character at a time.\r\n- If we encounter a repeating character, we shrink the window from the left until the character is no longer in the window.\r\n- We keep track of the maximum window size encountered so far and return it as the result.\r\n\r\nExample:\r\nInput: s = \"abcabcbb\"\r\nOutput: 3\r\nExplanation: The answer is \"abc\", with the length of 3.",
      "code": "*/\r\n\r\nint lengthOfLongestSubstring(const string& s) {\r\n    int ans = 0;\r\n    unordered_map<char, int> mp;\r\n    int start = 0;\r\n    \r\n    for (int i = 0; i < s.size(); i++) {\r\n        mp[s[i]]++;\r\n        \r\n        while (mp.size() < i - start + 1) {\r\n            mp[s[start]]--;\r\n            if (mp[s[start]] == 0)\r\n                mp.erase(s[start]);\r\n            start++;\r\n        }\r\n        \r\n        if (mp.size() == i - start + 1)\r\n            ans = max(ans, i - start + 1);\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\n// Complexity Analysis:\r\n// - The time complexity of this algorithm is O(N), where N is the length of the input string `s`. We iterate through each character of the string once.\r\n// - The space complexity is O(M), where M is the number of unique characters in the string `s`. The unordered map `mp` can store up to M key-value pairs.",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "sliding-window"
      ],
      "fingerprint": [
        "unordered_map<char, int>",
        "for (int i = 0; i < s.size()",
        "while (mp.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\01. Longest Substring Without Repeating Characters.cpp",
      "verified": false,
      "needsReview": true
    },
    "fruit-into-baskets": {
      "id": "fruit-into-baskets",
      "title": "Fruit into Baskets",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits of size N, where fruits[i] is the type of fruit the ith tree produces.\r\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\r\n1. You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\r\n2. Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of the baskets.\r\n3. Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\r\n\r\nGiven the integer array fruits, return the maximum number of fruits you can pick.\r\n\r\nExample 1:\r\nInput: N = 3, fruits[] = {2, 1, 2}\r\nOutput: 3\r\nExplanation: We can pick fruits from all three trees.",
      "approach": "1. Initialize an unordered_map mp to track the frequency of fruit types.\r\n2. Initialize variables ans and start to keep track of the maximum number of fruits and the start index of the subarray.\r\n3. Iterate through the fruit trees using a sliding window approach:\r\n   - Increment the frequency of the current fruit type in the map.\r\n   - Enter a while loop to adjust the start index until the number of fruit types in the map becomes more than 2.\r\n   - During the adjustment, decrement the frequency of the fruit type at the start index and remove it from the map if the frequency becomes 0.\r\n   - Update the ans by taking the maximum of the current ans and the length of the current subarray if the number of fruit types in the map is at most 2.\r\n4. Return the maximum number of fruits (ans).\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint totalFruits(int N, vector<int>& fruits) {\r\n    unordered_map<int, int> mp;\r\n    int ans = 0, start = 0;\r\n    for(int i = 0; i < fruits.size(); i++) {\r\n        mp[fruits[i]]++;\r\n        while(mp.size() > 2) {\r\n            mp[fruits[start]]--;\r\n            if(mp[fruits[start]] == 0)\r\n                mp.erase(fruits[start]);\r\n            start++;\r\n        }\r\n        if(mp.size() <= 2)\r\n            ans = max(ans, i - start + 1);\r\n    }\r\n    return ans;\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(N), where N is the number of fruit trees. We iterate through the fruit trees once using the sliding window approach.\r\n- Space complexity: O(1) or O(2), as the size of the map can be at most 2 since we only have two baskets.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "sliding-window"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for(int i = 0; i < fruits.size()",
        "while(mp.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\03. Fruit into Baskets.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-repeating-character": {
      "id": "longest-repeating-character",
      "title": "Longest Repeating Character",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\r\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\r\n\r\nExample 1:\r\nInput: s = \"ABAB\", k = 2\r\nOutput: 4\r\nExplanation: Replace the two 'A's with two 'B's or vice versa.",
      "approach": "1. Create an unordered_set ltrs to store all unique letters in the given string s.\r\n2. Initialize a variable ans to keep track of the maximum length of the substring.\r\n3. Iterate through each letter ltr in the set ltrs:\r\n   - Initialize variables start and ltrCnt to track the starting index of the current substring and the count of ltr in the substring.\r\n   - Iterate through each character in the string s:\r\n     - If the character is equal to ltr, increment ltrCnt.\r\n     - Enter a while loop to adjust the start index until the number of characters in the substring that are different from ltr is more than k.\r\n     - During the adjustment, if the character at the start index is equal to ltr, decrement ltrCnt.\r\n     - Increment the start index.\r\n     - If the length of the current substring minus ltrCnt is at most k, update ans by taking the maximum of ans and the length of the current substring.\r\n4. Return the maximum length of the substring (ans).\r\n\r\nCODE:",
      "code": "*/\r\nint characterReplacement(string s, int k) {\r\n    unordered_set<char> ltrs;\r\n    for(auto it : s)\r\n        ltrs.insert(it);\r\n    int ans = 0;\r\n    for(auto ltr : ltrs) {\r\n        int start = 0, ltrCnt = 0;\r\n        for(int i = 0; i < s.size(); i++) {\r\n            if(s[i] == ltr)\r\n                ltrCnt++;\r\n            while((i - start + 1) - ltrCnt > k) {\r\n                if(s[start] == ltr)\r\n                    ltrCnt--;\r\n                start++;\r\n            }\r\n            if((i - start + 1) - ltrCnt <= k)\r\n                ans = max(ans, i - start + 1);\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(N * L), where N is the length of the string s and L is the number of unique letters in the string. We iterate through the string and perform the sliding window operation for each unique letter.\r\n    - L can have the max value of 26, so we can say the complexity would be O(N * 26) i.e O(N).\r\n- Space complexity: O(L), as we store the unique letters in the set ltrs.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "sliding-window"
      ],
      "fingerprint": [
        "unordered_set<char>",
        "for(auto it : s)",
        "for(auto ltr : ltrs)",
        "for(int i = 0; i < s.size()",
        "while((i - start + 1)",
        ".insert("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\04. Longest Repeating Character.cpp",
      "verified": false,
      "needsReview": true
    },
    "binary-subarrays-with-sum": {
      "id": "binary-subarrays-with-sum",
      "title": "Binary Subarrays with Sum",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum equal to the goal.\r\n\r\nExample 1:\r\nInput: nums = [1,0,1,0,1], goal = 2\r\nOutput: 4\r\nExplanation: The 4 subarrays are bolded and underlined below:\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]",
      "approach": "1. Create an unordered_map mp to store the prefix sum and its frequency.\r\n2. Initialize a variable prefSum to keep track of the prefix sum.\r\n3. Initialize a variable cnt to keep track of the count of subarrays with a sum equal to the goal.\r\n4. Iterate through each element nums[i] in the array:\r\n   - Update prefSum by adding nums[i].\r\n   - Check if prefSum is equal to the goal, if so, increment cnt.\r\n   - Check if the difference between prefSum and goal (prefSum - goal) exists in the map.\r\n     - If it exists, increment cnt by the frequency of (prefSum - goal) in the map, as this would mean we have found subarrays with a sum equal to the goal.\r\n   - Increment the frequency of prefSum in the map.\r\n5. Return cnt, which represents the number of non-empty subarrays with a sum equal to the goal.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nint numSubarraysWithSum(vector<int>& nums, int goal) {\r\n    unordered_map<int, int> mp;\r\n    int prefSum = 0, cnt = 0;\r\n    for(int i = 0; i < nums.size(); i++) {\r\n        prefSum += nums[i];\r\n        if(prefSum == goal)\r\n            cnt++;\r\n        if(mp.find(prefSum - goal) != mp.end())\r\n            cnt += mp[prefSum - goal];\r\n        mp[prefSum]++;\r\n    }\r\n    return cnt;\r\n}\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(N), where N is the size of the input array nums. We traverse the array once and perform constant time operations in the loop.\r\n- Space complexity: O(N), as the worst-case scenario would be that all prefix sums are distinct, so the map mp would store N prefix sums.\r\n    - we can reduce the space complexity to O(1) if we use this countOfSubarrays with atmost sum = k - atmost sum = k-1 \r\n    - which will return in countofSubarrays with sum exactly K, but this won't work if array has -ve elements\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "for(int i = 0; i < nums.size()",
        ".find("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\05. Binary Subarrays with Sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-nice-subarrays": {
      "id": "count-the-number-of-nice-subarrays",
      "title": "Count the number of nice subarrays",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "/*Given an array of integers nums and an integer k, a continuous subarray is called nice if there are k odd numbers in it. Return the number of nice subarrays.\r\n\r\nExample 1:\r\nInput: nums = [1,1,2,1,1], k = 3\r\nOutput: 2\r\nExplanation: The only subarrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].",
      "approach": "1. Define a helper function called atMostK, which calculates the number of subarrays with at most k odd numbers.\r\n2. Initialize variables start to 0, oddCnt to 0, and ans to 0.\r\n3. Iterate through each element nums[i] in the array:\r\n   - If nums[i] is odd, increment oddCnt by 1.\r\n   - While oddCnt is greater than k, move the start pointer and decrement oddCnt if the element at nums[start] is odd. This ensures that we maintain at most k odd numbers in the subarray.\r\n   - Add the count of subarrays from start to i (i - start + 1) to ans.\r\n4. Return ans, which represents the number of subarrays with at most k odd numbers.\r\n5. In the numberOfSubarrays function, return the difference between atMostK(nums, k) and atMostK(nums, k - 1) to get the number of nice subarrays.\r\n\r\nCODE:",
      "code": "*/\r\nint atMostK(vector<int>& nums, int k) {\r\n    int start = 0, oddCnt = 0, ans = 0;\r\n    for(int i = 0; i < nums.size(); i++) {\r\n        if(nums[i] % 2 != 0)\r\n            oddCnt++;\r\n        while(oddCnt > k) {\r\n            if(nums[start] % 2 != 0)\r\n                oddCnt--;\r\n            start++;\r\n        }\r\n        ans += i - start + 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nint numberOfSubarrays(vector<int>& nums, int k) {\r\n    return atMostK(nums, k) - atMostK(nums, k - 1);\r\n}\r\n\r\n/*\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(N), where N is the size of the input array nums. We traverse the array once in both the atMostK function and the numberOfSubarrays function.\r\n- Space complexity: O(1), as we use constant extra space throughout the algorithm.\r\n*/",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(int i = 0; i < nums.size()",
        "while(oddCnt > k)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\06. Count the number of nice subarrays.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-substrings-containing-all-3-characters": {
      "id": "number-of-substrings-containing-all-3-characters",
      "title": "Number of Substrings Containing all 3 characters",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "Given a string s consisting only of characters 'a', 'b', and 'c', you need to count the number of substrings that contain at least one occurrence of all these characters.",
      "approach": "To count the number of substrings with at least one occurrence of 'a', 'b', and 'c', we can use a sliding window approach.\r\n\r\n1. Create a helper function, countOfUnvalidSubstrings, which counts the number of substrings that do not contain all three characters.\r\n   - Initialize an unordered_map, mp, to keep track of the counts of characters in the current window.\r\n   - Initialize start to 0 and ans to 0.\r\n   - Iterate over the string from left to right:\r\n     - Increment the count of the current character in mp.\r\n     - If the number of unique characters in mp exceeds 2, it means we have found an invalid substring.\r\n       - Decrement the count of the character at the start of the window in mp.\r\n       - If the count becomes zero, remove the character from mp.\r\n       - Move the start of the window to the next position.\r\n     - Add the length of the current window to ans.\r\n   - Return ans.\r\n\r\n2. In the main function, numberOfSubstrings:\r\n   - Calculate the total number of substrings, cntOfTotalSubstrings, using the formula (n * (n + 1)) / 2, where n is the length of the string.\r\n   - Subtract the count of invalid substrings obtained from countOfUnvalidSubstrings from cntOfTotalSubstrings.\r\n   - Return the resulting count.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "sliding-window",
        "union-find"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\07. Number of Substrings Containing all 3 characters.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximum-points-you-can-obtaln-form-the-card": {
      "id": "maximum-points-you-can-obtaln-form-the-card",
      "title": "Maximum Points you can obtaln form the card",
      "category": "sliding-window",
      "difficulty": "medium",
      "problemStatement": "You are given an array of cards, each with an associated number of points. You can take exactly k cards, either from the beginning or from the end of the row. Your goal is to maximize the sum of the points of the cards you have taken. Return the maximum score you can obtain.",
      "approach": "To maximize the score, we need to minimize the sum of the discarded cards. We can find the minimum sum of a subarray of size (n - k) using a sliding window approach.\r\n\r\n1. Create a helper function, minimumSumOfSizeK, which finds the minimum sum of a subarray of size k.\r\n   - Initialize ans to INT_MAX, currsum to 0, and start to 0.\r\n   - Iterate over the array from left to right:\r\n     - Add the current element to currsum.\r\n     - If the size of the current window (i - start + 1) exceeds k, remove the element at the start of the window from currsum and move the start to the next position.\r\n     - If the size of the current window is k, update ans with the minimum of ans and currsum.\r\n   - Return ans.\r\n\r\n2. In the main function, maxScore:\r\n   - Calculate the total sum of all the cards, totalSum.\r\n   - Calculate the size of the discarded cards, windowSize, which is (n - k).\r\n   - Find the minimum sum of a subarray of size windowSize using the minimumSumOfSizeK function and store it in discardedSum.\r\n   - Return the maximum score, which is (totalSum - discardedSum).\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(n), where n is the size of the cardPoints array. We iterate over the array once to calculate the total sum and find the minimum sum of a subarray.\r\n- Space complexity: O(1), as the extra space used is constant throughout the algorithm.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "sliding-window",
        "union-find"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\1. Medium Problems\\08. Maximum Points you can obtaln form the card.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-substring-with-at-most-k-unique-characters": {
      "id": "longest-substring-with-at-most-k-unique-characters",
      "title": "Longest Substring with at most K unique characters",
      "category": "sliding-window",
      "difficulty": "hard",
      "problemStatement": "Given a string 'str' and an integer 'K', find the length of the largest substring with at most 'K' distinct characters.\r\n\r\nEXAMPLE:\r\nFor example, if we are given 'str' = \"abbbbbbc\" and 'K' = 2, the substrings that can be formed are [\"abbbbbb\", \"bbbbbbc\"]. Hence, the answer is 7.",
      "approach": "We can use a sliding window approach to solve this problem.\r\n\r\n1. Create a function, kDistinctChars, that takes 'k' and the input string 's' as parameters.\r\n   - Initialize an unordered_map, mp, to store the frequency of characters.\r\n   - Initialize 'start' to 0 and 'ans' to 0.\r\n   - Iterate over the string from left to right:\r\n     - Increment the frequency of the current character in the map.\r\n     - If the number of distinct characters in the map exceeds 'k', move the 'start' pointer to the right and remove characters from the map until the number of distinct characters becomes equal to 'k'.\r\n     - Update 'ans' with the maximum length of the substring (i - start + 1).\r\n   - Return 'ans', which represents the length of the largest substring with at most 'k' distinct characters.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(n), where n is the length of the string 's'. We iterate over the string once using the sliding window approach.\r\n- Space complexity: O(k), as the space used by the unordered_map is proportional to the number of distinct characters, which can be at most 'k'.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\2. Hard Problems\\01. Longest Substring with at most K unique characters.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-substrings-with-exactly-k-unique-characters": {
      "id": "count-the-number-of-substrings-with-exactly-k-unique-characters",
      "title": "Count the number of substrings with exactly K unique characters",
      "category": "sliding-window",
      "difficulty": "hard",
      "problemStatement": "Given an integer array 'nums' and an integer 'k', find the number of good subarrays of 'nums'.\r\n\r\nA good array is an array where the number of different integers in that array is exactly 'k'.\r\n\r\nFor example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\r\nA subarray is a contiguous part of an array.\r\n\r\nEXAMPLE:\r\nInput: nums = [1,2,1,2,3], k = 2\r\nOutput: 7\r\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]",
      "approach": "We can solve this problem using a sliding window approach.\r\n\r\n1. Create a function, kDistinctIntegers, that takes 'k' and the input vector 's' as parameters.\r\n   - Initialize an unordered_map, mp, to store the frequency of elements.\r\n   - Initialize 'start' to 0 and 'ans' to 0.\r\n   - Iterate over the vector from left to right:\r\n     - Increment the frequency of the current element in the map.\r\n     - If the number of distinct elements in the map exceeds 'k', move the 'start' pointer to the right and remove elements from the map until the number of distinct elements becomes equal to 'k'.\r\n     - Update 'ans' by adding the number of subarrays that can be formed with exactly 'k' distinct integers, which is equal to (i - start + 1).\r\n   - Return 'ans', which represents the total number of good subarrays.\r\n\r\n2. Create a function, subarraysWithKDistinct, that takes 'nums' and 'k' as parameters.\r\n   - Return the difference between the number of good subarrays with 'k' distinct integers and the number of good subarrays with 'k-1' distinct integers, which can be calculated using the kDistinctIntegers function.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(n), where n is the length of the input vector 'nums'. We iterate over the vector once using the sliding window approach.\r\n- Space complexity: O(k), as the space used by the unordered_map is proportional to the number of distinct elements, which can be at most 'k'.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\2. Hard Problems\\02. Count the number of substrings with exactly K unique characters.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-window-substring": {
      "id": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "category": "sliding-window",
      "difficulty": "hard",
      "problemStatement": "Given two strings 's' and 't' of lengths 'm' and 'n' respectively, find the minimum window substring of 's' that contains all the characters of 't' (including duplicates). If there is no such substring, return an empty string.\r\n\r\nEXAMPLE:\r\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\r\nOutput: \"BANC\"\r\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string 't'.",
      "approach": "We can solve this problem using a sliding window approach.\r\n\r\n1. Create a function, minWindow, that takes 's' and 't' as parameters.\r\n   - Initialize an unordered_map, mp, to store the frequency of characters in 't'.\r\n   - Iterate over 't' and update the frequencies in the map.\r\n   - Initialize 'count' to the number of unique characters in 't'.\r\n   - Initialize 'start' to 0 and 'minlen' to INT_MAX.\r\n   - Initialize 'substrBegin' to 0, which represents the starting index of the minimum window substring.\r\n   - Iterate over 's' from left to right:\r\n     - Decrement the frequency of the current character in the map.\r\n     - If the frequency becomes 0, decrement 'count'.\r\n     - Check if 'count' becomes 0, indicating that we have found a window containing all characters of 't'.\r\n       - If the current window length is smaller than 'minlen', update 'minlen' and 'substrBegin' to the current window length and starting index respectively.\r\n       - Move the 'start' pointer to the right, increment the frequency of the character at 'start' in the map, and increment 'count' if the frequency becomes greater than 0.\r\n   - Return the minimum window substring by using the substr function on 's' with 'substrBegin' and 'minlen' as parameters.\r\n   - If 'minlen' is still INT_MAX, return an empty string.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time complexity: O(m + n), where m is the length of 's' and n is the length of 't'. We iterate over both strings once using the sliding window approach.\r\n- Space complexity: O(n), as the space used by the unordered_map is proportional to the number of unique characters in 't', which can be at most 'n'.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "sliding-window"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\08. Sliding Window\\2. Hard Problems\\03. Minimum Window Substring.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-min-heap": {
      "id": "implement-min-heap",
      "title": "Implement min heap",
      "category": "heaps",
      "difficulty": "unknown",
      "problemStatement": "Implement a min heap with all the required methods.",
      "approach": "A min heap is a binary tree-based data structure where the value of each parent node is less than or equal to the values of its children. The heapify operation is used to maintain the heap property, where a node is compared with its children and swapped if necessary.\r\n\r\nIn the given code, the minHeap class is implemented using a vector to store the elements. The heapify function is used to maintain the heap property by comparing the node with its left and right children and swapping if necessary. The bottomUpHeapify function is used to fix the heap property from a child node to its parent node.\r\n\r\nThe insert function adds an element to the heap by appending it to the vector and performing bottom-up heapification. The removeMin function removes the minimum element from the heap by replacing it with the last element, removing the last element, and then performing heapify. The minElement function returns the minimum element of the heap.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The heapify operation takes O(log n) time complexity, where n is the number of elements in the heap.\r\n- The bottomUpHeapify operation also takes O(log n) time complexity.\r\n- The insert operation takes O(log n) time complexity.\r\n- The removeMin operation takes O(log n) time complexity.\r\n- The minElement operation takes O(1) time complexity.\r\n\r\nOverall, the time complexity of the minHeap class methods is O(log n), where n is the number of elements in the heap.",
      "code": "*/\r\n\r\n\r\nclass minHeap {\r\npublic:\r\n    vector<int> pq;\r\n\r\n    // Function to heapify the heap.\r\n    void heapify(int node) {\r\n        int leftChild = (2 * node) + 1;\r\n        int rightChild = (2 * node) + 2;\r\n        int smallest = node;\r\n\r\n        if (leftChild < pq.size() && pq[leftChild] < pq[smallest])\r\n            smallest = leftChild;\r\n\r\n        if (rightChild < pq.size() && pq[rightChild] < pq[smallest])\r\n            smallest = rightChild;\r\n\r\n        if (smallest != node) {\r\n            swap(pq[node], pq[smallest]);\r\n            heapify(smallest);\r\n        }\r\n    }\r\n\r\n    void bottomUpHeapify(int node) {\r\n        int parent = (node - 1) / 2;\r\n        if (parent >= 0 && pq[parent] > pq[node]) {\r\n            swap(pq[parent], pq[node]);\r\n            bottomUpHeapify(parent);\r\n        }\r\n    }\r\n\r\n    // Function to insert 'val' in the heap.\r\n    void insert(int val) {\r\n        pq.push_back(val);\r\n        bottomUpHeapify(pq.size() - 1);\r\n    }\r\n\r\n    // Function to remove the minimum element.\r\n    void removeMin() {\r\n        pq[0] = pq.back();\r\n        pq.pop_back();\r\n        heapify(0);\r\n    }\r\n\r\n    // Function to return the minimum element.\r\n    int minElement() {\r\n        return (pq.empty()) ? -1 : pq[0];\r\n    }\r\n};",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "heap"
      ],
      "fingerprint": [
        "vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\1. Learning\\01. Implement min heap.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-if-array-is-heap": {
      "id": "check-if-array-is-heap",
      "title": "Check if array is heap",
      "category": "heaps",
      "difficulty": "unknown",
      "problemStatement": "Given an array A of size N, the task is to check if the given array represents a Binary Max Heap.",
      "approach": "1. Start from the root node and recursively check if the current node satisfies the max-heap property.\r\n2. The max-heap property states that every node should be greater than all of its descendants.\r\n3. Check if the current node is greater than its left and right children.\r\n4. Recursively check the max-heap property for the left and right subtrees.\r\n5. If the current node is greater and the left and right subtrees also satisfy the max-heap property, then the array represents a binary max heap.\r\n\r\nThe solve function is implemented to recursively check the max-heap property for each node. It checks if the current node is greater than its left and right children. If the current node is greater and the left and right subtrees also satisfy the max-heap property, then the array represents a binary max heap.\r\n\r\nThe isMaxHeap function is the main function that calls the solve function with the root node (index 0) and the size of the array. It returns true if the array represents a binary max heap, and false otherwise.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the isMaxHeap function is O(N), where N is the size of the array. This is because we need to check the max-heap property for each node in the array.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(N) due to the recursive calls in the solve function.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion",
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\1. Learning\\02. Check if array is heap.cpp",
      "verified": false,
      "needsReview": true
    },
    "convert-min-heap-to-max-heap": {
      "id": "convert-min-heap-to-max-heap",
      "title": "Convert min heap to max heap",
      "category": "heaps",
      "difficulty": "unknown",
      "problemStatement": "You are given an array arr of N integers representing a min Heap. The task is to convert it to a max Heap.\r\n\r\nA max-heap is a complete binary tree in which the value in each internal node is greater than or equal to the values in the children of that node.",
      "approach": "To convert a min-heap to a max-heap, we need to rearrange the elements of the array in such a way that the max-heap property is satisfied.\r\n1. Start from the last internal node of the heap (N/2 - 1) and perform heapify on each internal node.\r\n2. Heapify a node by comparing it with its left and right children and swapping if necessary.\r\n3. Continue this process for all internal nodes until the entire heap is converted to a max-heap.\r\n\r\nThe heapify function is implemented to compare a node with its left and right children and swap if necessary to satisfy the max-heap property.\r\n\r\nThe convertMinToMaxHeap function is the main function that converts the given min-heap to a max-heap. It starts from the last internal node (N/2 - 1) and performs heapify on each internal node.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the convertMinToMaxHeap function is O(N), where N is the size of the array. This is because we need to perform heapify on each internal node of the heap.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(1) as no extra space is used in the conversion process.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\1. Learning\\03. Convert min heap to max heap.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-largest-element": {
      "id": "kth-largest-element",
      "title": "Kth largest element",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given an integer array nums and an integer k, return the kth largest element in the array.",
      "approach": "To find the kth largest element in the array, we can use a min-heap of size k.\r\n1. Initialize a min-heap (priority queue) of size k.\r\n2. Insert the first k elements of the array into the min-heap.\r\n3. For the remaining elements in the array, if an element is larger than the top element of the min-heap, replace the top element with the current element and heapify to maintain the min-heap property.\r\n4. After processing all the elements, the top element of the min-heap will be the kth largest element in the array.\r\n\r\nThe findKthLargest function implements this approach. It uses a min-heap (priority queue) to find the kth largest element in the array without sorting the entire array.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the findKthLargest function is O(N log k), where N is the size of the array. Inserting elements into the min-heap and heapifying take O(log k) time, and we do this for N-k elements. The overall time complexity is dominated by the heap operations.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(k) as we need to store k elements in the min-heap.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\01. Kth largest element.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-smallest-element": {
      "id": "kth-smallest-element",
      "title": "Kth smallest element",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given an array arr[] and an integer K, where K is smaller than the size of the array, the task is to find the Kth smallest element in the given array. It is given that all array elements are distinct.",
      "approach": "To find the Kth smallest element in the array, we can use a max-heap of size K.\r\n1. Initialize a max-heap (priority queue) of size K.\r\n2. Insert the first K elements of the array into the max-heap.\r\n3. For the remaining elements in the array, if an element is smaller than the top element of the max-heap, replace the top element with the current element and heapify to maintain the max-heap property.\r\n4. After processing all the elements, the top element of the max-heap will be the Kth smallest element in the array.\r\n\r\nThe findKthLargest function implements this approach. It uses a max-heap (priority queue) to find the Kth smallest element in the array without sorting the entire array.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the findKthLargest function is O(N log K), where N is the size of the array. Inserting elements into the max-heap and heapifying take O(log K) time, and we do this for N-K elements. The overall time complexity is dominated by the heap operations.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(K) as we need to store K elements in the max-heap.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\02. Kth smallest element.cpp",
      "verified": false,
      "needsReview": true
    },
    "merge-k-sorted-arrays": {
      "id": "merge-k-sorted-arrays",
      "title": "Merge K sorted arrays",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given K sorted arrays arranged in the form of a matrix of size K*K, the task is to merge them into one sorted array.",
      "approach": "To merge K sorted arrays, we can use a min-heap (priority queue) to store the smallest elements from each array.\r\n1. Create a min-heap of size K to store the current smallest elements from each array.\r\n2. Initialize the min-heap with the first element from each array.\r\n3. While the min-heap is not empty, extract the smallest element from the min-heap, add it to the merged array, and replace it with the next element from the same array.\r\n4. Repeat step 3 until all elements from all arrays are processed.\r\n\r\nThe mergeKArrays function implements this approach. It uses a min-heap (priority queue) to merge K sorted arrays into one sorted array.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the mergeKArrays function is O(K^2 log K), where K is the size of each array. Inserting elements into the min-heap and extracting the minimum element take O(log K) time, and we do this for K^2 elements. The overall time complexity is dominated by the heap operations.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(K) as we need to store K elements in the min-heap.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\03. Merge K sorted arrays.cpp",
      "verified": false,
      "needsReview": true
    },
    "merge-k-sorted-lists": {
      "id": "merge-k-sorted-lists",
      "title": "Merge K sorted Lists",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "approach": "To merge K sorted linked lists, we can use a min-heap (priority queue) to store the smallest nodes from each list.\r\n1. Create a min-heap of size K to store the current smallest nodes from each list.\r\n2. Initialize the min-heap with the head node from each list.\r\n3. While the min-heap is not empty, extract the smallest node from the min-heap, add it to the merged linked list, and replace it with the next node from the same list.\r\n4. Repeat step 3 until all nodes from all lists are processed.\r\n\r\nThe mergeKLists function implements this approach. It uses a min-heap (priority queue) to merge K sorted linked lists into one sorted linked list.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the mergeKLists function is O(N log K), where N is the total number of nodes across all lists and K is the number of linked lists. Inserting nodes into the min-heap and extracting the minimum node take O(log K) time, and we do this for N nodes. The overall time complexity is dominated by the heap operations.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(K) as we need to store K nodes in the min-heap.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\04. Merge K sorted Lists.cpp",
      "verified": false,
      "needsReview": true
    },
    "arrange-by-rank": {
      "id": "arrange-by-rank",
      "title": "Arrange by rank",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given an array of integers arr, replace each element with its rank.",
      "approach": "To assign ranks to the elements in the array, we can use a min-heap (priority queue) to sort the elements in ascending order along with their indices.\r\n1. Create a min-heap to store pairs of (element, index) in ascending order.\r\n2. Push each element along with its index into the min-heap.\r\n3. Initialize the rank as 0 and the previous element as INT_MIN (an arbitrary value that never matches any element).\r\n4. While the min-heap is not empty, extract the minimum element from the min-heap.\r\n5. If the current element is different from the previous element, increment the rank.\r\n6. Assign the rank to the element at its corresponding index in the result array.\r\n7. Repeat steps 4-6 until all elements are processed.\r\n\r\nThe arrayRankTransform function implements this approach. It uses a min-heap to assign ranks to the elements in the array.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the arrayRankTransform function is O(N log N), where N is the size of the array. Inserting elements into the min-heap and extracting the minimum element take O(log N) time, and we do this for N elements. The overall time complexity is dominated by the heap operations.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(N) as we need to store N elements in the min-heap and the result array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\05. Arrange by rank.cpp",
      "verified": false,
      "needsReview": true
    },
    "task-scheduler": {
      "id": "task-scheduler",
      "title": "Task Scheduler",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.",
      "approach": "To minimize the total time, we need to consider the task with the maximum frequency. Let's assume the maximum frequency is maxfreq. The CPU will need at least (maxfreq - 1) intervals of cooldown time between the executions of the tasks with the maximum frequency.\r\n\r\n1. Create a frequency map to count the occurrences of each task.\r\n2. Find the maximum frequency maxfreq.\r\n3. Calculate the total number of intervals required by multiplying (maxfreq - 1) with the cooldown period n.\r\n4. Iterate through the frequency map and count the number of tasks with the maximum frequency. Add this count to the total number of intervals.\r\n5. Return the maximum of the total number of intervals and the total number of tasks.\r\n\r\nThe leastInterval function implements this approach.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the leastInterval function is O(N), where N is the number of tasks. We iterate through the tasks twice: once to calculate the frequencies and find the maximum frequency, and once to count the number of tasks with the maximum frequency. Both iterations take O(N) time.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(1) because the frequency map has a fixed number of unique tasks (26 lowercase letters).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\06. Task Scheduler.cpp",
      "verified": false,
      "needsReview": true
    },
    "divide-array-into-sets-of-k-consecutive-number": {
      "id": "divide-array-into-sets-of-k-consecutive-number",
      "title": "Divide array into sets of K consecutive number",
      "category": "heaps",
      "difficulty": "medium",
      "problemStatement": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\r\n\r\nReturn true if it is possible. Otherwise, return false.\r\n\r\nExample:\r\n\r\nInput: nums = [1,2,3,3,4,4,5,6], k = 4\r\nOutput: true\r\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].",
      "approach": "1. First, we check if the array size is divisible by k. If not, it is not possible to divide the array into sets of k consecutive numbers.\r\n2. We use a frequency map mp to count the occurrences of each element in the array.\r\n3. We sort the array nums in ascending order.\r\n4. For each number num in nums, we check if it is still available (mp[num] > 0).\r\n5. If num is available, we iterate from num + 1 to num + k - 1 and check if each number is available in mp as well. If any number is not available, we return false.\r\n6. If all numbers are available, we decrement the counts in mp accordingly.\r\n7. If we reach the end of the loop, it means it is possible to divide the array into sets of k consecutive numbers, and we return true.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\2. Medium Problems\\07. Divide array into sets of K consecutive number.cpp",
      "verified": false,
      "needsReview": true
    },
    "design-twitter": {
      "id": "design-twitter",
      "title": "Design Twitter",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.",
      "approach": "To design the Twitter class, we can use the following data structures:\r\n\r\n1. unordered_map<int, vector<int>> following: This map stores the users and the list of users they are following. Each user follows themselves initially.\r\n2. unordered_map<int, deque<pair<int, int>>> posts: This map stores the tweets of each user. Each tweet is represented by a pair of (timestamp, tweetId). We use a deque to maintain the most recent 10 tweets for each user.\r\n3. int time: This variable keeps track of the timestamp for tweets.\r\n\r\nThe Twitter class provides the following methods:\r\n\r\n1. Twitter(): Initializes the Twitter object.\r\n2. void postTweet(int userId, int tweetId): Composes a new tweet with ID tweetId by the user userId. The tweet is added to the posts map with the current timestamp. If the size of the user's tweets exceeds 10, the oldest tweet is removed.\r\n3. vector<int> getNewsFeed(int userId): Retrieves the 10 most recent tweet IDs in the user's news feed. It iterates through the users that the given user follows and adds their tweets to a set. The set is sorted in descending order of timestamps. The first 10 tweets are returned.\r\n4. void follow(int followerId, int followeeId): The user with ID followerId starts following the user with ID followeeId. The followeeId is added to the followerId's following list.\r\n5. void unfollow(int followerId, int followeeId): The user with ID followerId stops following the user with ID followeeId. The followeeId is removed from the followerId's following list.\r\n\r\nThe code provided implements the Twitter class with the above approach.\r\n\r\nTIME COMPLEXITY:\r\nThe time complexity of the postTweet method is O(1) for adding a tweet to the user's posts.\r\nThe time complexity of the getNewsFeed method is O(F * P * log(P)) where F is the number of users the given user follows and P is the maximum number of posts by any user. The method iterates through the posts of each followed user, which takes O(F * P) time, and sorts the tweets, which takes O(P * log(P)) time.\r\nThe time complexity of the follow and unfollow methods is O(1) for adding or removing a user from the following list.\r\n\r\nSPACE COMPLEXITY:\r\nThe space complexity is O(U + P) where U is the number of users and P is the total number of posts. The posts map stores the tweets of each user, and the size of the posts map is bounded by the number of users. The maximum size of the posts deque for each user is 10.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set",
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\01. Design Twitter.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-cost-to-join-n-ropes": {
      "id": "minimum-cost-to-join-n-ropes",
      "title": "Minimum Cost to join n ropes",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "There are given N ropes of different lengths, we need to connect these ropes into one rope. The cost to connect two ropes is equal to the sum of their lengths. The task is to connect the ropes with the minimum cost. Given an array arr[] containing the lengths of the ropes.\r\n\r\nExample:\r\nInput: arr[] = {4, 3, 2, 6}\r\nOutput: 29\r\nExplanation: The minimum cost is obtained by connecting ropes in the following order:\r\n1. Connect ropes of length 2 and 3, cost = 2 + 3 = 5, resulting array = {4, 5, 6}\r\n2. Connect ropes of length 4 and 5, cost = 4 + 5 = 9, resulting array = {9, 6}\r\n3. Connect ropes of length 6 and 9, cost = 6 + 9 = 15, resulting array = {15}\r\nTotal cost = 5 + 9 + 15 = 29",
      "approach": "1. Use a priority queue (min heap) to store the lengths of the ropes.\r\n2. Push all the rope lengths into the priority queue.\r\n3. While the priority queue has more than one element:\r\n   - Extract the two smallest ropes from the priority queue.\r\n   - Add their lengths together to get the cost.\r\n   - Push the sum back into the priority queue.\r\n   - Update the total cost.\r\n4. Return the total cost as the minimum cost of connecting the ropes.\r\n\r\nComplexity Analysis:\r\n- Time complexity: O(n log n), where n is the number of ropes. Inserting and extracting elements from the priority queue take O(log n) time, and the loop runs for (n-1) iterations.\r\n- Space complexity: O(n) to store the rope lengths in the priority queue.\r\n\r\nCode:",
      "code": "*/\r\n\r\nlong long connectRopes(int* arr, int n)\r\n{\r\n    long long ans = 0;\r\n    priority_queue<int, vector<int>, greater<int>> pq;\r\n    \r\n    // Push all rope lengths into the priority queue\r\n    for (int i = 0; i < n; i++) {\r\n        pq.push(arr[i]);\r\n    }\r\n    \r\n    // Connect ropes until only one rope remains\r\n    while (pq.size() > 1) {\r\n        int a = pq.top(); pq.pop();\r\n        int b = pq.top(); pq.pop();\r\n        int sum = a + b;\r\n        ans += sum;\r\n        \r\n        // Push the sum back into the priority queue if there are more than one rope remaining\r\n        if (!pq.empty()) {\r\n            pq.push(sum);\r\n        }\r\n    }\r\n    \r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        "vector<int>",
        "priority_queue<int, vector<int>",
        "queue<int, vector<int>",
        "for (int i = 0; i < n; i++)",
        "while (pq.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\02. Minimum Cost to join n ropes.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-largest-element-in-stream": {
      "id": "kth-largest-element-in-stream",
      "title": "Kth largest element in stream",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nImplement KthLargest class:\r\n- KthLargest(int k, int[] nums): Initializes the object with the integer k and the stream of integers nums.\r\n- int add(int val): Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\r\n\r\nExample:\r\nInput:\r\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\r\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\r\nOutput:\r\n[null, 4, 5, 5, 8, 8]\r\n\r\nExplanation:\r\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\r\nkthLargest.add(3);   // return 4\r\nkthLargest.add(5);   // return 5\r\nkthLargest.add(10);  // return 5\r\nkthLargest.add(9);   // return 8\r\nkthLargest.add(4);   // return 8",
      "approach": "- Use a min heap (priority queue) to store the k largest elements.\r\n- Initialize the min heap with the first k elements from the stream (nums) in the constructor.\r\n- For each subsequent element in the stream, add it to the min heap.\r\n- If the size of the min heap exceeds k, remove the smallest element.\r\n- The top element of the min heap represents the kth largest element.\r\n\r\nComplexity Analysis:\r\n- The time complexity of adding an element is O(log k) due to the insertion and removal operations in the min heap.\r\n- The space complexity is O(k) to store the k largest elements in the min heap.\r\n\r\nCode:",
      "code": "*/\r\n\r\nclass KthLargest {\r\nprivate:\r\n    priority_queue<int, vector<int>, greater<int>> pq;\r\n    int k;\r\n    \r\npublic:\r\n    KthLargest(int k, vector<int>& nums) {\r\n        this->k = k;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            pq.push(nums[i]);\r\n            if (pq.size() > k) {\r\n                pq.pop();\r\n            }\r\n        }\r\n    }\r\n    \r\n    int add(int val) {\r\n        pq.push(val);//* this is amazing to use\r\n        if (pq.size() > k) {\r\n            pq.pop();\r\n        }\r\n        return pq.top();\r\n    }\r\n};",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "priority_queue<int, vector<int>",
        "queue<int, vector<int>",
        "for (int i = 0; i < nums.size()",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\03. Kth largest element in stream.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximum-k-sum-combinations": {
      "id": "maximum-k-sum-combinations",
      "title": "Maximum K sum combinations",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "Given two integer arrays A and B of size N each. A sum combination is made by adding one element from array A and another element from array B. Return the maximum K valid distinct sum combinations from all the possible sum combinations. Output array must be sorted in non-increasing order.\r\n\r\nExample:\r\nInput:\r\nN = 2\r\nK = 2\r\nA[] = {3, 2}\r\nB[] = {1, 4}\r\nOutput: {7, 6}\r\nExplanation: \r\n7 -> (A: 3) + (B: 4)\r\n6 -> (A: 2) + (B: 4)",
      "approach": "1. Sort arrays A and B in non-increasing order.\r\n2. Initialize a min-heap (priority_queue) to store the sum combinations.\r\n3. Iterate over each element in array A.\r\n4. For each element in A, iterate over each element in array B.\r\n5. Calculate the sum of the current pair (A[i] + B[j]).\r\n6. If the heap size is less than K, push the sum into the heap.\r\n7. If the heap size is already K and the current sum is greater than the smallest element in the heap, pop the smallest element and push the current sum into the heap.\r\n8. After iterating over all elements, the heap will contain the K maximum valid sum combinations in non-increasing order.\r\n9. Store the elements of the heap in a vector and return it as the result.\r\n\r\nCOMPLEXITY ANALYSIS:-\r\nTIME COMPLEXITY - \r\nSorting the arrays A and B takes O(N log N) time.\r\nBuilding the max heap takes O(N) time.\r\nExtracting the maximum sum K times takes O(K log N) time.\r\nOverall, the time complexity of the solution is O(N log N + K log N).",
      "code": "*/\r\n\r\nvector<int> maxCombinations(int N, int K, vector<int> &A, vector<int> &B) {\r\n    priority_queue<pair<int,pair<int,int>>> pq;\r\n    sort(A.begin(),A.end());\r\n    sort(B.begin(),B.end());\r\n    for(int i=0;i<N;i++){\r\n        pq.push({A[i]+B[N-1],{i,N-1}});\r\n    }\r\n    vector<int> ans;\r\n    while(!pq.empty() && K--)\r\n    {\r\n        auto it=pq.top();\r\n        pq.pop();\r\n        int data=it.first;\r\n        int x=it.second.first;\r\n        int y=it.second.second;\r\n        ans.push_back(data);\r\n        if(y!=0){\r\n            pq.push({A[x]+B[y-1],{x,y-1}});\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "backtracking",
        "heap",
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "priority_queue<pair<int,pair<int,int>",
        "queue<pair<int,pair<int,int>",
        "for(int i=0;i<N;i++)",
        "while(!pq.empty()",
        "sort(",
        "sort(",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\04. Maximum K sum combinations.cpp",
      "verified": false,
      "needsReview": true
    },
    "median-in-a-stream": {
      "id": "median-in-a-stream",
      "title": "Median in a stream",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\r\n\r\nImplement the MedianFinder class:\r\n\r\nMedianFinder() initializes the MedianFinder object.\r\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\r\ndouble findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.",
      "approach": "1. Use two priority queues: a max heap to store the smaller half of the numbers and a min heap to store the larger half of the numbers.\r\n2. When adding a new number:\r\n   - If the max heap is empty or the number is smaller than the top element of the max heap, push it into the max heap.\r\n   - Otherwise, push it into the min heap.\r\n   - Balance the heaps by transferring the top element of the larger heap to the smaller heap if the size difference between the heaps exceeds 1.\r\n3. When finding the median:\r\n   - If the sizes of the heaps are equal, calculate the average of the top elements of both heaps.\r\n   - Otherwise, return the top element of the heap with a larger size.\r\nComplexity Analysis:\r\n\r\nThe time complexity for adding a number to the MedianFinder is O(log N), where N is the total number of elements added so far. This is because we need to maintain the two heaps and balance them if necessary, which takes logarithmic time.\r\nThe time complexity for finding the median using the findMedian() function is O(1). This is because we directly access the top elements of the heaps, which takes constant time.\r\nThe space complexity is O(N), where N is the total number of elements added. This is because we need to store the elements in the two priority queues.",
      "code": "*/\r\n    \r\npublic:\r\n    MedianFinder() {}\r\n    \r\n    void addNum(int num) {\r\n        if (maxpq.empty() || num < maxpq.top())\r\n            maxpq.push(num);\r\n        else\r\n            minpq.push(num);\r\n        \r\n        // Balancing the heaps\r\n        int a = maxpq.size();\r\n        int b = minpq.size();\r\n        if (abs(a - b) > 1) {\r\n            if (a > b) {\r\n                int temp = maxpq.top();\r\n                maxpq.pop();\r\n                minpq.push(temp);\r\n            }\r\n            else {\r\n                int temp = minpq.top();\r\n                minpq.pop();\r\n                maxpq.push(temp);\r\n            }\r\n        }\r\n    }\r\n    \r\n    double findMedian() {\r\n        int a = maxpq.size();\r\n        int b = minpq.size();\r\n        if (a == b)\r\n            return (static_cast<double>(maxpq.top() + minpq.top()) / 2);\r\n        if (a > b)\r\n            return maxpq.top();\r\n        return minpq.top();\r\n    }\r\n};",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        ".push(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\05. Median in a stream.cpp",
      "verified": false,
      "needsReview": true
    },
    "top-k-frequent-elements": {
      "id": "top-k-frequent-elements",
      "title": "Top K frequent elements",
      "category": "heaps",
      "difficulty": "hard",
      "problemStatement": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
      "approach": "1. Create a frequency map to count the occurrences of each element in the array.\r\n2. Use a min heap to store the k most frequent elements based on their frequencies.\r\n3. Iterate through the frequency map and push elements into the min heap.\r\n4. If the size of the min heap exceeds k, remove the element with the lowest frequency.\r\n5. Finally, extract the elements from the min heap and return them in reverse order to get the k most frequent elements.",
      "code": "*/\r\n\r\nvector<int> topKFrequent(vector<int>& nums, int k) {\r\n    unordered_map<int, int> mp;\r\n    for (auto it : nums)\r\n        mp[it]++;\r\n    \r\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\r\n    for (auto it : mp) {\r\n        pq.push({ it.second, it.first });\r\n        if (pq.size() > k)\r\n            pq.pop();\r\n    }\r\n    \r\n    vector<int> ans;\r\n    while (!pq.empty()) {\r\n        ans.push_back(pq.top().second);\r\n        pq.pop();\r\n    }\r\n    \r\n    reverse(ans.begin(), ans.end());\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "heap"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "vector<int>",
        "vector<pair<int, int>",
        "priority_queue<pair<int, int>",
        "queue<pair<int, int>",
        "for (auto it : nums)",
        "for (auto it : mp)",
        "while (!pq.empty()",
        ".push_back(",
        ".push(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\09. Heaps\\3. Hard Problems\\06. Top K frequent elements.cpp",
      "verified": false,
      "needsReview": true
    },
    "assign-cookies": {
      "id": "assign-cookies",
      "title": "Assign Cookies",
      "category": "greedy",
      "difficulty": "easy",
      "problemStatement": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\r\n\r\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\r\n\r\nExample:\r\nInput: g = [1,2,3], s = [1,1]\r\nOutput: 1\r\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \r\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\r\nYou need to output 1.",
      "approach": "1. Sort the greed factor array g and the cookie size array s in ascending order.\r\n2. Initialize a counter variable child to track the number of content children.\r\n3. Iterate over the cookie size array s and check if the current cookie size is greater than or equal to the greed factor of the current child.\r\n4. If it is, increment the child counter and move to the next child.\r\n5. Finally, return the total number of content children.\r\n\r\nComplexity Analysis:\r\n- Sorting the arrays takes O(n log n) time, where n is the size of the arrays.\r\n- The iteration over the arrays takes O(n) time.\r\n- Therefore, the overall time complexity is O(n log n).\r\n\r\nCode:",
      "code": "*/\r\n\r\nint findContentChildren(vector<int>& g, vector<int>& s) {\r\n    sort(g.begin(), g.end());\r\n    sort(s.begin(), s.end());\r\n    int child = 0;\r\n    for (int i = 0; i < s.size() && child < g.size(); i++) {\r\n        if (s[i] >= g[child])\r\n            child++;\r\n    }\r\n    return child;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < s.size()",
        "sort(",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\1. Easy\\01. Assign Cookies.cpp",
      "verified": false,
      "needsReview": true
    },
    "fractional-knapsack": {
      "id": "fractional-knapsack",
      "title": "Fractional Knapsack",
      "category": "greedy",
      "difficulty": "easy",
      "problemStatement": "Given weights and values of N items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack.\r\nNote: Unlike 0/1 knapsack, you are allowed to break the item.\r\n\r\nExample:\r\nInput:\r\nN = 3, W = 50\r\nvalues[] = {60, 100, 120}\r\nweight[] = {10, 20, 30}\r\nOutput:\r\n240.00\r\nExplanation: Total maximum value of items\r\nwe can have is 240.00 from the given\r\ncapacity of the sack.",
      "approach": "1. We will define a comparator function that compares items based on their value/weight ratio in descending order.\r\n2. We will sort the items array based on the comparator function.\r\n3. Initialize a variable loot to keep track of the total value in the knapsack.\r\n4. Iterate over the items array, starting from the item with the highest value/weight ratio.\r\n5. If the weight of the current item is greater than the remaining capacity W, we take a fraction of the item to fill the remaining capacity.\r\n   The fraction is determined by the remaining capacity divided by the weight of the current item.\r\n6. Add the fraction of the item's value to the loot.\r\n7. Reduce the remaining capacity by the weight of the item.\r\n8. Repeat steps 5-7 until the remaining capacity becomes zero or all items are considered.\r\n9. Finally, return the loot, which represents the maximum total value in the knapsack.\r\n\r\nComplexity Analysis:\r\n- The sorting step takes O(n log n) time, where n is the number of items.\r\n- The iteration over the items takes O(n) time.\r\n- Therefore, the overall time complexity is O(n log n).\r\n\r\nCode:",
      "code": "*/\r\n\r\nstatic bool comp(Item a, Item b) {\r\n    return a.value / (a.weight * 1.0) > b.value / (b.weight * 1.0);\r\n}\r\n\r\ndouble fractionalKnapsack(int W, Item arr[], int n) {\r\n    sort(arr, arr + n, comp);\r\n    double loot = 0;\r\n    for (int i = 0; i < n && W; i++) {\r\n        if (arr[i].weight > W) {\r\n            loot += (W * (arr[i].value / (arr[i].weight * 1.0)));\r\n            W = 0;\r\n        } else {\r\n            loot += arr[i].value;\r\n            W -= arr[i].weight;\r\n        }\r\n    }\r\n    return loot;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "sorting"
      ],
      "fingerprint": [
        "for (int i = 0; i < n && W; i++)",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\1. Easy\\02. Fractional Knapsack.cpp",
      "verified": false,
      "needsReview": true
    },
    "lemonade-exchange": {
      "id": "lemonade-exchange",
      "title": "Lemonade Exchange",
      "category": "greedy",
      "difficulty": "easy",
      "problemStatement": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills).\r\nEach customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\r\nNote that you do not have any change in hand at first.\r\nGiven an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\r\n\r\nExample:\r\nInput: bills = [5, 5, 5, 10, 20]\r\nOutput: true\r\nExplanation:\r\nFrom the first 3 customers, we collect three $5 bills in order.\r\nFrom the fourth customer, we collect a $10 bill and give back a $5.\r\nFrom the fifth customer, we give a $10 bill and a $5 bill.\r\nSince all customers got correct change, we output true.",
      "approach": "- We maintain two counters: `fiveCnt` to count the number of $5 bills and `tenCnt` to count the number of $10 bills we have.\r\n- We iterate over the bills array.\r\n- For each bill, we check if it is $5, $10, or $20.\r\n  - If it is $5, we increment the `fiveCnt`.\r\n  - If it is $10, we increment the `tenCnt` and decrement the `fiveCnt` since we need to give back a $5 bill as change.\r\n  - If it is $20, we try to give back a $10 bill and a $5 bill as change if we have them. Otherwise, we try to give back three $5 bills.\r\n- After each transaction, we check if the `fiveCnt` is negative, which means we have given a $5 bill that we actually don't have. In this case, we return false.\r\n- If we successfully process all the bills without any negative `fiveCnt`, we return true.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the length of the bills array.\r\n- We iterate over the bills array once to process each bill.\r\n- The space complexity is O(1) as we are using only a constant amount of extra space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool lemonadeChange(vector<int>& bills) {\r\n    int fiveCnt = 0, tenCnt = 0;\r\n    for (auto bill : bills) {\r\n        if (bill == 5)\r\n            fiveCnt++;\r\n        else if (bill == 10) {\r\n            tenCnt++;\r\n            fiveCnt--;\r\n        } else {\r\n            if (tenCnt) {\r\n                tenCnt--;\r\n                fiveCnt--;\r\n            } else\r\n                fiveCnt -= 3;\r\n        }\r\n        // this means we have given $5 which we actually don't have\r\n        if (fiveCnt < 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for (auto bill : bills)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\1. Easy\\03. Lemonade Exchange.cpp",
      "verified": false,
      "needsReview": true
    },
    "valid-parenthesis-string": {
      "id": "valid-parenthesis-string",
      "title": "Valid Parenthesis String",
      "category": "greedy",
      "difficulty": "easy",
      "problemStatement": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\r\nThe following rules define a valid string:\r\n- Any left parenthesis '(' must have a corresponding right parenthesis ')'.\r\n- Any right parenthesis ')' must have a corresponding left parenthesis '('.\r\n- Left parenthesis '(' must go before the corresponding right parenthesis ')'.\r\n- '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\r\n\r\nExample:\r\nInput: s = \"(*))\"\r\nOutput: true",
      "approach": "- We maintain two counters `cmin` and `cmax` to keep track of the minimum and maximum possible number of open parentheses.\r\n- We iterate over the characters in the string.\r\n- For each character:\r\n  - If it is '(', we increment both `cmin` and `cmax`.\r\n  - If it is ')', we decrement `cmax` and update `cmin` to the maximum of `cmin - 1` and 0 (to handle cases where '*' is treated as '(').\r\n  - If it is '*', we increment `cmax` (considering '*' as '(') and update `cmin` to the maximum of `cmin - 1` and 0 (to handle cases where '*' is treated as ')').\r\n  - If `cmax` becomes negative at any point, it means even after treating all '*' as '(' we can't maintain balance, so we return false.\r\n- Finally, we check if `cmin` is 0, which means we have balanced parentheses.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the length of the string s.\r\n- We iterate over each character once.\r\n- The space complexity is O(1) as we are using only a constant amount of extra space.\r\n\r\nCode:",
      "code": "*/\r\n\r\n// NOTE- this approach is not intuitive but the most optimal however we can use recursion to solve this problem and optimize it using dp.\r\n// We can also solve this using recursion where in the case of '*' we will make 3 recursion calls,\r\n//  1-> where opencnt++,\r\n//  2-> where opencnt\r\n//  3-> where opencnt--\r\n//  The base case would be at end if opencnt == 0 return true else false.\r\n\r\nbool checkValidString(string s) {\r\n    int cmin = 0, cmax = 0;\r\n    for (auto c : s) {\r\n        if (c == '(') {\r\n            cmax++;\r\n            cmin++;\r\n        } else if (c == ')') {\r\n            cmax--;\r\n            cmin = max(cmin - 1, 0);\r\n        } else { // this is the case of '*'\r\n            cmax++; // if we treat '*' as '('\r\n            cmin = max(cmin - 1, 0); // if we treat '*' as ')'\r\n        }\r\n        if (cmax < 0) // this means even after treating all '*' as '(' we can't maintain balance\r\n            return false;\r\n    }\r\n    return (cmin == 0);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [
        "for (auto c : s)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\1. Easy\\04. Valid Parenthesis String.cpp",
      "verified": false,
      "needsReview": true
    },
    "n-meetings-in-one-room": {
      "id": "n-meetings-in-one-room",
      "title": "N Meetings in one room",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "There is one meeting room in a firm. There are N meetings in the form of (start[i], end[i]) where start[i] is the start time of meeting i and end[i] is the finish time of meeting i.\r\nWhat is the maximum number of meetings that can be accommodated in the meeting room when only one meeting can be held in the meeting room at a particular time?\r\nNote: Start time of one chosen meeting can't be equal to the end time of the other chosen meeting.\r\n\r\nExample:\r\nInput:\r\nN = 6\r\nstart[] = {1,3,0,5,8,5}\r\nend[] = {2,4,6,7,9,9}\r\nOutput: 4\r\nExplanation: Maximum four meetings can be held with the given start and end timings.\r\nThe meetings are - (1, 2), (3, 4), (5, 7), and (8, 9)",
      "approach": "- We store the meetings as pairs of (end[i], start[i]) in a vector.\r\n- We sort the vector in non-decreasing order based on the end time of meetings.\r\n- We initialize the answer as 1 and the previous meeting end time as the end time of the first meeting in the sorted vector.\r\n- We iterate over the meetings starting from the second meeting.\r\n  - If the start time of the current meeting is greater than the previous meeting end time, we increment the answer and update the previous meeting end time.\r\n- Finally, we return the answer.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(NlogN), where N is the number of meetings.\r\n- Sorting the meetings based on the end time takes O(NlogN) time.\r\n- The space complexity is O(N) as we store the meetings in a vector.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint maxMeetings(int start[], int end[], int n)\r\n{\r\n    vector<pair<int, int>> meet;\r\n    for (int i = 0; i < n; i++) {\r\n        meet.push_back({end[i], start[i]});\r\n    }\r\n    sort(meet.begin(), meet.end());\r\n    int ans = 1, prev = meet[0].first;\r\n    for (int i = 1; i < n; i++) {\r\n        if (meet[i].second > prev) {\r\n            ans++;\r\n            prev = meet[i].first;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "sorting"
      ],
      "fingerprint": [
        "vector<pair<int, int>",
        "for (int i = 0; i < n; i++)",
        "for (int i = 1; i < n; i++)",
        "sort(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\01. N Meetings in one room.cpp",
      "verified": false,
      "needsReview": true
    },
    "jump-game": {
      "id": "jump-game",
      "title": "Jump Game",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\r\nReturn true if you can reach the last index, or false otherwise.\r\n\r\nExample:\r\nInput: nums = [2,3,1,1,4]\r\nOutput: true\r\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.",
      "approach": "- We maintain a variable 'farthest' to keep track of the farthest position we can reach.\r\n- We iterate over the array from left to right.\r\n- At each position, we check if the current position is reachable from the previous farthest position.\r\n- If the current position is beyond the farthest position, it means we cannot reach the end, so we return false.\r\n- Otherwise, we update the farthest position by taking the maximum of the current farthest and the current position plus the maximum jump length at that position.\r\n- Finally, if we reach the end of the array or beyond it, we return true.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the length of the array nums.\r\n- We iterate over the array once to update the farthest position.\r\n- The space complexity is O(1) as we use only a constant amount of extra space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool canJump(vector<int>& nums) {\r\n    int farthest = 0;\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        if (farthest < i)\r\n            return false;\r\n        farthest = max(farthest, nums[i] + i);\r\n    }\r\n    return true;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\02. Jump Game.cpp",
      "verified": false,
      "needsReview": true
    },
    "jump-game-2": {
      "id": "jump-game-2",
      "title": "Jump Game 2",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\r\nEach element nums[i] represents the maximum length of a forward jump from index i.\r\nReturn the minimum number of jumps to reach nums[n - 1].\r\n\r\nExample:\r\nInput: nums = [2,3,1,1,4]\r\nOutput: 2\r\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
      "approach": "- We maintain three variables: 'steps', 'end', and 'farthest'.\r\n- 'steps' keeps track of the minimum number of jumps required.\r\n- 'end' represents the current farthest position that we can reach.\r\n- 'farthest' stores the farthest position we can reach by taking a jump from the current position.\r\n- We iterate over the array from left to right, except for the last element.\r\n- At each position, we update the 'farthest' by taking the maximum of the current farthest and the current position plus the maximum jump length at that position.\r\n- If the 'farthest' position is greater than or equal to the last index, it means we can reach the end, so we return 'steps + 1'.\r\n- When we reach the 'end' position, it means we have taken the maximum number of jumps from the previous step.\r\n- So, we increment 'steps' by 1 and update the 'end' to the 'farthest' position.\r\n- Finally, we return the 'steps' as the minimum number of jumps required.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the length of the input array 'nums'.\r\n- We iterate over the array once.\r\n- The space complexity is O(1) as we use only a constant amount of extra space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint jump(vector<int>& nums) {\r\n    int steps = 0, end = 0, farthest = 0;\r\n    for (int i = 0; i < nums.size() - 1; i++) {\r\n        farthest = max(farthest, nums[i] + i);\r\n        if (farthest >= nums.size() - 1)\r\n            return steps + 1;\r\n        if (i == end) {\r\n            steps++;\r\n            end = farthest;\r\n        }\r\n    }\r\n    return steps;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = 0; i < nums.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\03. Jump Game 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-platforms": {
      "id": "minimum-platforms",
      "title": "Minimum Platforms",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "Given arrival and departure times of all trains that reach a railway station, find the minimum number of platforms required for the railway station so that no train is kept waiting.\r\nConsider that all the trains arrive on the same day and leave on the same day. Arrival and departure time can never be the same for a train, but we can have the arrival time of one train equal to the departure time of another. At any given instance of time, the same platform cannot be used for both the departure of a train and the arrival of another train. In such cases, we need different platforms.\r\n\r\nExample:\r\nInput: n = 6\r\narr[] = {0900, 0940, 0950, 1100, 1500, 1800}\r\ndep[] = {0910, 1200, 1120, 1130, 1900, 2000}\r\nOutput: 3\r\nExplanation:\r\nMinimum 3 platforms are required to safely arrive and depart all trains.",
      "approach": "- We sort the arrival and departure arrays in non-decreasing order.\r\n- We initialize variables 'i', 'j', 'plat', and 'ans' to 0.\r\n- We iterate over the arrival array using 'i' and departure array using 'j'.\r\n- If the arrival time at index 'i' is less than or equal to the departure time at index 'j', it means a train is arriving and we need an additional platform.\r\n  - So, we increment 'i' and 'plat'.\r\n  - We update 'ans' with the maximum value of 'ans' and 'plat'.\r\n- If the arrival time is greater than the departure time, it means a train has departed and we can free up a platform.\r\n  - So, we increment 'j' and decrement 'plat'.\r\n- Finally, we return 'ans' as the minimum number of platforms required.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(NlogN), where N is the number of trains.\r\n- We sort the arrival and departure arrays, which takes O(NlogN) time.\r\n- The space complexity is O(1) as we use only a constant amount of extra space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint findPlatform(int arr[], int dep[], int n)\r\n{\r\n    sort(arr, arr + n);\r\n    sort(dep, dep + n);\r\n    int i = 0, j = 0, plat = 0, ans = 0;\r\n    while (i < n) {\r\n        if (arr[i] <= dep[j]) {\r\n            i++;\r\n            plat++;\r\n            ans = max(ans, plat);\r\n        }\r\n        else {\r\n            j++;\r\n            plat--;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while (i < n)",
        "sort(",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\04. Minimum Platforms.cpp",
      "verified": false,
      "needsReview": true
    },
    "job-sequencing-problem": {
      "id": "job-sequencing-problem",
      "title": "Job Sequencing Problem",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "Given a set of N jobs where each job 'i' has a deadline and profit associated with it. Each job takes 1 unit of time to complete, and only one job can be scheduled at a time. We earn the profit associated with a job if and only if the job is completed by its deadline. Find the number of jobs done and the maximum profit.\r\n\r\nExample:\r\nInput:\r\nN = 4\r\nJobs = {(1,4,20),(2,1,10),(3,1,40),(4,1,30)}\r\nOutput:\r\n2 60\r\nExplanation:\r\nJob1 and Job3 can be done with a maximum profit of 60 (20+40).",
      "approach": "- We create a vector of pairs 'jobs' to store the profit and deadline of each job.\r\n- We sort the 'jobs' vector in non-increasing order of profits.\r\n- We initialize a vector 'deadline' of size 'n+1' and set all elements to -1.\r\n- We also initialize variables 'ans' and 'cnt' to 0.\r\n- We iterate over the 'jobs' vector.\r\n  - For each job, we get the deadline and profit.\r\n  - We check from the deadline to 1 (in reverse order) if there is any slot available to schedule the job.\r\n  - If we find an available slot, we mark it as scheduled by setting 'deadline[dead]' to 1, increment 'cnt' and add the profit to 'ans'.\r\n- Finally, we return a vector containing 'cnt' and 'ans' as the number of jobs done and the maximum profit.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(NlogN), where N is the number of jobs.\r\n- This is due to the sorting operation on the 'jobs' vector based on profits.\r\n- The space complexity is O(N) as we use additional vectors to store the jobs and deadlines.\r\n\r\nCode:",
      "code": "*/\r\n\r\nstatic bool comp(pair<int,int> a, pair<int,int> b) {\r\n    return a.first > b.first;\r\n}\r\n\r\nvector<int> JobScheduling(Job arr[], int n) {\r\n    vector<pair<int,int>> jobs;\r\n    for(int i = 0; i < n; i++) {\r\n        jobs.push_back({arr[i].profit, arr[i].dead});\r\n    }\r\n    sort(jobs.begin(), jobs.end(), comp);\r\n    vector<int> deadline(n+1, -1);\r\n    int ans = 0, cnt = 0;\r\n    for(int i = 0; i < n; i++) {\r\n        int dead = jobs[i].second;\r\n        int profit = jobs[i].first;\r\n        while(dead >= 1 && deadline[dead] != -1) {\r\n            dead--;\r\n        }\r\n        if(dead >= 1) {\r\n            deadline[dead] = 1;\r\n            cnt++;\r\n            ans += profit;\r\n        }\r\n    }\r\n    return {cnt, ans};\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<pair<int,int>",
        "vector<int>",
        "for(int i = 0; i < n; i++)",
        "for(int i = 0; i < n; i++)",
        "while(dead >= 1 && deadline[dead] != -1)",
        "sort(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\05. Job Sequencing Problem.cpp",
      "verified": false,
      "needsReview": true
    },
    "candy": {
      "id": "candy",
      "title": "Candy",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\r\nYou are giving candies to these children subjected to the following requirements:\r\n- Each child must have at least one candy.\r\n- Children with a higher rating get more candies than their neighbors.\r\nReturn the minimum number of candies you need to have to distribute the candies to the children.\r\n\r\nExample:\r\nInput: ratings = [1,0,2]\r\nOutput: 5\r\nExplanation: You can allocate to the first, second, and third child with 2, 1, 2 candies respectively.",
      "approach": "- We start by assigning 1 candy to each child as the minimum requirement.\r\n- Then, we iterate from left to right and check if the current child has a higher rating than the previous child.\r\n- If yes, we increment the number of candies for the current child by 1 compared to the previous child.\r\n- Next, we iterate from right to left and check if the current child has a higher rating than the next child.\r\n- If yes, we take the maximum of the current child's candies and the next child's candies plus 1.\r\n- Finally, we sum up all the candies assigned to get the minimum number of candies required.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the number of children.\r\n- We iterate over the ratings twice to assign the candies.\r\n- The space complexity is O(N) as we use an additional vector to store the number of candies assigned to each child.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint candy(vector<int>& ratings) {\r\n    int n = ratings.size();\r\n    if(n == 1) return 1;\r\n    vector<int> num(n, 1);\r\n    for(int i = 1; i < n; i++) {\r\n        if(ratings[i] > ratings[i-1]) {\r\n            num[i] = num[i-1] + 1;\r\n        }\r\n    }\r\n    for(int i = n-2; i >= 0; i--) {\r\n        if(ratings[i] > ratings[i+1]) {\r\n            num[i] = max(num[i], num[i+1] + 1);\r\n        }\r\n    }\r\n    int sum = 0;\r\n    for(auto it : num) {\r\n        sum += it;\r\n    }\r\n    return sum;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(int i = 1; i < n; i++)",
        "for(int i = n-2; i >= 0; i--)",
        "for(auto it : num)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\06. Candy.cpp",
      "verified": false,
      "needsReview": true
    },
    "insert-interval": {
      "id": "insert-interval",
      "title": "Insert Interval",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\r\n\r\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\r\n\r\nReturn intervals after the insertion.\r\n\r\nExample:\r\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\r\nOutput: [[1,2],[3,10],[12,16]]\r\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].",
      "approach": "- We iterate through the intervals and compare them with the newInterval.\r\n- There are three possible cases:\r\n  1. The newInterval is before the current interval: We add the newInterval and update the newInterval to the current interval.\r\n  2. The newInterval is after the current interval: We add the current interval to the result.\r\n  3. The newInterval overlaps with the current interval: We update the newInterval to cover the merged interval.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(N), where N is the number of intervals.\r\n- We iterate through the intervals once.\r\n- The space complexity is O(1) as we are using a constant amount of additional space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\r\n    vector<vector<int>> ans;\r\n    int n = intervals.size();\r\n\r\n    for(int i = 0; i < n; i++) {\r\n        // newInterval is after the current interval\r\n        if(intervals[i][1] < newInterval[0]) {\r\n            ans.push_back(intervals[i]);\r\n        }\r\n        // newInterval is before the current interval\r\n        else if(newInterval[1] < intervals[i][0]) {\r\n            ans.push_back(newInterval);\r\n            newInterval = intervals[i];\r\n        }\r\n        // newInterval overlaps with the current interval\r\n        else {\r\n            newInterval[0] = min(intervals[i][0], newInterval[0]);\r\n            newInterval[1] = max(intervals[i][1], newInterval[1]);\r\n        }\r\n    }\r\n    ans.push_back(newInterval);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i = 0; i < n; i++)",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\07. Insert Interval.cpp",
      "verified": false,
      "needsReview": true
    },
    "non-overlapping-intervals": {
      "id": "non-overlapping-intervals",
      "title": "Non Overlapping Intervals",
      "category": "greedy",
      "difficulty": "medium",
      "problemStatement": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n\r\nExample:\r\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\r\nOutput: 1\r\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.",
      "approach": "- We sort the intervals based on the end time in ascending order.\r\n- We initialize a count variable to keep track of the number of intervals that need to be removed.\r\n- We initialize the end variable to store the end time of the first interval.\r\n- Then, we iterate through the intervals starting from the second interval.\r\n- If the start time of the current interval is less than the end time of the previous interval, it means there is an overlap.\r\n- In that case, we increment the count variable since we need to remove this interval to make the rest non-overlapping.\r\n- Otherwise, if there is no overlap, we update the end variable to the end time of the current interval.\r\n- Finally, we return the count variable, which represents the minimum number of intervals to remove.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(NlogN), where N is the number of intervals.\r\n- Sorting the intervals takes O(NlogN) time, and iterating through the intervals takes O(N) time.\r\n- The space complexity is O(1) as we are not using any additional data structures.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool comp(vector<int>& a, vector<int>& b) {\r\n    return a[1] < b[1];\r\n}\r\n\r\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\r\n    if(intervals.size() < 2) return 0;\r\n    sort(intervals.begin(), intervals.end(), comp);\r\n    int cnt = 0, end = intervals[0][1];\r\n    for(int i = 1; i < intervals.size(); i++) {\r\n        if(intervals[i][0] < end) {\r\n            cnt++;\r\n        }\r\n        else {\r\n            end = intervals[i][1];\r\n        }\r\n    }\r\n    return cnt;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<vector<int>",
        "for(int i = 1; i < intervals.size()",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\10. Greedy Approach\\2. Medium\\08. Non Overlapping Intervals.cpp",
      "verified": false,
      "needsReview": true
    },
    "introduction-to-trees": {
      "id": "introduction-to-trees",
      "title": "Introduction to trees",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given an integer 'N', determine the maximum number of nodes present on 'Nth' level in a binary tree.",
      "approach": "- The number of nodes on each level of a binary tree follows a pattern.\r\n- The number of nodes on the Nth level is equal to 2^(N-1).\r\n- We can use the pow function from the cmath library to calculate the power of 2.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this approach is O(1) as we are using a simple mathematical formula.\r\n- The space complexity is also O(1) as we are not using any additional space.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint numberOfNodes(int N) {\r\n    if(N <= 1) {\r\n        return 1;\r\n    }\r\n    return pow(2, N - 1);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\01. Introduction to trees.cpp",
      "verified": false,
      "needsReview": true
    },
    "binary-tree-representation": {
      "id": "binary-tree-representation",
      "title": "Binary Tree representation",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "You are given an array nodes. It contains 7 integers, which represents the value of nodes of the binary tree in level order traversal. You are also given a root of the tree which has a value equal to nodes[0].\r\nYour task to construct a binary tree by creating nodes for the remaining 6 nodes.",
      "approach": "- We can solve this problem recursively by performing a level-order traversal of the tree.\r\n- Starting from the root node, we can recursively create the left and right child nodes using the given array of values.\r\n- The position of each child node in the array can be calculated based on the index of its parent node.\r\n\r\nComplexity Analysis:\r\n- Since we are visiting each node once, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we are using the call stack for recursion.\r\n\r\nCode:",
      "code": "*/\r\n\r\nstruct node {\r\n    int data;\r\n    node* left;\r\n    node* right;\r\n};\r\n\r\nnode* newNode(int data) {\r\n    node* newNode = new node();\r\n    newNode->data = data;\r\n    newNode->left = NULL;\r\n    newNode->right = NULL;\r\n    return newNode;\r\n}\r\n\r\nnode* solve(vector<int>& vec, int i) {\r\n    if(i >= 7) {\r\n        return NULL;\r\n    }\r\n    \r\n    node* root = newNode(vec[i]);\r\n    i = 2 * i;\r\n    root->left = solve(vec, i + 1);\r\n    root->right = solve(vec, i + 2);\r\n    \r\n    return root;\r\n}\r\n\r\nvoid create_tree(node*& root0, vector<int>& vec) {\r\n    root0 = solve(vec, 0);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion",
        "bfs"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\02. Binary Tree representation.cpp",
      "verified": false,
      "needsReview": true
    },
    "preorder-traversal": {
      "id": "preorder-traversal",
      "title": "Preorder Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the preorder traversal of its nodes' values.",
      "approach": "- Preorder traversal visits the root node first, followed by the left subtree, and then the right subtree.\r\n- We can solve this problem recursively by following the preorder traversal order.\r\n- Starting from the root node, we can add the node's value to the result vector, then recursively traverse the left subtree and right subtree.\r\n\r\nComplexity Analysis:\r\n- Since we are visiting each node once, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we are using the call stack for recursion.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> preorderTraversal(TreeNode* root) {\r\n    vector<int> ans;\r\n    solve(root, ans);\r\n    return ans;\r\n}\r\n\r\nvoid solve(TreeNode* root, vector<int>& ans) {\r\n    if (!root) {\r\n        return;\r\n    }\r\n    ans.push_back(root->val);\r\n    solve(root->left, ans);\r\n    solve(root->right, ans);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\03. Preorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "inorder-traversal": {
      "id": "inorder-traversal",
      "title": "Inorder Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
      "approach": "- inorder traversal visits the left subtree first, followed by the root node, and then the right subtree.\r\n- We can solve this problem recursively by following the inorder traversal order.\r\n\r\nComplexity Analysis:\r\n- Since we are visiting each node once, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we are using the call stack for recursion.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> inorderTraversal(TreeNode* root) {\r\n    vector<int> ans;\r\n    solve(root, ans);\r\n    return ans;\r\n}\r\n\r\nvoid solve(TreeNode* root, vector<int>& ans) {\r\n    if (!root) {\r\n        return;\r\n    }\r\n    solve(root->left, ans);\r\n    ans.push_back(root->val);\r\n    solve(root->right, ans);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\04. Inorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "postorder-traversal": {
      "id": "postorder-traversal",
      "title": "Postorder Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the postorder traversal of its nodes' values.",
      "approach": "- postorder traversal visits the left subtree first, followed by the right subtree, and then the root node.\r\n- We can solve this problem recursively by following the postorder traversal order.\r\n\r\nComplexity Analysis:\r\n- Since we are visiting each node once, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we are using the call stack for recursion.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> postorderTraversal(TreeNode* root) {\r\n    vector<int> ans;\r\n    solve(root, ans);\r\n    return ans;\r\n}\r\n\r\nvoid solve(TreeNode* root, vector<int>& ans) {\r\n    if (!root) {\r\n        return;\r\n    }\r\n    solve(root->left, ans);\r\n    ans.push_back(root->val);\r\n    solve(root->right, ans);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\05. Postorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "level-order-traversal": {
      "id": "level-order-traversal",
      "title": "Level Order Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "approach": "- We can perform a level order traversal using a queue.\r\n- We start by pushing the root node into the queue.\r\n- Then, while the queue is not empty, we process each level by taking the size of the queue and iterating over the nodes at that level.\r\n- For each node, we add its value to the current level's vector and push its left and right child nodes into the queue if they exist.\r\n- After processing each level, we add the level's vector to the result vector.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we store the node values in the result vector.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<vector<int>> levelOrder(TreeNode* root) {\r\n    vector<vector<int>> ans;\r\n    if (!root) {\r\n        return ans;\r\n    }\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    while (!q.empty()) {\r\n        vector<int> level;\r\n        int n = q.size();\r\n        for (int i = 0; i < n; i++) {\r\n            TreeNode* curr = q.front();\r\n            q.pop();\r\n            level.push_back(curr->val);\r\n            if (curr->left) {\r\n                q.push(curr->left);\r\n            }\r\n            if (curr->right) {\r\n                q.push(curr->right);\r\n            }\r\n        }\r\n        ans.push_back(level);\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "bfs"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "queue<TreeNode*>",
        "for (int i = 0; i < n; i++)",
        "while (!q.empty()",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\06. Level Order Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "iterative-preorder-traversal": {
      "id": "iterative-preorder-traversal",
      "title": "Iterative Preorder Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the preorder traversal of its nodes' values.",
      "approach": "- We can perform a preorder traversal iteratively using a stack.\r\n- We start by pushing the root node into the stack.\r\n- Then, while the stack is not empty, we pop a node from the stack, add its value to the result vector, and push its right child (if it exists) followed by its left child (if it exists) into the stack.\r\n- By pushing the right child before the left child, we ensure that the left child is processed first during the traversal.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we store the node values in the result vector.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> preorderTraversal(TreeNode* root) {\r\n    if (!root) {\r\n        return {};\r\n    }\r\n    stack<TreeNode*> st;\r\n    st.push(root);\r\n    vector<int> ans;\r\n    while (!st.empty()) {\r\n        TreeNode* curr = st.top();\r\n        st.pop();\r\n        ans.push_back(curr->val);\r\n        if (curr->right) {\r\n            st.push(curr->right);\r\n        }\r\n        if (curr->left) {\r\n            st.push(curr->left);\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "stack<TreeNode*>",
        "while (!st.empty()",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\07. Iterative Preorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "iterative-inorder-traversal": {
      "id": "iterative-inorder-traversal",
      "title": "Iterative Inorder Traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
      "approach": "- We can perform an inorder traversal iteratively using a stack.\r\n- The idea is to push all the left children of a node into the stack until we reach a node with no left child.\r\n- Then, we pop a node from the stack, add its value to the result vector, and move to its right child (if it exists).\r\n- We repeat this process until the stack is empty and all nodes are traversed.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we store the node values in the result vector and use a stack to keep track of the nodes.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid pushLeft(TreeNode* curr, stack<TreeNode*>& st) {\r\n    while (curr) {\r\n        st.push(curr);\r\n        curr = curr->left;\r\n    }\r\n}\r\n\r\nvector<int> inorderTraversal(TreeNode* root) {\r\n    if (!root) {\r\n        return {};\r\n    }\r\n    stack<TreeNode*> st;\r\n    TreeNode* curr = root;\r\n    pushLeft(curr, st);\r\n    vector<int> ans;\r\n    while (!st.empty()) {\r\n        curr = st.top();\r\n        st.pop();\r\n        ans.push_back(curr->val);\r\n        curr = curr->right;\r\n        if (curr) {\r\n            pushLeft(curr, st);\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "stack<TreeNode*>",
        "stack<TreeNode*>",
        "while (curr)",
        "while (!st.empty()",
        ".push_back(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\08. Iterative Inorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "iterative-postorder": {
      "id": "iterative-postorder",
      "title": "Iterative Postorder",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, return the postorder traversal of its nodes' values.",
      "approach": "- We can perform a postorder traversal iteratively using a stack and a map.\r\n- The idea is to push all the left children of a node into the stack until we reach a node with no left child.\r\n- Then, we check if the right child of the node exists or has already been visited (using the map).\r\n    - If it does not exist or has been visited, we add the node's value to the result vector and pop the node from the stack.\r\n    - Otherwise, we push the right child into the stack and mark it as visited in the map.\r\n- We repeat this process until the stack is empty and all nodes are traversed.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is also O(N) as we store the node values in the result vector and use a stack and a map to keep track of the nodes.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid pushLeft(TreeNode* curr, stack<TreeNode*>& st, unordered_map<TreeNode*, bool>& mp) {\r\n    while (curr) {\r\n        mp[curr] = true;\r\n        st.push(curr);\r\n        curr = curr->left;\r\n    }\r\n}\r\n\r\nvector<int> postorderTraversal(TreeNode* root) {\r\n    if (!root) {\r\n        return {};\r\n    }\r\n    vector<int> ans;\r\n    stack<TreeNode*> st;\r\n    TreeNode* curr = root;\r\n    unordered_map<TreeNode*, bool> mp;\r\n    pushLeft(curr, st, mp);\r\n    while (!st.empty()) {\r\n        curr = st.top();\r\n        if (!curr->right || mp[curr->right]) {\r\n            ans.push_back(curr->val);\r\n            st.pop();\r\n        }\r\n        else {\r\n            pushLeft(curr->right, st, mp);\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers"
      ],
      "fingerprint": [
        "unordered_map<TreeNode*, bool>",
        "unordered_map<TreeNode*, bool>",
        "vector<int>",
        "vector<int>",
        "stack<TreeNode*>",
        "stack<TreeNode*>",
        "while (curr)",
        "while (!st.empty()",
        ".push_back(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\09. Iterative Postorder.cpp",
      "verified": false,
      "needsReview": true
    },
    "all-in-one-traversal": {
      "id": "all-in-one-traversal",
      "title": "All in one traversal",
      "category": "binary-trees",
      "difficulty": "unknown",
      "problemStatement": "You have been given a Binary Tree of 'N' nodes, where the nodes have integer values.\r\nYour task is to find the In-Order, Pre-Order, and Post-Order traversals of the given binary tree.",
      "approach": "- We can perform the tree traversals recursively using three functions:\r\n    - In-Order Traversal: Visit the left subtree, visit the current node, visit the right subtree.\r\n    - Pre-Order Traversal: Visit the current node, visit the left subtree, visit the right subtree.\r\n    - Post-Order Traversal: Visit the left subtree, visit the right subtree, visit the current node.\r\n- For each traversal, we can maintain a vector to store the values of the visited nodes in the respective order.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N) as we store the values of the nodes in vectors for each traversal.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid traversal(BinaryTreeNode<int>* root, vector<int>& pre, vector<int>& ino, vector<int>& pos) {\r\n    if (root == NULL) {\r\n        return;\r\n    }\r\n\r\n    // Pre-Order Traversal\r\n    pre.push_back(root->data);\r\n    traversal(root->left, pre, ino, pos);\r\n    // In-Order Traversal\r\n    ino.push_back(root->data);\r\n    traversal(root->right, pre, ino, pos);\r\n    // Post-Order Traversal\r\n    pos.push_back(root->data);\r\n}\r\n\r\nvector<vector<int>> getTreeTraversal(BinaryTreeNode<int>* root) {\r\n    vector<vector<int>> ans;\r\n    vector<int> pre;\r\n    vector<int> ino;\r\n    vector<int> pos;\r\n\r\n    traversal(root, pre, ino, pos);\r\n\r\n    ans.push_back(ino);\r\n    ans.push_back(pre);\r\n    ans.push_back(pos);\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\1. Traversals\\10. All in one traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "height-of-binary-tree": {
      "id": "height-of-binary-tree",
      "title": "Height of binary tree",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, return its maximum depth.\r\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "approach": "- We can calculate the maximum depth of a binary tree recursively by traversing its left and right subtrees.\r\n- The maximum depth of a tree is equal to the maximum of the maximum depths of its left and right subtrees, plus 1 for the root node.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the tree can be skewed and have a height of N, resulting in O(N) space complexity. In the best case, the tree is balanced and has a height of log(N), resulting in O(log(N)) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint maxDepth(TreeNode* root) {\r\n    if (!root) {\r\n        return 0;\r\n    }\r\n    return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\01. Height of binary tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "balanced-binary-tree": {
      "id": "balanced-binary-tree",
      "title": "Balanced Binary Tree",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given a binary tree, determine if it is height-balanced.",
      "approach": "- We can solve this problem recursively by checking if the left and right subtrees of each node are height-balanced.\r\n- For each node, we calculate the height of its left and right subtrees, and check if the absolute difference of their heights is at most 1.\r\n- If both subtrees are height-balanced, and the absolute difference of their heights is at most 1, then the current node and its subtree are height-balanced.\r\n- We can use a pair of values to represent the result of the recursion: the first value indicates if the subtree is height-balanced, and the second value represents the height of the subtree.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the tree can be skewed and have a height of N, resulting in O(N) space complexity. In the best case, the tree is balanced and has a height of log(N), resulting in O(log(N)) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\npair<bool, int> solve(TreeNode* root) {\r\n    if (!root) {\r\n        return {true, 0};\r\n    }\r\n    auto left = solve(root->left);\r\n    auto right = solve(root->right);\r\n    int height = max(left.second, right.second) + 1;\r\n    bool balanced = left.first && right.first && abs(left.second - right.second) <= 1;\r\n    return {balanced, height};\r\n}\r\n\r\nbool isBalanced(TreeNode* root) {\r\n    auto result = solve(root);\r\n    return result.first;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\02. Balanced Binary Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "diameter-of-binary-tree": {
      "id": "diameter-of-binary-tree",
      "title": "Diameter of Binary Tree",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, return the length of the diameter of the tree.",
      "approach": "- The diameter of a binary tree is the length of the longest path between any two nodes in the tree.\r\n- This path may or may not pass through the root.\r\n- To find the diameter of the tree, we can recursively calculate the height of each node's left and right subtrees.\r\n- At each node, we calculate the diameter as the maximum of the following three values:\r\n  - The diameter of the left subtree.\r\n  - The diameter of the right subtree.\r\n  - The sum of the heights of the left and right subtrees plus one (for the current node).\r\n- We update the diameter variable with the maximum diameter encountered during the traversal.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the tree can be skewed and have a height of N, resulting in O(N) space complexity. In the best case, the tree is balanced and has a height of log(N), resulting in O(log(N)) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint maxDepth(TreeNode* root, int& diameter) {\r\n    if (!root) {\r\n        return 0;\r\n    }\r\n    int left = maxDepth(root->left, diameter);\r\n    int right = maxDepth(root->right, diameter);\r\n    diameter = max(diameter, left + right);\r\n    return max(left, right) + 1;\r\n}\r\n\r\nint diameterOfBinaryTree(TreeNode* root) {\r\n    int diameter = 0;\r\n    maxDepth(root, diameter);\r\n    return diameter;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\03. Diameter of Binary Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximum-path-sum": {
      "id": "maximum-path-sum",
      "title": "Maximum Path Sum",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.\r\nA node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\r\nThe path sum of a path is the sum of the node's values in the path.\r\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
      "approach": "- The maximum path sum can be calculated using a recursive approach.\r\n- For each node, we calculate the maximum path sum that includes the node as the root.\r\n- The maximum path sum that includes the current node is the maximum of the following values:\r\n  - The value of the current node.\r\n  - The maximum path sum of the left subtree plus the value of the current node.\r\n  - The maximum path sum of the right subtree plus the value of the current node.\r\n  - The maximum path sum of the left subtree plus the maximum path sum of the right subtree plus the value of the current node.\r\n- During the calculation, we keep track of the maximum path sum encountered so far and update it if necessary.\r\n- We return the maximum path sum encountered overall.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the tree can be skewed and have a height of N, resulting in O(N) space complexity. In the best case, the tree is balanced and has a height of log(N), resulting in O(log(N)) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint solve(TreeNode* root, int& maxSum) {\r\n    if (!root) {\r\n        return 0;\r\n    }\r\n    int leftSum = max(0, solve(root->left, maxSum));\r\n    int rightSum = max(0, solve(root->right, maxSum));\r\n    int currentSum = root->val + leftSum + rightSum;\r\n    maxSum = max(maxSum, currentSum);\r\n    return root->val + max(leftSum, rightSum);\r\n}\r\n\r\nint maxPathSum(TreeNode* root) {\r\n    int maxSum = INT_MIN;\r\n    solve(root, maxSum);\r\n    return maxSum;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\04. Maximum Path Sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "same-tree": {
      "id": "same-tree",
      "title": "Same Tree",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
      "approach": "- The trees are considered the same if they have the same structure (i.e., same nodes in the same arrangement) and the corresponding nodes have the same values.\r\n- We can use a recursive approach to check if the trees are the same.\r\n- The trees are the same if both trees are empty (reached the end of the tree) or both trees are non-empty and the current nodes have the same value, and the left subtrees and right subtrees are the same.\r\n- We can check if the trees are the same by comparing the values of the current nodes and recursively checking the left subtrees and right subtrees.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the tree can be skewed and have a height of N, resulting in O(N) space complexity. In the best case, the tree is balanced and has a height of log(N), resulting in O(log(N)) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nbool isSameTree(TreeNode* p, TreeNode* q) {\r\n    if (!p && !q) {\r\n        return true; // Both trees are empty, they are the same\r\n    }\r\n    if (!p || !q) {\r\n        return false; // One tree is empty and the other is not, they are different\r\n    }\r\n    return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\05. Same Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "zig-zag-traversal": {
      "id": "zig-zag-traversal",
      "title": "Zig-Zag Traversal",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
      "approach": "- We can use a queue to perform a level order traversal of the binary tree.\r\n- To achieve the zigzag order, we can use a flag variable to keep track of the current direction (left to right or right to left) for each level.\r\n- Initialize a boolean variable `ltor` to true, where true represents the left to right direction.\r\n- While traversing each level, we store the values of the nodes in a temporary vector.\r\n- If `ltor` is true, we push the left child first and then the right child into the queue for the next level.\r\n- If `ltor` is false, we push the right child first and then the left child into the queue for the next level.\r\n- After processing all the nodes in the current level, if `ltor` is false, we reverse the temporary vector to achieve the right to left direction for the next level.\r\n- We alternate the value of `ltor` after processing each level to switch between left to right and right to left directions.\r\n- Finally, we return the vector containing the zigzag level order traversal.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(M), where M is the maximum number of nodes at any level in the binary tree. In the worst case, the maximum number of nodes at any level can be N/2 (in a complete binary tree), resulting in O(N) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\r\n    if (!root) return {}; // Empty tree, return an empty vector\r\n\r\n    vector<vector<int>> ans; // Vector to store the zigzag level order traversal\r\n    queue<TreeNode*> q; // Queue for level order traversal\r\n    q.push(root);\r\n    bool ltor = true; // Flag variable to track the current direction (left to right or right to left)\r\n\r\n    while (!q.empty()) {\r\n        int n = q.size(); // Number of nodes at the current level\r\n        vector<int> levelValues; // Temporary vector to store the values of nodes at the current level\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            TreeNode* curr = q.front();\r\n            q.pop();\r\n\r\n            levelValues.push_back(curr->val);\r\n\r\n            if (curr->left) q.push(curr->left);\r\n            if (curr->right) q.push(curr->right);\r\n        }\r\n\r\n        if (!ltor) {\r\n            reverse(levelValues.begin(), levelValues.end()); // Reverse the values to achieve right to left direction\r\n        }\r\n\r\n        ans.push_back(levelValues);\r\n\r\n        ltor = !ltor; // Alternate the direction for the next level\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "bfs"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "queue<TreeNode*>",
        "for (int i = 0; i < n; i++)",
        "while (!q.empty()",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\06. Zig-Zag Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "boundary-traversal": {
      "id": "boundary-traversal",
      "title": "Boundary Traversal",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given a Binary Tree, find its Boundary Traversal. The traversal should be in the following order:\r\n\r\nLeft boundary nodes: defined as the path from the root to the left-most node, i.e., the leaf node you could reach when you always travel preferring the left subtree over the right subtree.\r\nLeaf nodes: All the leaf nodes except for the ones that are part of the left or right boundary.\r\nReverse right boundary nodes: defined as the path from the right-most node to the root. The right-most node is the leaf node you could reach when you always travel preferring the right subtree over the left subtree. Exclude the root from this as it was already included in the traversal of left boundary nodes.\r\nNote: If the root doesn't have a left subtree or right subtree, then the root itself is the left or right boundary.",
      "approach": "- We can divide the boundary traversal into three parts: left boundary nodes, leaf nodes, and reverse right boundary nodes.\r\n- To find the left boundary nodes, we can traverse the left subtree from the root to the leftmost leaf node. We add the values of the nodes to the answer vector during this traversal.\r\n- To find the leaf nodes, we can perform a separate recursive traversal of the binary tree and add the values of the leaf nodes (excluding the ones already included in the left boundary or right boundary) to the answer vector.\r\n- To find the reverse right boundary nodes, we can traverse the right subtree from the root to the rightmost leaf node (excluding the root). We add the values of the nodes to the answer vector during this traversal.\r\n- Finally, we return the answer vector containing the boundary traversal.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(H), where H is the height of the binary tree. In the worst case, the height of the binary tree can be N, resulting in O(N) space complexity.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvoid leftTraversal(TreeNode<int>* root, vector<int>& ans) {\r\n    if (!root) return;\r\n    if (!root->left && !root->right) return;\r\n\r\n    ans.push_back(root->val);\r\n\r\n    if (root->left)\r\n        leftTraversal(root->left, ans);\r\n    else\r\n        leftTraversal(root->right, ans);\r\n}\r\n\r\nvoid leafTraversal(TreeNode<int>* root, vector<int>& ans) {\r\n    if (!root) return;\r\n    if (!root->left && !root->right) {\r\n        ans.push_back(root->val);\r\n    }\r\n    leafTraversal(root->left, ans);\r\n    leafTraversal(root->right, ans);\r\n}\r\n\r\nvoid rightTraversal(TreeNode<int>* root, vector<int>& ans) {\r\n    if (!root) return;\r\n    if (!root->left && !root->right) return;\r\n\r\n    int temp = root->val;\r\n\r\n    if (root->right)\r\n        rightTraversal(root->right, ans);\r\n    else\r\n        rightTraversal(root->left, ans);\r\n\r\n    ans.push_back(temp);\r\n}\r\n\r\nvector<int> boundaryTraversal(TreeNode<int>* root) {\r\n    if (!root) return {};\r\n    vector<int> ans;\r\n\r\n    ans.push_back(root->val);\r\n    leftTraversal(root->left, ans);\r\n    leafTraversal(root->left, ans);\r\n    leafTraversal(root->right, ans);\r\n    rightTraversal(root->right, ans);\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\07. Boundary Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "vertical-order-traversal": {
      "id": "vertical-order-traversal",
      "title": "Vertical Order Traversal",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, calculate the vertical order traversal of the binary tree.\r\nThere may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.",
      "approach": "- We can perform a level order traversal of the binary tree while keeping track of the horizontal distance (hd) of each node from the root.\r\n- For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively.\r\n- We can use a queue to perform the level order traversal. The queue will store pairs of (hd, node), where hd represents the horizontal distance and node represents the current node being processed.\r\n- During the traversal, we maintain an unordered_map to store the nodes at each horizontal distance. The key in the map is the horizontal distance (hd), and the value is a vector of pairs representing the level and value of the nodes at that horizontal distance.\r\n- After the traversal, we iterate over the keys in the map in ascending order and sort the nodes within each horizontal distance based on their levels. We then extract the values and add them to the result vector.\r\n- Finally, we return the result vector containing the vertical order traversal.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N), where N is the number of nodes in the binary tree. This space is used to store the nodes in the unordered_map during the traversal.\r\n\r\nCode:",
      "code": "*/\r\n\r\n// NOTE:- we are keeping track of levels because of the question condition but if no such condition exists, then no need of level only hd will work.\r\n\r\nvector<vector<int>> verticalTraversal(TreeNode* root) {\r\n    if (!root) return {};\r\n\r\n    unordered_map<int, vector<pair<int, int>>> mp;\r\n    int mini = 0, maxi = 0;\r\n    queue<pair<int, TreeNode*>> q;\r\n    q.push({0, root});\r\n\r\n    int lvl = 0;\r\n    while (!q.empty()) {\r\n        int n = q.size();\r\n        for (int i = 0; i < n; i++) {\r\n            auto p = q.front();\r\n            q.pop();\r\n            TreeNode* curr = p.second;\r\n            int hd = p.first;\r\n            if (curr->left) {\r\n                mini = min(mini, hd - 1);\r\n                q.push({hd - 1, curr->left});\r\n            }\r\n            if (curr->right) {\r\n                maxi = max(maxi, hd + 1);\r\n                q.push({hd + 1, curr->right});\r\n            }\r\n            mp[hd].push_back({lvl, curr->val});\r\n        }\r\n        lvl++;\r\n    }\r\n\r\n    vector<vector<int>> ans;\r\n    for (int i = mini; i <= maxi; i++) {\r\n        sort(mp[i].begin(), mp[i].end());\r\n        vector<int> temp;\r\n        for (auto it : mp[i])\r\n            temp.push_back(it.second);\r\n        ans.push_back(temp);\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "two-pointers",
        "bfs"
      ],
      "fingerprint": [
        "unordered_map<int, vector<pair<int, int>",
        "vector<vector<int>",
        "vector<pair<int, int>",
        "vector<vector<int>",
        "queue<pair<int, TreeNode*>",
        "for (int i = 0; i < n; i++)",
        "for (int i = mini; i <= maxi; i++)",
        "for (auto it : mp[i])",
        "while (!q.empty()",
        "sort(",
        ".push_back(",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\08. Vertical Order Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "top-view": {
      "id": "top-view",
      "title": "Top View",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given a binary tree, print its top view.",
      "approach": "- We can perform a level order traversal of the binary tree while keeping track of the horizontal distance (hd) of each node from the root.\r\n- For each node, if the horizontal distance is not present in the map, we add it to the map along with its value.\r\n- Since we want to print the nodes in the order of their horizontal distance, we maintain the minimum and maximum horizontal distances (`mini` and `maxi`) during the traversal.\r\n- Finally, we iterate over the range from `mini` to `maxi` and retrieve the corresponding values from the map, and add them to the result vector.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N), where N is the number of nodes in the binary tree. This space is used to store the nodes in the map during the traversal.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> getTopView(TreeNode<int> *root) {\r\n    if (!root) return {};\r\n\r\n    unordered_map<int, int> mp;\r\n    int mini = 0, maxi = 0;\r\n    queue<pair<int, TreeNode<int>*>> q;\r\n    q.push({0, root});\r\n\r\n    while (!q.empty()) {\r\n        auto p = q.front();\r\n        q.pop();\r\n        TreeNode<int>* curr = p.second;\r\n        int hd = p.first;\r\n        if (curr->left) {\r\n            mini = min(mini, hd - 1);\r\n            q.push({hd - 1, curr->left});\r\n        }\r\n        if (curr->right) {\r\n            maxi = max(maxi, hd + 1);\r\n            q.push({hd + 1, curr->right});\r\n        }\r\n        if (mp.find(hd) == mp.end())\r\n            mp[hd] = curr->data;\r\n    }\r\n\r\n    vector<int> ans;\r\n    for (int i = mini; i <= maxi; i++) {\r\n        ans.push_back(mp[i]);\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "bfs",
        "trie"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<int>",
        "vector<int>",
        "queue<pair<int, TreeNode<int>",
        "for (int i = mini; i <= maxi; i++)",
        "while (!q.empty()",
        ".find(",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\09. Top View.cpp",
      "verified": false,
      "needsReview": true
    },
    "bottom-view": {
      "id": "bottom-view",
      "title": "Bottom View",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given a binary tree, print its bottom view.",
      "approach": "- We can perform a level order traversal of the binary tree while keeping track of the horizontal distance (hd) and the level of each node from the root.\r\n- For each node, we update its horizontal distance and level in the map.\r\n- Since we want to print the nodes in the order of their horizontal distance, we maintain the minimum and maximum horizontal distances (`mini` and `maxi`) during the traversal.\r\n- Finally, we iterate over the range from `mini` to `maxi` and retrieve the corresponding values from the map, and add them to the result vector.\r\n\r\nComplexity Analysis:\r\n- Since we visit each node once and perform constant time operations for each node, the time complexity of this approach is O(N), where N is the number of nodes in the binary tree.\r\n- The space complexity is O(N), where N is the number of nodes in the binary tree. This space is used to store the nodes in the map during the traversal.\r\n\r\nCode:",
      "code": "*/\r\n\r\nvector<int> getBottomView(TreeNode<int> *root) {\r\n    if (!root) return {};\r\n\r\n    unordered_map<int, pair<int, int>> mp;\r\n    int mini = 0, maxi = 0;\r\n    queue<pair<TreeNode<int>*, pair<int, int>>> q;\r\n    q.push({root, {0, 0}});\r\n\r\n    while (!q.empty()) {\r\n        auto p = q.front();\r\n        q.pop();\r\n        TreeNode<int>* curr = p.first;\r\n        int hd = p.second.first;\r\n        int level = p.second.second;\r\n\r\n        mp[hd] = {curr->data, level};\r\n        mini = min(mini, hd);\r\n        maxi = max(maxi, hd);\r\n\r\n        if (curr->left) {\r\n            q.push({curr->left, {hd - 1, level + 1}});\r\n        }\r\n        if (curr->right) {\r\n            q.push({curr->right, {hd + 1, level + 1}});\r\n        }\r\n    }\r\n\r\n    vector<int> ans;\r\n    for (int i = mini; i <= maxi; i++) {\r\n        ans.push_back(mp[i].first);\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "bfs",
        "trie"
      ],
      "fingerprint": [
        "unordered_map<int, pair<int, int>",
        "vector<int>",
        "vector<int>",
        "queue<pair<TreeNode<int>",
        "for (int i = mini; i <= maxi; i++)",
        "while (!q.empty()",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\10. Bottom View.cpp",
      "verified": false,
      "needsReview": true
    },
    "left-or-right-view": {
      "id": "left-or-right-view",
      "title": "Left or Right View",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, imagine yourself standing on the right side of it,\r\nreturn the values of the nodes you can see ordered from top to bottom.",
      "approach": "- Perform a level order traversal of the binary tree.\r\n- For each level, keep track of the last node encountered (the rightmost node from the viewer's perspective).\r\n- Add the value of the last node at each level to the result.\r\n\r\nComplexity Analysis:\r\n- Time complexity: O(N), where N is the number of nodes in the binary tree.\r\n- Space complexity: O(M), where M is the maximum number of nodes at any level in the tree.",
      "code": "*/\r\nvector<int> rightSideView(TreeNode* root) {\r\n    if (!root) return {};\r\n\r\n    vector<int> ans;\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    while (!q.empty()) {\r\n        int n = q.size();\r\n        for (int i = 0; i < n; i++) {\r\n            TreeNode* curr = q.front();\r\n            q.pop();\r\n            if (curr->left) {\r\n                q.push(curr->left);\r\n            }\r\n            if (curr->right) {\r\n                q.push(curr->right);\r\n            }\r\n            // Add only the last node of the level to the answer for right view in case of left view push only the first element\r\n            if (i == n - 1) {\r\n                ans.push_back(curr->val);\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "queue<TreeNode*>",
        "for (int i = 0; i < n; i++)",
        "while (!q.empty()",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\11. Left or Right View.cpp",
      "verified": false,
      "needsReview": true
    },
    "symmetric-tree": {
      "id": "symmetric-tree",
      "title": "Symmetric Tree",
      "category": "binary-trees",
      "difficulty": "medium",
      "problemStatement": "Given the root of a binary tree, check whether it is a mirror of itself\r\n (i.e., symmetric around its center).\r\n \r\n Example:\r\n Input: root = [1,2,2,3,4,4,3]\r\n Output: true",
      "approach": "We can solve this problem using a recursive approach.\r\n 1. Define a helper function \"isMirror\" that takes two tree nodes as input.\r\n 2. Base case:\r\n    - If both nodes are NULL, return true.\r\n    - If either node is NULL, return false.\r\n 3. Check if the values of the two nodes are equal.\r\n 4. Recursively call \"isMirror\" on the left and right children of the two nodes:\r\n    - isMirror(node1->left, node2->right)\r\n    - isMirror(node1->right, node2->left)\r\n 5. Return the logical AND of the above two recursive calls.\r\n 6. In the main \"isSymmetric\" function, return the result of calling \"isMirror\" on the root's left and right children.\r\n \r\n COMPLEXITY ANALYSIS:\r\n - The time complexity is O(N), where N is the number of nodes in the binary tree, as we need to visit all the nodes once.\r\n - The space complexity is O(H), where H is the height of the tree, due to the recursive function calls on the stack.\r\n   In the worst case, the height of the tree can be equal to the number of nodes, resulting in O(N) space complexity.",
      "code": "*/\r\n\r\nbool isMirror(TreeNode* node1, TreeNode* node2) {\r\n    if (!node1 && !node2)\r\n        return true;\r\n    if (!node1 || !node2)\r\n        return false;\r\n    return (node1->val == node2->val) &&\r\n           isMirror(node1->left, node2->right) &&\r\n           isMirror(node1->right, node2->left);\r\n}\r\n\r\nbool isSymmetric(TreeNode* root) {\r\n    return isMirror(root->left, root->right);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\2. Medium Problems\\12. Symmetric Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "all-root-to-leaf-paths": {
      "id": "all-root-to-leaf-paths",
      "title": "All root to leaf paths",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "**\r\n\r\nWrite a program to print the path from the root to a given node in a binary tree. You are given a binary tree and a node value. You need to find and print the path from the root to the node.\r\n\r\n**",
      "approach": "**\r\n\r\nTo find the path from the root to the given node, we can use a recursive function. The idea is to traverse the tree from the root and keep track of the path in a vector. If the target node is found, add the node's value to the path vector, and return true. Otherwise, recursively search for the target node in the left and right subtrees. If the target node is not found, remove the last node from the path vector before returning false.\r\n\r\n**Complexity Analysis:**\r\n\r\nLet N be the number of nodes in the binary tree.\r\n\r\n- Time Complexity: The time complexity of the recursive function is O(N) as we may visit all nodes in the worst case.\r\n- Space Complexity: The space complexity is O(N) due to the space used by the recursion stack and the path vector.\r\n\r\n**Code:*",
      "code": "**/\r\n\r\nbool findPath(TreeNode* root, int target, vector<int>& path) {\r\n    if (!root) return false;\r\n\r\n    path.push_back(root->val);\r\n\r\n    if (root->val == target) {\r\n        return true;\r\n    }\r\n\r\n    if (findPath(root->left, target, path) || findPath(root->right, target, path)) {\r\n        return true;\r\n    }\r\n\r\n    path.pop_back();\r\n    return false;\r\n}\r\n\r\nvector<int> getPathFromRootToNode(TreeNode* root, int target) {\r\n    vector<int> path;\r\n    findPath(root, target, path);\r\n    return path;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\01. All root to leaf paths.cpp",
      "verified": false,
      "needsReview": true
    },
    "lowest-common-ancestor": {
      "id": "lowest-common-ancestor",
      "title": "Lowest Common Ancestor",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\r\n\r\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"\r\n\r\nExample 1:\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\nOutput: 3\r\nExplanation: The LCA of nodes 5 and 1 is 3.",
      "approach": "To find the lowest common ancestor (LCA) of two nodes `p` and `q` in a binary tree, we can use a recursive approach. We start from the root of the tree and check if either `p` or `q` matches the current node. If one of them matches, it means that the current node is the LCA. Otherwise, we recursively search for `p` and `q` in the left and right subtrees.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet `n` be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we may have to visit all nodes of the binary tree in the worst case.\r\n- Space Complexity: The space complexity is O(h) for the recursive call stack, where `h` is the height of the binary tree. In the worst case, when the binary tree is skewed, the space complexity becomes O(n).\r\n\r\n\r\nCODE:",
      "code": "*/\r\n\r\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\r\n    if (!root) return NULL;\r\n    if (root->val == p->val || root->val == q->val) return root;\r\n\r\n    TreeNode* lef = lowestCommonAncestor(root->left, p, q);\r\n    TreeNode* rig = lowestCommonAncestor(root->right, p, q);\r\n\r\n    if (!lef)\r\n        return rig;\r\n    if (!rig)\r\n        return lef;\r\n    return root;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\02. Lowest Common Ancestor.cpp",
      "verified": false,
      "needsReview": true
    },
    "max-width-of-binary-tree": {
      "id": "max-width-of-binary-tree",
      "title": "Max width of binary tree",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given the root of a binary tree, return the maximum width of the given tree.\r\n\r\nThe maximum width of a tree is the maximum width among all levels.\r\n\r\nThe width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\r\n\r\nIt is guaranteed that the answer will be in the range of a 32-bit signed integer.\r\n\r\nExample 1:\r\nInput: root = [1,3,2,5,3,null,9]\r\nOutput: 4\r\nExplanation: The maximum width exists in the third level with length 4 (5,3,null,9).",
      "approach": "To find the maximum width, we can perform a level-order traversal (BFS) of the binary tree while keeping track of the indices of nodes at each level. For each level, we calculate the width by finding the difference between the indices of the leftmost and rightmost non-null nodes. The maximum width among all levels will be the answer.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet `n` be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we need to traverse all nodes in the binary tree using BFS.\r\n- Space Complexity: The space complexity is O(w) for the queue, where `w` is the maximum width of the binary tree at any level.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint widthOfBinaryTree(TreeNode* root) {\r\n    if (!root) return 0;\r\n    long long ans = 0;\r\n    queue<pair<long long, TreeNode*>> q;\r\n    q.push({0, root});\r\n\r\n    while (!q.empty()) {\r\n        int n = q.size();\r\n        long long start = q.front().first;\r\n        long long end = q.back().first;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            auto p = q.front();\r\n            q.pop();\r\n            // note we are doing -start because we don't need previous value\r\n            long long index = p.first - start;\r\n            TreeNode* curr = p.second;\r\n\r\n            if (curr->left) q.push({2 * index + 1, curr->left});\r\n            if (curr->right) q.push({2 * index + 2, curr->right});\r\n        }\r\n\r\n        ans = max(ans, end - start + 1);\r\n    }\r\n\r\n    return (int)ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "bfs"
      ],
      "fingerprint": [
        "queue<pair<long long, TreeNode*>",
        "for (int i = 0; i < n; i++)",
        "while (!q.empty()",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\03. Max width of binary tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "check-children-sum-property": {
      "id": "check-children-sum-property",
      "title": "Check children sum property",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given a Binary Tree. Return true if, for every node X in the tree other than the leaves, its value is equal to the sum of its left subtree's value and its right subtree's value. Else return false.\r\n\r\nAn empty tree is also a Sum Tree as the sum of an empty tree can be considered to be 0. A leaf node is also considered a Sum Tree.\r\n\r\n\r\nExample 1:\r\nInput:\r\n    3\r\n  /   \\    \r\n 1     2\r\n\r\nOutput: 1\r\nExplanation:\r\nThe sum of left subtree and right subtree is 1 + 2 = 3, which is the value of the root node.\r\nTherefore, the given binary tree is a sum tree.",
      "approach": "To determine if a binary tree is a Sum Tree, we can perform a post-order traversal of the tree and check if each node satisfies the condition of being a Sum Tree.\r\n\r\nFor each node in the tree, we will calculate the sum of its left subtree and right subtree. If both subtrees are Sum Trees and the value of the current node is equal to the sum of its subtrees, then the current node is also a Sum Tree. Otherwise, it is not a Sum Tree.\r\n\r\nTo indicate that the current node is not a Sum Tree, we return a special value (e.g., INT_MIN) from the recursive function. If the result is INT_MIN, then the binary tree is not a Sum Tree. Otherwise, it is a Sum Tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet `n` be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) as we visit each node in the binary tree once during the post-order traversal.\r\n- Space Complexity: The space complexity is O(h) due to the recursion stack, where h is the height of the binary tree.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint solve(Node* root) {\r\n    if (!root) return 0;\r\n    if (!root->left && !root->right) return root->data;\r\n    \r\n    int lef = solve(root->left);\r\n    int rig = solve(root->right);\r\n    \r\n    return (lef + rig == root->data) ? 2 * root->data : INT_MIN;\r\n}\r\n\r\nbool isSumTree(Node* root) {\r\n    int ans = solve(root);\r\n    return (ans == INT_MIN) ? false : true;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\04. Check children sum property.cpp",
      "verified": false,
      "needsReview": true
    },
    "all-nodes-at-distance-k": {
      "id": "all-nodes-at-distance-k",
      "title": "All nodes at distance K",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.\r\n\r\nYou can return the answer in any order.\r\n\r\nExample 1:\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\r\nOutput: [7,4,1]\r\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.",
      "approach": "To find the nodes that are at a distance k from the target node, we can perform a two-step process:\r\n1. First, traverse the binary tree to build a map of each node to its parent node using BFS. This map will help us later to backtrack from the target node to its ancestors.\r\n2. Next, perform a BFS from the target node to find all nodes at a distance k from it. While doing this, we also mark visited nodes to avoid revisiting the same nodes.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet `n` be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we need to traverse the entire binary tree to build the parent map and perform BFS from the target node.\r\n- Space Complexity: The space complexity is O(n) for the parent map and O(k) for the queue used in BFS. In the worst case, when k approaches n, the space complexity becomes O(n).\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\r\n    vector<int> ans;\r\n    unordered_map<int, TreeNode*> parent;\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    while (!q.empty()) {\r\n        int si = q.size();\r\n        for (int i = 0; i < si; i++) {\r\n            auto top = q.front();\r\n            q.pop();\r\n\r\n            if (top->left) {\r\n                parent[top->left->val] = top;\r\n                q.push(top->left);\r\n            }\r\n\r\n            if (top->right) {\r\n                parent[top->right->val] = top;\r\n                q.push(top->right);\r\n            }\r\n        }\r\n    }\r\n\r\n    unordered_map<int, int> visited;\r\n    q.push(target);\r\n    while (k-- && !q.empty()) {\r\n        int size = q.size();\r\n\r\n        for (int i = 0; i < size; i++) {\r\n            auto top = q.front();\r\n            q.pop();\r\n\r\n            visited[top->val] = 1;\r\n\r\n            if (top->left && !visited[top->left->val]) {\r\n                q.push(top->left);\r\n            }\r\n\r\n            if (top->right && !visited[top->right->val]) {\r\n                q.push(top->right);\r\n            }\r\n\r\n            if (parent[top->val] && !visited[parent[top->val]->val]) {\r\n                q.push(parent[top->val]);\r\n            }\r\n        }\r\n    }\r\n\r\n    while (!q.empty()) {\r\n        ans.push_back(q.front()->val);\r\n        q.pop();\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "recursion",
        "backtracking",
        "bfs"
      ],
      "fingerprint": [
        "unordered_map<int, TreeNode*>",
        "unordered_map<int, int>",
        "vector<int>",
        "vector<int>",
        "queue<TreeNode*>",
        "for (int i = 0; i < si; i++)",
        "for (int i = 0; i < size; i++)",
        "while (!q.empty()",
        "while (k-- && !q.empty()",
        "while (!q.empty()",
        ".push_back(",
        ".push(",
        ".push(",
        ".push(",
        ".pop(",
        ".pop(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\05. All nodes at distance K.cpp",
      "verified": false,
      "needsReview": true
    },
    "min-time-to-burn-binary-tree": {
      "id": "min-time-to-burn-binary-tree",
      "title": "Min time to burn binary tree",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given a binary tree and a node data called target. Find the minimum time required to burn the complete binary tree if the target is set on fire. It is known that in 1 second, all nodes connected to a given node get burned. That is its left child, right child, and parent.\r\nNote: The tree contains unique values.\r\n\r\nExample 1:\r\nInput:\r\n          1\r\n        /   \\\r\n      2      3\r\n    /  \\      \\\r\n   4    5      6\r\n       / \\      \\\r\n      7   8      9\r\n                   \\\r\n                   10\r\n\r\nTarget Node = 8\r\nOutput: 7\r\nExplanation: If the leaf with the value 8 is set on fire:\r\nAfter 1 sec: 5 is set on fire.\r\nAfter 2 sec: 2, 7 are set to fire.\r\nAfter 3 sec: 4, 1 are set to fire.\r\nAfter 4 sec: 3 is set to fire.\r\nAfter 5 sec: 6 is set to fire.\r\nAfter 6 sec: 9 is set to fire.\r\nAfter 7 sec: 10 is set to fire.\r\nIt takes 7s to burn the complete tree.",
      "approach": "To find the minimum time required to burn the complete binary tree, we need to perform a BFS (level-order traversal) starting from the target node. While doing BFS, we will also keep track of the parent node for each node using a hash map. The parent node will be used to traverse upward from the target node in the BFS process.\r\n\r\nWe will burn the target node and its adjacent nodes (left child, right child, and parent) one by one in each second. By the time we burn all nodes in the last level, all other nodes in the binary tree would have been burned as well.\r\n\r\nFinally, we will count the number of seconds it took to burn the complete binary tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet `n` be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we perform a BFS starting from the target node, visiting all nodes in the binary tree once.\r\n- Space Complexity: The space complexity is O(n) for the queue and the hash map.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid setParent(BinaryTreeNode<int>* root, unordered_map<BinaryTreeNode<int>*, BinaryTreeNode<int>*>& parent) {\r\n    if (!root) return;\r\n    if (root->data == start->data) s = root;\r\n\r\n    if (root->left) parent[root->left] = root;\r\n    if (root->right) parent[root->right] = root;\r\n\r\n    setParent(root->left, parent);\r\n    setParent(root->right, parent);\r\n}\r\n\r\nint timeToBurnTree(BinaryTreeNode<int>* root, BinaryTreeNode<int>* start) {\r\n    unordered_map<BinaryTreeNode<int>*, BinaryTreeNode<int>*> parent;\r\n    setParent(root, parent);\r\n\r\n    queue<BinaryTreeNode<int>*> q;\r\n    q.push(start);\r\n    int time = 0;\r\n    unordered_map<BinaryTreeNode<int>*, bool> vis;\r\n\r\n    while (!q.empty()) {\r\n        int n = q.size();\r\n        for (int i = 0; i < n; i++) {\r\n            auto curr = q.front();\r\n            q.pop();\r\n\r\n            if (curr->left && !vis[curr->left]) q.push(curr->left);\r\n            if (curr->right && !vis[curr->right]) q.push(curr->right);\r\n            if (parent[curr] && !vis[parent[curr]]) q.push(parent[curr]);\r\n            \r\n            vis[curr] = true;\r\n        }\r\n        time++;\r\n    }\r\n    return time - 1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set",
        "two-pointers",
        "bfs"
      ],
      "fingerprint": [
        "unordered_map<BinaryTreeNode<int>",
        "unordered_map<BinaryTreeNode<int>",
        "unordered_map<BinaryTreeNode<int>",
        "queue<BinaryTreeNode<int>",
        "for (int i = 0; i < n; i++)",
        "while (!q.empty()",
        ".push(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\06. Min time to burn binary tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-nodes-in-complete-binary-tree": {
      "id": "count-nodes-in-complete-binary-tree",
      "title": "Count nodes in complete binary tree",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given the root of a complete binary tree, return the number of nodes in the tree.\r\n\r\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\r\n\r\nDesign an algorithm that runs in less than O(n) time complexity.",
      "approach": "To count the number of nodes in the complete binary tree efficiently, we can make use of the property of complete binary trees. Since all levels of the tree, except possibly the last level, are completely filled, we can perform binary search on the last level to find the number of nodes.\r\n\r\n1. First, we calculate the height of the left and right subtrees starting from the root.\r\n2. If the height of the left subtree is equal to the height of the right subtree, it means that the last level is completely filled, and the number of nodes in the tree is 2^h - 1, where h is the height of the tree.\r\n3. If the heights are not equal, it means that the last level is not completely filled. In this case, we recursively calculate the number of nodes in the left and right subtrees and add 1 (for the root node) to get the total number of nodes in the tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the complete binary tree.\r\n- Time Complexity: The time complexity of this approach is O(log^2 n), as we perform binary search on the last level, and at each step, we calculate the height of the left and right subtrees, which takes O(log n) time. We do this operation recursively, so the overall time complexity is O(log^2 n).\r\n- Space Complexity: The space complexity is O(log n) due to the recursion stack, where n is the height of the complete binary tree.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint leftHeight(TreeNode* root) {\r\n    int h = 1;\r\n    while (root) {\r\n        h++;\r\n        root = root->left;\r\n    }\r\n    return h;\r\n}\r\n\r\nint rightHeight(TreeNode* root) {\r\n    int h = 1;\r\n    while (root) {\r\n        h++;\r\n        root = root->right;\r\n    }\r\n    return h;\r\n}\r\n\r\nint countNodes(TreeNode* root) {\r\n    if (!root) return 0;\r\n    int lh = leftHeight(root->left);\r\n    int rh = rightHeight(root->right);\r\n    if (lh == rh)\r\n        return pow(2, lh) - 1;\r\n    return 1 + countNodes(root->left) + countNodes(root->right);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search",
        "recursion"
      ],
      "fingerprint": [
        "while (root)",
        "while (root)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\07. Count nodes in complete binary tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "construct-bt-from-inorder-and-preorder": {
      "id": "construct-bt-from-inorder-and-preorder",
      "title": "Construct BT from inorder and preorder",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
      "approach": "The preorder traversal follows the root-left-right order, while the inorder traversal follows the left-root-right order. Based on these two traversals, we can construct the binary tree recursively.\r\n\r\n1. The first element in the preorder traversal array is the root of the binary tree.\r\n2. We can find the position of the root in the inorder traversal array. All the elements to the left of this position will be in the left subtree, and all the elements to the right will be in the right subtree.\r\n3. Recursively, we can build the left and right subtrees using the corresponding portions of the preorder and inorder traversal arrays.\r\n4. The recursive function takes the index of the current element in the preorder traversal array, the starting and ending indices of the current portion in the inorder traversal array, and the preorder and inorder traversal arrays as inputs.\r\n5. In each recursive call, we create a new node with the value of the current element in the preorder traversal array and determine its left and right subtrees by calling the recursive function on the corresponding portions of the inorder and preorder traversal arrays.\r\n6. The base case is when the starting index is greater than the ending index, indicating an empty portion of the tree. In this case, we return NULL.\r\n7. Finally, we return the root of the constructed binary tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n), as we visit each node once.\r\n- Space Complexity: The space complexity is O(n) for the recursive call stack.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nTreeNode* solve(int i, int ins, int ine, vector<int>& preorder, vector<int>& inorder) {\r\n    if (i >= preorder.size() || ins > ine) return NULL;\r\n\r\n    int loc = -1;\r\n    for (int j = ins; j <= ine; j++) {\r\n        if (inorder[j] == preorder[i])\r\n            loc = j;\r\n    }\r\n    TreeNode* root = new TreeNode(preorder[i]);\r\n    root->left = solve(i + 1, ins, loc - 1, preorder, inorder);\r\n    // Note: the index of the right child in preorder is the number of nodes in the left subtree + 1\r\n    root->right = solve(i + (loc - ins + 1), loc + 1, ine, preorder, inorder);\r\n\r\n    return root;\r\n}\r\n\r\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\r\n    int n = inorder.size();\r\n    return solve(0, 0, n - 1, preorder, inorder);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int j = ins; j <= ine; j++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\08. Construct BT from inorder and preorder.cpp",
      "verified": false,
      "needsReview": true
    },
    "construct-bt-from-inorder-and-postorder": {
      "id": "construct-bt-from-inorder-and-postorder",
      "title": "Construct BT from inorder and postorder",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
      "approach": "The postorder traversal follows the left-right-root order, while the inorder traversal follows the left-root-right order. Based on these two traversals, we can construct the binary tree recursively.\r\n\r\n1. The last element in the postorder traversal array is the root of the binary tree.\r\n2. We can find the position of the root in the inorder traversal array. All the elements to the left of this position will be in the left subtree, and all the elements to the right will be in the right subtree.\r\n3. Recursively, we can build the left and right subtrees using the corresponding portions of the inorder and postorder traversal arrays.\r\n4. The recursive function takes the index of the current element in the postorder traversal array, the starting and ending indices of the current portion in the inorder traversal array, and the inorder and postorder traversal arrays as inputs.\r\n5. In each recursive call, we create a new node with the value of the current element in the postorder traversal array and determine its left and right subtrees by calling the recursive function on the corresponding portions of the inorder and postorder traversal arrays.\r\n6. The base case is when the starting index is greater than the ending index, indicating an empty portion of the tree. In this case, we return NULL.\r\n7. Finally, we return the root of the constructed binary tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n), as we visit each node once.\r\n- Space Complexity: The space complexity is O(n) for the recursive call stack.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nTreeNode* solve(int pi, int ins, int ine, vector<int>& inorder, vector<int>& postorder) {\r\n    if (pi < 0 || ins > ine) return NULL;\r\n\r\n    int loc = -1;\r\n    for (int i = ins; i <= ine; i++) {\r\n        if (inorder[i] == postorder[pi])\r\n            loc = i;\r\n    }\r\n\r\n    TreeNode* root = new TreeNode(postorder[pi]);\r\n    root->right = solve(pi - 1, loc + 1, ine, inorder, postorder);\r\n    root->left = solve(pi - (ine - loc + 1), ins, loc - 1, inorder, postorder);\r\n\r\n    return root;\r\n}\r\n\r\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\r\n    int n = inorder.size();\r\n    return solve(n - 1, 0, n - 1, inorder, postorder);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = ins; i <= ine; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\09. Construct BT from inorder and postorder.cpp",
      "verified": false,
      "needsReview": true
    },
    "morris-preorder-traversal": {
      "id": "morris-preorder-traversal",
      "title": "Morris Preorder Traversal",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given a binary tree, find the preorder traversal of the tree without using extra space.",
      "approach": "We can achieve a non-recursive preorder traversal without using extra space by modifying the binary tree itself.\r\n\r\n1. We start with the current node as the root.\r\n2. While the current node is not NULL, we do the following:\r\n   - If the current node does not have a left child, we visit the current node and move to its right child.\r\n   - If the current node has a left child, we find the rightmost node of its left subtree.\r\n     - If the rightmost node does not have a right child, we visit the current node, make the right child of the rightmost node point to the current node, and move to the left child.\r\n     - If the rightmost node already has a right child (which points back to the current node), we reset the right child to NULL, visit the current node, and move to its right child.\r\n3. We repeat this process until we have visited all the nodes in the tree.\r\n4. Finally, we return the result vector containing the preorder traversal.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we visit each node once.\r\n- Space Complexity: The space complexity is O(1) since we don't use any extra space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> preOrder(Node* root) {\r\n    vector<int> ans;\r\n    Node* curr = root;\r\n\r\n    while (curr) {\r\n        if (!curr->left) {\r\n            ans.push_back(curr->data);\r\n            curr = curr->right;\r\n        } else {\r\n            Node* rightmost = curr->left;\r\n            while (rightmost->right && rightmost->right != curr)\r\n                rightmost = rightmost->right;\r\n\r\n            if (!rightmost->right) {\r\n                ans.push_back(curr->data);\r\n                rightmost->right = curr;\r\n                curr = curr->left;\r\n            } else {\r\n                rightmost->right = NULL;\r\n                curr = curr->right;\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "while (curr)",
        "while (rightmost->right && rightmost->right != curr)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\11. Morris Preorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "morris-inorder-traversal": {
      "id": "morris-inorder-traversal",
      "title": "Morris Inorder Traversal",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given a binary tree, find the inorder traversal of the tree without using extra space.",
      "approach": "We can achieve a non-recursive inorder traversal without using extra space by modifying the binary tree itself.\r\n\r\n1. We start with the current node as the root.\r\n2. While the current node is not NULL, we do the following:\r\n   - If the current node does not have a left child, we visit the current node and move to its right child.\r\n   - If the current node has a left child, we find the rightmost node of its left subtree.\r\n     - If the rightmost node does not have a right child, we make the right child point to the current node and move to the left child.\r\n     - If the rightmost node already has a right child (which points back to the current node), we reset the right child to NULL, visit the current node, and move to its right child.\r\n3. We repeat this process until we have visited all the nodes in the tree.\r\n4. Finally, we return the result vector containing the inorder traversal.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we visit each node once.\r\n- Space Complexity: The space complexity is O(1) since we don't use any extra space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> inOrder(Node* root) {\r\n    vector<int> ans;\r\n    Node* curr = root;\r\n\r\n    while (curr) {\r\n        if (!curr->left) {\r\n            ans.push_back(curr->data);\r\n            curr = curr->right;\r\n        } else {\r\n            Node* rightmost = curr->left;\r\n            while (rightmost->right && rightmost->right != curr)\r\n                rightmost = rightmost->right;\r\n\r\n            if (!rightmost->right) {\r\n                rightmost->right = curr;\r\n                curr = curr->left;\r\n            } else {\r\n                ans.push_back(curr->data);\r\n                rightmost->right = NULL;\r\n                curr = curr->right;\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "while (curr)",
        "while (rightmost->right && rightmost->right != curr)",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\12. Morris Inorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "flatten-binary-tree": {
      "id": "flatten-binary-tree",
      "title": "Flatten Binary Tree",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Given the root of a binary tree, flatten the tree into a \"linked list\".",
      "approach": "To flatten the binary tree into a linked list, we can modify the tree in-place using a modified preorder traversal.\r\n\r\n1. We start with the current node as the root.\r\n2. While the current node is not NULL, we do the following:\r\n   - If the current node has a left child, we find the rightmost node of its left subtree.\r\n     - We make the right child of the rightmost node point to the right child of the current node.\r\n     - We set the left child of the current node to NULL.\r\n     - We set the right child of the current node to its left child.\r\n   - We move to the right child of the current node.\r\n3. We repeat this process until we have visited all the nodes in the tree.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity: The time complexity of this approach is O(n) since we visit each node once.\r\n- Space Complexity: The space complexity is O(1) since we don't use any extra space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid flatten(TreeNode* root) {\r\n    TreeNode* curr = root;\r\n\r\n    while (curr) {\r\n        if (curr->left) {\r\n            TreeNode* temp = curr->left;\r\n            while (temp->right)\r\n                temp = temp->right;\r\n\r\n            temp->right = curr->right;\r\n            curr->left = NULL;\r\n            curr->right = curr->left;\r\n        }\r\n        curr = curr->right;\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "two-pointers"
      ],
      "fingerprint": [
        "while (curr)",
        "while (temp->right)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\13. Flatten Binary Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "serialize-and-deserialize": {
      "id": "serialize-and-deserialize",
      "title": "Serialize and Deserialize",
      "category": "binary-trees",
      "difficulty": "hard",
      "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
      "approach": "To serialize the binary tree, we can perform a preorder traversal of the tree and append the node values to a string, separating them by a delimiter.\r\n\r\nTo deserialize the string back to the original tree structure, we can use a stringstream to split the string by the delimiter and recursively build the tree.\r\n\r\n1. For serialization:\r\n   - If the current node is NULL, we append \"N,\" to the string.\r\n   - Otherwise, we append the node value followed by a delimiter \",\" to the string.\r\n   - We then recursively serialize the left and right subtrees.\r\n\r\n2. For deserialization:\r\n   - If the current string token is \"N,\" indicating a NULL node, we return NULL.\r\n   - Otherwise, we convert the string token to an integer and create a new TreeNode with the value.\r\n   - We then recursively deserialize the left and right subtrees.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of nodes in the binary tree.\r\n- Time Complexity:\r\n  - Serialization: O(n) - We visit each node once during the serialization process.\r\n  - Deserialization: O(n) - We process each string token once during the deserialization process.\r\n- Space Complexity: O(n) - The space required for the serialized string and the recursion stack.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid serialize(TreeNode* root, string& serialized) {\r\n    if (!root) {\r\n        serialized += \"N,\";\r\n        return;\r\n    }\r\n    serialized += to_string(root->val) + \",\";\r\n    serialize(root->left, serialized);\r\n    serialize(root->right, serialized);\r\n}\r\n\r\nstring serialize(TreeNode* root) {\r\n    string serialized;\r\n    serialize(root, serialized);\r\n    return serialized;\r\n}\r\n\r\nTreeNode* deserialize(stringstream& ss) {\r\n    string token;\r\n    getline(ss, token, ',');\r\n    if (token == \"N\")\r\n        return nullptr;\r\n    TreeNode* root = new TreeNode(stoi(token));\r\n    root->left = deserialize(ss);\r\n    root->right = deserialize(ss);\r\n    return root;\r\n}\r\n\r\nTreeNode* deserialize(string data) {\r\n    stringstream ss(data);\r\n    return deserialize(ss);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\11. Binary Trees\\3. Hard\\14. Serialize and Deserialize.cpp",
      "verified": false,
      "needsReview": true
    },
    "intro-to-bst": {
      "id": "intro-to-bst",
      "title": "Intro to BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "**\r\n\r\nGiven an array `order`, which represents the inorder traversal of a binary search tree (BST), the task is to check if it's valid or not.\r\n\r\n**",
      "approach": "**\r\n\r\nA binary search tree is considered valid if its inorder traversal is in non-decreasing order. We can simply iterate through the `order` array and check if each element is smaller than the next element. If we find any element that is greater than or equal to the next element, the BST is not valid, and we return `false`. Otherwise, we return `true`.\r\n\r\n**Complexity Analysis:**\r\n\r\nLet's analyze the time and space complexity of our approach:\r\n\r\n- Time Complexity: O(N)\r\n  - In the worst case, we need to iterate through the entire `order` array once, where N is the number of elements in the array.\r\n\r\n- Space Complexity: O(1)\r\n  - We are not using any additional space that grows with the input size, so the space complexity is constant.\r\n\r\n**Code:*",
      "code": "**/\r\n\r\n\r\nbool isValidBST(vector<int> &order) {\r\n    for (int i = 1; i < order.size(); i++) {\r\n        if (order[i - 1] >= order[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search"
      ],
      "fingerprint": [
        "vector<int>",
        "for (int i = 1; i < order.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\1. Concept\\01. Intro to BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "search-in-bst": {
      "id": "search-in-bst",
      "title": "Search in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "**\r\n\r\nYou are given the root of a binary search tree (BST) and an integer `val`. You need to find the node in the BST whose value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `NULL`.\r\n\r\n**",
      "approach": "**\r\n\r\nSince the given binary tree is a binary search tree, we can utilize its property to efficiently find the node with the value `val`. We start from the root and compare its value with `val`. If the current node's value is equal to `val`, we return the current node as it is the node we are looking for. If the current node's value is greater than `val`, we need to search in the left subtree because all nodes in the left subtree have smaller values. Similarly, if the current node's value is smaller than `val`, we need to search in the right subtree. We recursively perform this process until we find the desired node or reach a leaf node (where the node is not present).\r\n\r\n**Complexity Analysis:**\r\n\r\nLet's analyze the time and space complexity of our approach:\r\n\r\n- Time Complexity: O(log N) on average for balanced BST, O(N) in the worst case for skewed BST.\r\n  - In a balanced binary search tree, each level reduces the search space by half, so the time complexity is logarithmic. However, in the worst case, the BST can be skewed, and we may need to traverse all nodes in one path, leading to linear time complexity.\r\n\r\n- Space Complexity: O(H), where H is the height of the BST.\r\n  - The space complexity is determined by the recursion stack. In the average case, the height of a balanced BST is logarithmic, resulting in a logarithmic space complexity. In the worst case, when the tree is skewed, the height is N, resulting in a space complexity of O(N).\r\n\r\n**Code:*",
      "code": "**/\r\n\r\n\r\nTreeNode* searchBST(TreeNode* root, int val) {\r\n    if (!root) return NULL;\r\n    if (root->val == val) return root;\r\n    if (root->val > val) return searchBST(root->left, val);\r\n    else return searchBST(root->right, val);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "binary-search",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\1. Concept\\02. Search in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-value-in-bst": {
      "id": "minimum-value-in-bst",
      "title": "Minimum value in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "**\r\n\r\nGiven a Binary Search Tree (BST), find the minimum value in it.\r\n\r\nExample:\r\n\r\n\r\n    8\r\n   / \r\n  5\r\n / \\\r\n3   6 \r\n\r\n\r\nBST for the given input looks like the above. The minimum value in this BST is `3`.\r\n\r\n**",
      "approach": "**\r\n\r\nTo find the minimum value in a BST, we can traverse the left child nodes until we reach the leftmost leaf node, which will have the minimum value.\r\n\r\n**COMPLEXITY ANALYSIS:**\r\n\r\nLet 'n' be the number of nodes in the BST.\r\n\r\n- Time Complexity: The time complexity of finding the minimum value in a BST is O(h), where 'h' is the height of the BST. In the worst case, the height of a skewed BST could be 'n', but in a balanced BST, the height is log(n), making the average time complexity O(log n).\r\n- Space Complexity: The space complexity is O(1) as we are not using any extra space.\r\n\r\n**CODE:*",
      "code": "**/\r\n\r\nint minVal(Node* root) {\r\n    if (!root) return -1;\r\n    while (root->left)\r\n        root = root->left;\r\n    return root->data;\t\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "while (root->left)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\1. Concept\\03. Minimum value in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "ceil-in-bst": {
      "id": "ceil-in-bst",
      "title": "Ceil in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "**\r\n\r\nGiven a Binary Search Tree (BST) and a number `X`, find the Ceil of `X`. Ceil(X) is a number that is either equal to `X` or is immediately greater than `X` in the BST.\r\n\r\nIf the Ceil of `X` could not be found, return `-1`.\r\n\r\n**Example 1:**\r\n\r\nInput:\r\n\r\n      5\r\n    /   \\\r\n   1     7\r\n    \\\r\n     2 \r\n      \\\r\n       3\r\nX = 3\r\n\r\nOutput: 3\r\n\r\nExplanation: We find 3 in the BST, so the ceil of 3 is 3.\r\n\r\n**",
      "approach": "**\r\n\r\nTo find the Ceil of a given number `X`, we can perform a traversal of the BST and keep track of the node with the smallest value that is greater than or equal to `X`. \r\nWe can use a recursive function to traverse the BST while updating the answer (`ans`) whenever we find a node with a greater value than `X`. If we find an exact match for `X`, we can directly set `ans` to `X`.\r\n\r\n**COMPLEXITY ANALYSIS:**\r\n\r\nThe time complexity of this approach is O(h), where `h` is the height of the BST. In the worst case, the height of the BST can be `N` (for a skewed tree), where `N` is the number of nodes in the BST. \r\nIn the average case, the height is usually log(N) for a balanced BST.\r\n\r\nThe space complexity is O(1) since we are using a constant amount of extra space (variables) to store the intermediate results.\r\n\r\n**CODE:*",
      "code": "**/\r\n\r\n\r\nvoid solve(Node* root, int x, int& ans) {\r\n    if (!root) return;\r\n    if (root->data == x) {\r\n        ans = root->data;\r\n        return;\r\n    } \r\n    if (root->data > x) {\r\n        ans = root->data;\r\n        return solve(root->left, x, ans);\r\n    }\r\n    return solve(root->right, x, ans);\r\n}\r\n\r\nint findCeil(Node* root, int input) {\r\n    if (root == NULL) return -1;\r\n    int ans = -1;\r\n    solve(root, input, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\01. Ceil in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "floor-in-bst": {
      "id": "floor-in-bst",
      "title": "Floor in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "// Given a Binary Search Tree (BST) with `n` number of nodes and a value `x`, find the greatest value node of the BST which is smaller than or equal to `x`.\r\n// Note: If `x` is smaller than the smallest node of the BST, then return -1.\r\n\r\n//",
      "approach": "// To find the floor of `x` in the BST, we can perform a recursive traversal of the tree starting from the root. While traversing, we compare the value of the current node with `x` to find the largest value in the tree that is smaller than or equal to `x`. We update the `ans` variable with the current node's value if it is smaller than or equal to `x` and continue the traversal in the left or right subtree.\r\n\r\n// Complexity Analysis\r\n// Time complexity: O(h), where h is the height of the BST. In the worst case, the function needs to traverse the entire height of the BST.\r\n// Space complexity: O(1), as the function uses a single integer variable (`ans`) to store the result.\r\n\r\n//",
      "code": "int findFloor(Node* root, int x) {\r\n    if (!root) return -1;\r\n    int ans = -1;\r\n    while (root) {\r\n        if (root->data == x) {\r\n            ans = root->data;\r\n            break;\r\n        } else if (root->data < x) {\r\n            ans = root->data;\r\n            root = root->right;\r\n        } else {\r\n            root = root->left;\r\n        }\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "while (root)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\02. Floor in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "insert-into-bst": {
      "id": "insert-into-bst",
      "title": "Insert into BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\r\n\r\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\r\n\r\nExample 1:\r\nInput: root = [4,2,7,1,3], val = 5\r\nOutput: [4,2,7,1,3,5]",
      "approach": "1. To insert a value 'val' into the BST, we start from the root node and traverse down the tree to find the appropriate position for insertion.\r\n2. If the BST is empty (i.e., root is null), we create a new node with value 'val' and make it the root of the BST.\r\n3. If the value of the current node is less than 'val', we move to the right subtree, as the value to be inserted will be greater than the current node.\r\n4. If the value of the current node is greater than or equal to 'val', we move to the left subtree, as the value to be inserted will be less than or equal to the current node.\r\n5. We continue this process of traversing down the tree until we reach a leaf node where we can insert the new value 'val'.\r\n\r\nComplexity Analysis\r\nTime complexity: O(h), where h is the height of the BST. In the worst case, the function needs to traverse the entire height of the BST to find the appropriate position for insertion.\r\nSpace complexity: O(h), where h is the height of the BST. In the worst case, the function may have to traverse the entire height of the BST, leading to h recursive calls in the call stack.",
      "code": "*/\r\n\r\nTreeNode* insertIntoBST(TreeNode* root, int val) {\r\n    if (!root) return new TreeNode(val);\r\n    if (root->val < val) root->right = insertIntoBST(root->right, val); \r\n    else root->left =  insertIntoBST(root->left, val);\r\n    return root;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\03. Insert into BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "delete-from-bst": {
      "id": "delete-from-bst",
      "title": "Delete from BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\r\n\r\nBasically, the deletion can be divided into two stages:\r\n\r\n1. Search for a node to remove.\r\n2. If the node is found, delete the node.",
      "approach": "To delete a node with a given key from the BST, we need to search for the node first. If the node is found, there are three possible cases:\r\n1. The node to be deleted is a leaf node (no children).\r\n2. The node to be deleted has only one child (left or right child).\r\n3. The node to be deleted has both left and right children.\r\n\r\nFor the first case, we simply remove the node from the tree and return NULL as the new root.\r\nFor the second case, we return the non-NULL child of the node to be deleted as the new root.\r\nFor the third case, we find the maximum value node in the left subtree of the node to be deleted (the rightmost node of the left subtree), copy its value to the node to be deleted, and then recursively delete the maximum value node in the left subtree.\r\n\r\nExample:\r\nInput: root = [5,3,6,2,4,null,7], key = 3\r\nOutput: [5,4,6,2,null,null,7]",
      "code": "TreeNode* deleteNode(TreeNode* root, int key) {\r\n    if (!root) return NULL;\r\n    if (root->val == key) {\r\n        if (!root->left && !root->right) return NULL; // Case: Node to be deleted is a leaf node\r\n        if (!root->left || !root->right) return root->left ? root->left : root->right; // Case: Node to be deleted has only one child\r\n        TreeNode* temp = root->left; // Case: Node to be deleted has both left and right children\r\n        while (temp->right != NULL) temp = temp->right;\r\n        root->val = temp->val;\r\n        root->left = deleteNode(root->left, temp->val); // Delete the node that was copied into the current node\r\n    } \r\n    if (root->val < key) root->right = deleteNode(root->right, key);\r\n    root->left = deleteNode(root->left, key);\r\n    return root;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [
        "while (temp->right != NULL)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\04. Delete from BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "kth-smallest-element-in-bst": {
      "id": "kth-smallest-element-in-bst",
      "title": "Kth smallest element in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\r\n\r\nExample:\r\nInput: root = [3,1,4,null,2], k = 1\r\nOutput: 1",
      "approach": "To find the kth smallest value in a binary search tree (BST), we can perform an in-order traversal of the BST and keep track of the count of nodes visited so far. When the count becomes equal to k, we have found the kth smallest value.\r\n\r\n1. Perform in-order traversal of the BST.\r\n2. While traversing, keep track of the count of nodes visited and compare it with k.\r\n3. When count becomes equal to k, store the value of the current node as the answer.\r\n\r\nExample:\r\nConsider the BST [3, 1, 4, null, 2].\r\n\r\n          3\r\n         / \\\r\n        1   4\r\n         \\\r\n          2\r\n\r\nIn-order traversal of this BST gives: 1, 2, 3, 4. The 1st smallest value is 1, 2nd smallest value is 2, 3rd smallest value is 3, and so on.\r\n\r\nTime Complexity: O(log n + k)\r\n- The in-order traversal of a balanced BST takes O(log n) time on average.\r\n- Finding the kth smallest value takes O(k) time in the worst case when k is close to n (the number of nodes in the BST).\r\n- In the worst case, the total time complexity becomes O(log n + k).\r\n\r\nSpace Complexity: O(log n)\r\n- The space complexity is determined by the recursion stack during the in-order traversal, which has a maximum depth of log n for a balanced BST.",
      "code": "*/\r\n\r\nvoid inorder(TreeNode* root, int k, int& cnt, int& ans) {\r\n    if (!root) return;\r\n    inorder(root->left, k, cnt, ans);\r\n    cnt++;\r\n    if (cnt == k) {\r\n        ans = root->val;\r\n        return;\r\n    }\r\n    inorder(root->right, k, cnt, ans);\r\n}\r\n\r\nint kthSmallest(TreeNode* root, int k) {\r\n    int ans = -1, cnt = 0;\r\n    inorder(root, k, cnt, ans);\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "binary-search",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\05. Kth smallest element in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "validate-bst": {
      "id": "validate-bst",
      "title": "Validate BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\r\n\r\nA valid BST is defined as follows:\r\n- The left subtree of a node contains only nodes with keys less than the node's key.\r\n- The right subtree of a node contains only nodes with keys greater than the node's key.\r\n- Both the left and right subtrees must also be binary search trees.\r\n\r\nExample:\r\nInput: root = [5,1,4,null,null,3,6]\r\nOutput: false\r\nExplanation: The root node's value is 5 but its right child's value is 4.",
      "approach": "- Initialize the range with LONG_MIN and LONG_MAX values.\r\n- Now, if a node->val is out of the range then it's not a BST\r\n- And, then check for the left and right subtrees with modified range \r\n\r\nTime Complexity: O(n)\r\n- The in-order traversal visits each node exactly once, where n is the number of nodes in the binary tree.\r\n\r\nSpace Complexity: O(h)\r\n- The space complexity is determined by the recursion stack during the in-order traversal, where h is the height of the binary tree.\r\n- In the worst case, the height of the binary tree can be n for a skewed tree, so the space complexity becomes O(n).\r\n- However, for a balanced BST, the height is log n, so the space complexity becomes O(log n).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\06. Validate BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "lca-in-bst": {
      "id": "lca-in-bst",
      "title": "LCA in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\r\n\r\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\r\n\r\nExample:\r\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\r\nOutput: 6\r\nExplanation: The LCA of nodes 2 and 8 is 6.",
      "approach": "- Traverse the BST from the root.\r\n- If both the nodes p and q are smaller than the current node's value, then the LCA must be in the left subtree. So, recursively call the function on the left subtree.\r\n- If both the nodes p and q are greater than the current node's value, then the LCA must be in the right subtree. So, recursively call the function on the right subtree.\r\n- If the current node's value is between the values of nodes p and q, then the current node is the LCA.\r\n\r\nTime Complexity: O(h)\r\n- h is the height of the BST.\r\n- In the worst case, the height of the BST can be n for a skewed tree, so the time complexity becomes O(n).\r\n- However, for a balanced BST, the height is log n, so the time complexity becomes O(log n).\r\n\r\nSpace Complexity: O(h)\r\n- The space complexity is determined by the recursion stack during the function call.\r\n- In the worst case, the height of the BST can be n for a skewed tree, so the space complexity becomes O(n).\r\n- However, for a balanced BST, the height is log n, so the space complexity becomes O(log n).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\07. LCA in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "build-bst-from-preorder-traversal": {
      "id": "build-bst-from-preorder-traversal",
      "title": "Build BST from Preorder Traversal",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\r\n\r\nIt is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\r\n\r\nA binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\r\n\r\nA preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.\r\n\r\nExample:\r\nInput: preorder = [8,5,1,7,10,12]\r\nOutput: [8,5,10,1,7,null,12]",
      "approach": "- The first element of the preorder traversal is the root of the BST.\r\n- We start with the first element of the preorder traversal and recursively build the BST as follows:\r\n    - If the current element is greater than the previous element, it must be the right child of the previous element. We build the right subtree of the previous element using this information and recursively move forward in the preorder array.\r\n    - If the current element is smaller than the previous element, it must be a left child of one of the previous elements. We keep on traversing the preorder array until we find an element greater than the current element. This element will be the right child of one of the ancestors of the current element.\r\n\r\nTime Complexity: O(n)\r\n- In the worst case, we might need to traverse the entire preorder array to construct the BST.\r\n\r\nSpace Complexity: O(h)\r\n- The space complexity is determined by the recursion stack during the function call.\r\n- In the worst case, the height of the BST can be n for a skewed tree, so the space complexity becomes O(n).\r\n- However, for a balanced BST, the height is log n, so the space complexity becomes O(log n).",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\08. Build BST from Preorder Traversal.cpp",
      "verified": false,
      "needsReview": true
    },
    "bst-iterator": {
      "id": "bst-iterator",
      "title": "BST Iterator",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\r\n\r\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\r\n\r\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\r\n\r\nint next() Moves the pointer to the right, then returns the number at the pointer.",
      "approach": "- We are using a stack to keep track of the nodes during the in-order traversal of the BST.\r\n- In the constructor, we initialize the stack by pushing all the leftmost nodes in the BST to the stack.\r\n- The next() function returns the top element of the stack (which will be the next smallest element in the BST) and pops it from the stack.\r\n- If the node has a right child, we push all the leftmost nodes in the right subtree to the stack before returning the node's value.\r\n- The hasNext() function simply checks if the stack is empty or not.\r\n\r\nTime Complexity:\r\n- The constructor takes O(h) time, where h is the height of the BST, as it traverses the leftmost path in the BST.\r\n- The next() and hasNext() functions take O(1) time as they only perform stack operations.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(h), where h is the height of the BST, as the stack stores the nodes in the leftmost path of the BST.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\09. BST Iterator.cpp",
      "verified": false,
      "needsReview": true
    },
    "two-sum-in-bst": {
      "id": "two-sum-in-bst",
      "title": "Two Sum in BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.\r\n\r\nExplanation:\r\n- We are using two stacks, one for the left traversal and one for the right traversal of the BST.\r\n- The next() function returns the next smallest element in the BST by popping the top element from the left stack and pushing all the leftmost nodes in its right subtree to the stack.\r\n- The before() function returns the next largest element in the BST by popping the top element from the right stack and pushing all the rightmost nodes in its left subtree to the stack.\r\n- We use the two pointer approach with the next() and before() functions to find the pair of elements in the BST whose sum is equal to k.\r\n\r\nTime Complexity:\r\n- The findTarget() function uses two pointers (one for the left and one for the right traversal of the BST) and performs a two pointer traversal of the BST, taking O(n) time, where n is the number of nodes in the BST.\r\n- The next() and before() functions take O(h) time each, where h is the height of the BST, as they traverse the leftmost and rightmost paths in the BST.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(h), where h is the height of the BST, as the stacks store the nodes in the leftmost and rightmost paths of the BST.",
      "approach": "with the next() and before() functions to find the pair of elements in the BST whose sum is equal to k.\r\n\r\nTime Complexity:\r\n- The findTarget() function uses two pointers (one for the left and one for the right traversal of the BST) and performs a two pointer traversal of the BST, taking O(n) time, where n is the number of nodes in the BST.\r\n- The next() and before() functions take O(h) time each, where h is the height of the BST, as they traverse the leftmost and rightmost paths in the BST.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(h), where h is the height of the BST, as the stacks store the nodes in the leftmost and rightmost paths of the BST.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\10. Two Sum in BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "recover-bst": {
      "id": "recover-bst",
      "title": "Recover BST",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\r\n\r\nExplanation:\r\n- We perform an in-order traversal of the BST to find the two nodes that are swapped.\r\n- During the in-order traversal, we keep track of the previous node and compare it with the current node. If the current node is less than the previous node, then we have found the two swapped nodes.\r\n- We swap the values of the two nodes to recover the BST.\r\n\r\nTime Complexity:\r\n- The in-order traversal takes O(n) time, where n is the number of nodes in the BST.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(h), where h is the height of the BST, as the recursion stack stores the nodes in the leftmost path of the BST.",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\11. Recover BST.cpp",
      "verified": false,
      "needsReview": true
    },
    "largest-bst-in-binary-tree": {
      "id": "largest-bst-in-binary-tree",
      "title": "Largest BST in Binary Tree",
      "category": "bst",
      "difficulty": "unknown",
      "problemStatement": "Given a binary tree. Find the size of its largest subtree that is a Binary Search Tree.\r\n\r\nExplanation:\r\n- We use a recursive function to traverse the binary tree in a bottom-up manner.\r\n- At each node, we check if the left and right subtrees are binary search trees.\r\n- If the current node satisfies the binary search tree condition (i.e., the value of the current node is greater than the maximum value in the left subtree and less than the minimum value in the right subtree), then we update the size of the largest subtree.\r\n- We return a triplet containing the size of the subtree, the minimum value in the subtree, and the maximum value in the subtree.\r\n\r\nTime Complexity:\r\n- The recursive function visits each node once, so the time complexity is O(n), where n is the number of nodes in the binary tree.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(h), where h is the height of the binary tree, as the recursion stack stores the nodes in the path from the root to the deepest leaf node.",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\12. Binary Search Trees\\2. Practice Problems\\12. Largest BST in Binary Tree.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-graphs": {
      "id": "count-the-number-of-graphs",
      "title": "Count the number of graphs",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Count the number of undirected graphs that can be formed with n vertices.",
      "approach": "-\r\n- calculate the number of edges with formula n*n-1/2\r\n- return pow(2,edges) \r\n\r\nComplexity Analysis:-\r\n\r\nTime Complexity = O(1)\r\nSpace Complexity = O(1)",
      "code": "",
      "complexity": {
        "time": {
          "average": "O(1)",
          "worst": "O(1)"
        },
        "space": {
          "average": "O(1) */",
          "worst": "O(1) */"
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\1. Learning\\01. Count the number of graphs.cpp",
      "verified": false,
      "needsReview": false
    },
    "graph-representation": {
      "id": "graph-representation",
      "title": "Graph Representation",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given the adjacency matrix representation of an undirected graph, your task is to return the adjacency list of the graph where each adjacency list contains the vertex itself at the first position and then all its adjacent nodes.\r\n\r\nExplanation:\r\n- We initialize an empty adjacency list vector of vectors.\r\n- For each vertex in the graph, we add the vertex itself as the first element of its adjacency list.\r\n- Then, for each edge (u, v) in the graph, we add v to the adjacency list of u and u to the adjacency list of v.\r\n- Finally, we return the adjacency list.\r\n\r\nTime Complexity:\r\n- The time complexity is O(m), where m is the number of edges in the graph, as we iterate through each edge once.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(n + 2 * m), where n is the number of vertices and 2 * m is the total number of elements in all adjacency lists, as each edge is represented twice (once in the adjacency list of u and once in the adjacency list of v).",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\1. Learning\\02. Graph Representation.cpp",
      "verified": false,
      "needsReview": true
    },
    "bfs": {
      "id": "bfs",
      "title": "BFS",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a directed graph, perform Breadth First Traversal (BFS) of the graph starting from vertex 0 and visit all the nodes directly or indirectly connected to Node 0.\r\n\r\nExplanation:\r\n- We initialize an empty vector 'ans' to store the BFS traversal.\r\n- We also initialize a vector 'vis' to keep track of visited nodes, initialized with 'false' for all nodes.\r\n- We use a queue 'q' to perform BFS. We start by pushing vertex 0 into the queue and mark it as visited.\r\n- While the queue is not empty, we pop the front element and add it to the 'ans' vector.\r\n- For each adjacent vertex of the current node, if it has not been visited, we push it into the queue and mark it as visited.\r\n- We continue this process until the queue becomes empty and all connected nodes are visited.\r\n- Finally, we return the 'ans' vector containing the BFS traversal.\r\n\r\nTime Complexity:\r\n- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we visit all the vertices and edges.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(V), where V is the number of vertices, as we use extra space for the 'vis' vector and the 'q' queue.",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\1. Learning\\03. BFS.cpp",
      "verified": false,
      "needsReview": true
    },
    "dfs": {
      "id": "dfs",
      "title": "DFS",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a connected undirected graph, perform Depth First Traversal (DFS) of the graph starting from vertex 0 and visit all the nodes directly or indirectly connected to Node 0.\r\n\r\nExplanation:\r\n- We initialize an empty vector 'ans' to store the DFS traversal.\r\n- We also initialize a vector 'vis' to keep track of visited nodes, initialized with 'false' for all nodes.\r\n- We start DFS from vertex 0 by calling the recursive function 'dfs'.\r\n- In the 'dfs' function, we push the current node into the 'ans' vector and mark it as visited.\r\n- For each adjacent vertex of the current node, if it has not been visited, we call the 'dfs' function recursively for that vertex.\r\n- We continue this process until all connected nodes are visited.\r\n- Finally, we return the 'ans' vector containing the DFS traversal.\r\n\r\nTime Complexity:\r\n- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we visit all the vertices and edges.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(V), where V is the number of vertices, as we use extra space for the 'vis' vector.",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\1. Learning\\04. DFS.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-the-number-of-provinces": {
      "id": "count-the-number-of-provinces",
      "title": "Count the number of provinces",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given an n x n matrix 'isConnected' representing connections between cities (nodes), find the total number of provinces in the graph.\r\n\r\nExplanation:\r\n- The problem can be solved using Depth First Search (DFS).\r\n- We first convert the given matrix 'isConnected' into an adjacency list 'adj' representing the graph.\r\n- We use a 'vis' vector to keep track of visited cities, initialized to 'false' for all cities.\r\n- We initialize a variable 'ans' to store the number of provinces.\r\n- We then perform DFS from each city and mark all directly or indirectly connected cities as visited.\r\n- We increment the 'ans' for each unvisited city and continue the process until all cities are visited.\r\n- Finally, we return the 'ans' which represents the total number of provinces in the graph.\r\n\r\nTime Complexity:\r\n- The time complexity is O(n^2), where n is the number of cities. We traverse the entire 'isConnected' matrix to construct the adjacency list.\r\n\r\nSpace Complexity:\r\n- The space complexity is O(n), where n is the number of cities. We use extra space for the adjacency list and the 'vis' vector.",
      "approach": "",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\01. Count the number of provinces.cpp",
      "verified": false,
      "needsReview": true
    },
    "rotten-oranges": {
      "id": "rotten-oranges",
      "title": "Rotten Oranges",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an m x n grid where each cell can have one of three values:\r\n\r\n0 representing an empty cell,\r\n1 representing a fresh orange, or\r\n2 representing a rotten orange.\r\n\r\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\r\n\r\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\r\n\r\nExample:\r\n\r\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\r\nOutput: 4",
      "approach": "1. Use Breadth-First Search (BFS) to rot the oranges.\r\n2. Initialize a queue to store the rotten oranges.\r\n3. Iterate through the grid to find the rotten oranges and count the number of fresh oranges.\r\n4. Perform BFS starting from each rotten orange and keep track of the time required to rot all the fresh oranges.\r\n5. For each level in BFS (each minute), check adjacent cells to a rotten orange and mark them as rotten if they contain a fresh orange. Decrease the fresh count and add the newly rotten oranges to the queue.\r\n6. Repeat this process until all fresh oranges are rotten or the queue is empty.\r\n7. Return the time required (minutes) if all fresh oranges are rotten, otherwise, return -1.\r\n\r\nTime Complexity: O(m * n) - where 'm' is the number of rows and 'n' is the number of columns in the grid.\r\nSpace Complexity: O(m * n) - due to the queue and the grid.\r\n\r\nCode:",
      "code": "*/\r\n\r\nint orangesRotting(vector<vector<int>>& grid) {\r\n    int ans = -1, fresh = 0, m = grid.size(), n = grid[0].size();\r\n    queue<pair<int, int>> q;\r\n\r\n    for(int i = 0; i < m; i++) {\r\n        for(int j = 0; j < n; j++) {\r\n            if(grid[i][j] == 2) {\r\n                q.push({i, j});\r\n            }\r\n            if(grid[i][j] == 1) {\r\n                fresh++;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(fresh == 0) {\r\n        return 0;\r\n    }\r\n\r\n    vector<int> dr = {-1, 1, 0, 0};\r\n    vector<int> dc = {0, 0, -1, 1};\r\n\r\n    while(!q.empty()) {\r\n        int k = q.size();\r\n        while(k--) {\r\n            auto p = q.front();\r\n            q.pop();\r\n            int x = p.first, y = p.second;\r\n\r\n            for(int i = 0; i < 4; i++) {\r\n                int nx = x + dr[i], ny = y + dc[i];\r\n                if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {\r\n                    grid[nx][ny] = 2;\r\n                    q.push({nx, ny});\r\n                    fresh--;\r\n                }\r\n            }\r\n        }\r\n        ans++;\r\n    }\r\n\r\n    return (fresh > 0) ? -1 : ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<int>",
        "vector<int>",
        "queue<pair<int, int>",
        "for(int i = 0; i < m; i++)",
        "for(int j = 0; j < n; j++)",
        "for(int i = 0; i < 4; i++)",
        "while(!q.empty()",
        "while(k--)",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\02. Rotten Oranges.cpp",
      "verified": false,
      "needsReview": true
    },
    "flood-fill-algorithm": {
      "id": "flood-fill-algorithm",
      "title": "Flood-Fill Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\r\n\r\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\r\n\r\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\r\n\r\nReturn the modified image after performing the flood fill.\r\n\r\nExample:\r\n\r\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\r\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\r\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\r\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\r\n\r\nCODE:",
      "approach": "",
      "code": "*/\r\n\r\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\r\n    vector<vector<int>> ans(image.begin(), image.end());\r\n    int m = image.size(), n = image[0].size();\r\n    queue<pair<int, int>> q;\r\n    q.push({sr, sc});\r\n    int s = ans[sr][sc];\r\n    ans[sr][sc] = color;\r\n\r\n    vector<int> dr = {-1, 1, 0, 0};\r\n    vector<int> dc = {0, 0, -1, 1};\r\n\r\n    while (!q.empty()) {\r\n        int siz = q.size();\r\n        while (siz--) {\r\n            auto p = q.front();\r\n            q.pop();\r\n            int x = p.first, y = p.second;\r\n            for (int i = 0; i < 4; i++) {\r\n                int nx = x + dr[i], ny = y + dc[i];\r\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && ans[nx][ny] == s && ans[nx][ny] != color) {\r\n                    ans[nx][ny] = color;\r\n                    q.push({nx, ny});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<vector<int>",
        "queue<pair<int, int>",
        "for (int i = 0; i < 4; i++)",
        "while (!q.empty()",
        "while (siz--)",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\03. Flood-Fill Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "detect-cycle-in-undirected-graph": {
      "id": "detect-cycle-in-undirected-graph",
      "title": "Detect Cycle in Undirected Graph",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not. Graph is in the form of adjacency list where adj[i] contains all the nodes ith node is having an edge with.",
      "approach": "- To check whether the graph contains a cycle or not, we can perform a Depth-First Search (DFS) traversal on the graph and keep track of the visited nodes.\r\n- During the DFS traversal, if we encounter a node that is already visited and is not the parent of the current node (indicating a back edge), then there is a cycle in the graph. We need to check this condition for every node in the graph.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we may need to visit all the vertices and edges of the graph.\r\n- Space Complexity: O(V), where V is the number of vertices. We use an additional array to keep track of visited nodes.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\04. Detect Cycle in Undirected Graph.cpp",
      "verified": false,
      "needsReview": true
    },
    "01-matrix": {
      "id": "01-matrix",
      "title": "01 Matrix",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\r\n\r\nThe distance between two adjacent cells is 1.",
      "approach": "- We can use a Breadth-First Search (BFS) traversal to find the distance of the nearest 0 for each cell.\r\n- First, we initialize the distance matrix with -1 for all cells.\r\n- Then, we iterate through the matrix and find all cells with the value 0. For each 0 cell found, we add it to the queue and set its distance to 0 in the distance matrix.\r\n- Next, we perform a BFS starting from the cells with 0. During the BFS, we update the distance of each cell from the nearest 0 cell and continue the BFS until all cells are visited.\r\n- Finally, we return the distance matrix.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix.\r\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the distance matrix and the queue during BFS.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "bfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\05. 01 Matrix.cpp",
      "verified": false,
      "needsReview": true
    },
    "surrounded-regions": {
      "id": "surrounded-regions",
      "title": "Surrounded Regions",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\r\n\r\nA region is captured by flipping all 'O's into 'X's in that surrounded region.",
      "approach": "- We can use Depth-First Search (DFS) to find all regions that are surrounded by 'X'.\r\n- First, we initialize a copy of the board called 'vis' to store the visited status of each cell.\r\n- Then, we perform a DFS starting from all border cells that have 'O's. During the DFS, we mark all connected 'O's as visited by changing them to a special character, such as '#', in the 'vis' matrix.\r\n- After performing DFS from border cells, all remaining '#'s in the 'vis' matrix represent regions that are not surrounded by 'X'.\r\n- Finally, we update the original board by flipping all remaining 'O's to 'X'.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.\r\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\06. Surrounded Regions.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-enclaves": {
      "id": "number-of-enclaves",
      "title": "Number of Enclaves",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\r\n\r\nA move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\r\n\r\nReturn the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.",
      "approach": "- We can use Depth-First Search (DFS) to mark all land cells connected to the boundary of the grid as uncountable (i.e., cells that we can walk off the boundary).\r\n- First, we initialize a copy of the grid called 'vis' to store the visited status of each cell.\r\n- Then, we perform DFS from all land cells located at the boundary of the grid. During the DFS, we mark all connected land cells as visited by changing their value to -1 in the 'vis' matrix.\r\n- After performing DFS from boundary cells, all remaining land cells in the 'vis' matrix represent cells that we cannot walk off the boundary of the grid.\r\n- Finally, we count the number of land cells in the 'vis' matrix and return the count as the result.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.\r\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\07. Number of Enclaves.cpp",
      "verified": false,
      "needsReview": true
    },
    "word-ladder": {
      "id": "word-ladder",
      "title": "Word Ladder",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\r\n1. Every adjacent pair of words differs by a single letter.\r\n2. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\r\n3. sk == endWord\r\n\r\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
      "approach": "- We can model this problem as a graph where each word is a node and there is an edge between two words if they differ by a single letter.\r\n- First, we create an adjacency list to represent the graph based on the given wordList. Two words are adjacent if they differ by one character.\r\n- Then, we use Breadth-First Search (BFS) to find the shortest transformation sequence from beginWord to endWord.\r\n- We start BFS from the beginWord and traverse the graph level by level, marking visited words to avoid revisiting them.\r\n- During the BFS, if we reach the endWord, we return the length of the transformation sequence.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(n^2 * m), where n is the size of wordList and m is the average length of the words in wordList. In the worst case, we may need to compare every pair of words in wordList to create the adjacency list.\r\n- Space Complexity: O(n^2), where n is the size of wordList. We use additional space for the adjacency list and the visited map.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "bfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\08. Word Ladder.cpp",
      "verified": false,
      "needsReview": true
    },
    "distinct-islands": {
      "id": "distinct-islands",
      "title": "Distinct Islands",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a boolean 2D matrix grid of size n * m. You have to find the number of distinct islands where a group of connected 1s (horizontally or vertically) forms an island. Two islands are considered to be distinct if and only if one island is not equal to another (not rotated or reflected).",
      "approach": "- We can model this problem as a graph where each group of connected 1s forms an island.\r\n- We can use Depth-First Search (DFS) to traverse the grid and identify each island.\r\n- During the DFS, we keep track of the path taken to traverse each island. The path can be represented as a string, where each character in the string represents the direction of movement during the DFS (U for Up, D for Down, R for Right, and L for Left).\r\n- We use a set to store the paths of all distinct islands. As sets store unique elements, we will have only unique paths in the set.\r\n- Finally, we return the size of the set, which gives us the number of distinct islands.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(n * m), where n is the number of rows and m is the number of columns in the grid. We visit each cell at most once during the DFS.\r\n- Space Complexity: O(n * m), where n is the number of rows and m is the number of columns in the grid. We use additional space to store the visited status of each cell and the paths of the islands in the set.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\10. Distinct Islands.cpp",
      "verified": false,
      "needsReview": true
    },
    "bipartite-graph": {
      "id": "bipartite-graph",
      "title": "Bipartite Graph",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\r\n1. There are no self-edges (graph[u] does not contain u).\r\n2. There are no parallel edges (graph[u] does not contain duplicate values).\r\n3. If v is in graph[u], then u is in graph[v] (the graph is undirected).\r\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\r\n\r\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.",
      "approach": "- We can use Depth-First Search (DFS) to color the nodes in the graph such that we can partition them into two sets A and B.\r\n- While performing the DFS, we use two colors: 1 and -1 to color the nodes. We start by coloring the first node with color 1.\r\n- For each uncolored node, we perform DFS and color its neighbors with the opposite color.\r\n- If we encounter a neighbor with the same color as the current node, the graph is not bipartite, and we return false.\r\n- If the DFS completes without any conflicts, we return true, indicating that the graph is bipartite.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(V + E), where V is the number of nodes (vertices) in the graph, and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.\r\n- Space Complexity: O(V), where V is the number of nodes (vertices) in the graph. We use additional space to store the colors of the nodes.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\11. Bipartite Graph.cpp",
      "verified": false,
      "needsReview": true
    },
    "detect-cycle-in-directed-graph": {
      "id": "detect-cycle-in-directed-graph",
      "title": "Detect Cycle in Directed Graph",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.",
      "approach": "- To check for cycles in a directed graph, we can use Depth-First Search (DFS) with backtracking.\r\n- During the DFS, we maintain a visited array to keep track of nodes that have been visited.\r\n- We perform DFS from each unvisited node to explore the graph and check for cycles.\r\n- If we encounter a node that is already visited in the current DFS traversal, it means we have found a cycle, and we return true.\r\n- If we complete the DFS for all nodes without finding any cycle, we return false.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.\r\n- Space Complexity: O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the visited status of the nodes.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking",
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\2. Traversal Problems\\12. Detect Cycle in Directed Graph.cpp",
      "verified": false,
      "needsReview": true
    },
    "topological-sorting": {
      "id": "topological-sorting",
      "title": "Topological Sorting",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a DAG (directed acyclic graph), print the Topological sorting of a given graph.",
      "approach": "- Topological sorting is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge u -> v, vertex u comes before v in the ordering.\r\n- To find the topological sorting, we can use Depth-First Search (DFS) with backtracking.\r\n- We perform DFS starting from each unvisited node, and as we finish exploring a node and backtrack, we add it to the front of the topological sorting order.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.\r\n- Space Complexity: O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the visited status of the nodes and the topological sorting order.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion",
        "backtracking",
        "dfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\01. Topological Sorting.cpp",
      "verified": false,
      "needsReview": true
    },
    "kahn-s-algorithm": {
      "id": "kahn-s-algorithm",
      "title": "Kahn's Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.",
      "approach": "- We can use Topological Sorting to check if a directed graph contains a cycle or not.\r\n- If a directed graph is a DAG (Directed Acyclic Graph), it means it does not contain any cycle.\r\n- So, to check for a cycle, we perform a variation of Topological Sorting using Kahn's algorithm, which is based on the concept of indegree.\r\n- If there is no cycle in the graph, we can always find a node with an indegree of 0 (no incoming edges) and remove it along with its outgoing edges.\r\n- We keep repeating this process, and if at any point we are unable to find a node with an indegree of 0, it means there is a cycle in the graph.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We perform a BFS-like traversal of all nodes and edges.\r\n- Space Complexity: O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the indegree of each node and the queue for BFS.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\02. Kahn's Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "course-scheduler-1": {
      "id": "course-scheduler-1",
      "title": "Course Scheduler 1",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\r\n\r\nReturn true if you can finish all courses. Otherwise, return false.",
      "approach": "- We can model the problem as a directed graph, where each course is a node, and a prerequisite pair [ai, bi] indicates a directed edge from course bi to course ai.\r\n- To check if we can finish all courses, we need to ensure that the directed graph is a DAG (Directed Acyclic Graph) with no cycles.\r\n- If there are cycles in the graph, it means there is a circular dependency between courses, and we cannot finish all courses in such cases.\r\n- To check for cycles, we can use Kahn's algorithm for Topological Sorting.\r\n- If we can perform a successful Topological Sort (i.e., there is no cycle), then it means we can finish all courses.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We perform a BFS-like traversal of all nodes and edges.\r\n- Space Complexity: O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We use additional space to store the adjacency list and indegree of each node.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\03. Course Scheduler 1.cpp",
      "verified": false,
      "needsReview": true
    },
    "course-scheduler-2": {
      "id": "course-scheduler-2",
      "title": "Course Scheduler 2",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\r\n\r\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
      "approach": "- We can model the problem as a directed graph, where each course is a node, and a prerequisite pair [ai, bi] indicates a directed edge from course bi to course ai.\r\n- To find the course ordering, we can use Kahn's algorithm for Topological Sorting.\r\n- If we can perform a successful Topological Sort, it means we can finish all courses, and the order in which we pop the nodes from the queue will give us the correct course order.\r\n- If there is a cycle in the graph (i.e., it is not possible to finish all courses), the algorithm will not be able to remove all nodes with indegree 0, and we will not get a valid course ordering.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We perform a BFS-like traversal of all nodes and edges.\r\n- Space Complexity: O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We use additional space to store the adjacency list and indegree of each node.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\04. Course Scheduler 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-eventual-safe-state": {
      "id": "find-eventual-safe-state",
      "title": "Find Eventual Safe State",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\r\n\r\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).",
      "approach": "- We are given a directed graph, and we need to find all the safe nodes.\r\n- A node is safe if every possible path starting from that node leads to a terminal node (or another safe node).\r\n- To solve this, we can use a reverse graph approach along with a topological sorting method.\r\n- We create a reverse adjacency list, where revadj[i] contains all the nodes from which there is a directed edge to node i (i.e., nodes that have an edge towards node i).\r\n- We also keep track of the outdegree of each node, which represents the number of outgoing edges from that node.\r\n- We then start with nodes that have an outdegree of 0 (i.e., terminal nodes) and perform a BFS-like traversal.\r\n- During the traversal, we keep reducing the outdegree of the nodes from which there is a directed edge to the current node.\r\n- If a node's outdegree becomes 0 during the traversal, we add it to the queue for further processing.\r\n- All the nodes that become terminal nodes during the traversal are safe nodes.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N + E), where N is the number of nodes, and E is the number of edges in the graph. We perform a BFS-like traversal of all nodes and edges.\r\n- Space Complexity: O(N + E), where N is the number of nodes, and E is the number of edges in the graph. We use additional space to store the reverse adjacency list and outdegree of each node.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\05. Find Eventual Safe State.cpp",
      "verified": false,
      "needsReview": true
    },
    "alien-dictonary": {
      "id": "alien-dictonary",
      "title": "Alien Dictonary",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a sorted dictionary of an alien language having N words and k starting alphabets of the standard dictionary. Find the order of characters in the alien language.",
      "approach": "- We are given a sorted dictionary of an alien language.\r\n- To find the order of characters in the alien language, we can use a directed graph approach along with topological sorting.\r\n- We create a directed graph where each node represents a character, and there is a directed edge from node 'a' to node 'b' if character 'a' comes before character 'b' in the alien language.\r\n- We also keep track of the indegree of each node, which represents the number of characters that come before it in the alien language.\r\n- We iterate through the dictionary and set the directed edges and indegrees accordingly.\r\n- We then start with the nodes having an indegree of 0 (i.e., the characters that come first in the alien language) and perform a BFS-like traversal.\r\n- During the traversal, we keep reducing the indegree of the nodes that come after the current node.\r\n- The characters that become terminal nodes (i.e., their indegree becomes 0) during the traversal are the characters that come last in the alien language.\r\n- We construct the order of characters based on the BFS traversal, and that will be the correct order of characters in the alien language.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N), where N is the number of words in the dictionary. We iterate through the dictionary once to set the directed edges and indegrees.\r\n- Space Complexity: O(K), where K is the number of starting alphabets in the standard dictionary. We use additional space to store the directed graph and indegrees.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "bfs",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\3. Topo Sort Problems\\06. Alien Dictonary.cpp",
      "verified": false,
      "needsReview": true
    },
    "shortest-path-in-undirected-graph-having-unit-distance": {
      "id": "shortest-path-in-undirected-graph-having-unit-distance",
      "title": "Shortest path in Undirected Graph having unit distance",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an undirected graph with unit weight. Find the shortest path from the source vertex to all other vertices, and if it is unreachable to reach any vertex, then return -1 for that vertex.",
      "approach": "- To find the shortest path from the source vertex to all other vertices, we can use a BFS traversal of the graph.\r\n- We create an adjacency list to represent the undirected graph.\r\n- We use a queue to perform the BFS traversal, starting from the source vertex.\r\n- During the BFS traversal, we keep track of the level (or distance) of each vertex from the source vertex.\r\n- We maintain a boolean array to keep track of visited vertices so that we don't visit the same vertex again.\r\n- If a vertex is reachable from the source vertex, its distance will be equal to the number of edges in the shortest path from the source vertex.\r\n- After the BFS traversal is complete, we will have the distance of each vertex from the source vertex.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N+M), where N is the number of vertices and M is the number of edges in the graph. We perform a BFS traversal, visiting each vertex and edge once.\r\n- Space Complexity: O(N), where N is the number of vertices. We use additional space to store the adjacency list, visited array, and the distance array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\01. Shortest path in Undirected Graph having unit distance.cpp",
      "verified": false,
      "needsReview": true
    },
    "shortest-path-in-dag": {
      "id": "shortest-path-in-dag",
      "title": "Shortest path in DAG",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a Directed Acyclic Graph of N vertices from 0 to N-1 and a 2D Integer array (or vector) edges[][] of length M, where there is a directed edge from edges[i][0] to edges[i][1] with a distance of edges[i][2] for all i.\r\n\r\nFind the shortest path from the source (vertex 0) to all other vertices, and if it is impossible to reach any vertex, then return -1 for that vertex.",
      "approach": "- To find the shortest path from the source vertex to all other vertices in a Directed Acyclic Graph (DAG), we can use a topological sorting based approach along with dynamic programming (DP).\r\n- First, we perform a topological sorting of the DAG. This will give us a linear order in which the vertices should be visited such that there are no backward edges.\r\n- After obtaining the topological order, we initialize the distance array with a large value (infinity) for all vertices, except the source vertex whose distance is set to 0.\r\n- We then iterate through the vertices in the topological order and update the distance for each vertex by considering all outgoing edges from that vertex and the distances of its neighboring vertices.\r\n- Since the graph is a DAG, we are guaranteed that we visit all the parent nodes of a vertex before visiting the vertex itself. Hence, we can safely update the distance of each vertex in a topological order.\r\n- After updating the distance array, if any vertex remains at the initial large value (infinity), it means that it is not reachable from the source vertex, and we set its distance to -1.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(N + M), where N is the number of vertices and M is the number of edges in the graph. The time complexity is dominated by the topological sorting and DP updates.\r\n- Space Complexity: O(N + M), where N is the number of vertices and M is the number of edges in the graph. We use additional space for the adjacency list, visited array, topological order, and the distance array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming",
        "sorting"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\02. Shortest path in DAG.cpp",
      "verified": false,
      "needsReview": true
    },
    "dijkstra-s-algorithm": {
      "id": "dijkstra-s-algorithm",
      "title": "Dijkstra's Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a weighted, undirected, and connected graph of V vertices and an adjacency list 'adj', where 'adj[i]' is a list of lists containing two integers where the first integer of each list j denotes there is an edge between node i and node j, and the second integer corresponds to the weight of that edge. You are also given the source vertex S. You need to find the shortest distance of all vertices from the source vertex S. You have to return a list of integers denoting the shortest distance between each node and the source vertex S.",
      "approach": "- We can use Dijkstra's algorithm to find the shortest distance from the source vertex to all other vertices in a weighted graph.\r\n- The algorithm maintains a priority queue (min-heap) to store the vertices based on their tentative distances from the source vertex. We start with the source vertex and update the distances of its neighbors, pushing them into the priority queue.\r\n- We continue this process until all vertices are visited and their distances are finalized. The priority queue ensures that we always pick the vertex with the minimum tentative distance for processing.\r\n- We initialize the distance array 'dis' with a large value (infinity) for all vertices, except the source vertex whose distance is set to 0.\r\n- We push the source vertex into the priority queue along with its distance, and then perform Dijkstra's algorithm.\r\n- After the algorithm completes, we have the shortest distances of all vertices from the source vertex in the 'dis' array.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Time Complexity: O(E + log(V)), where E is the number of edges and V is the number of vertices in the graph. The time complexity is dominated by the priority queue operations in Dijkstra's algorithm.\r\n- Space Complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph. We use additional space for the adjacency list, the distance array, and the priority queue.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "heap"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\03. Dijkstra's Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "shortest-path-in-binary-matrix": {
      "id": "shortest-path-in-binary-matrix",
      "title": "Shortest Path in binary matrix",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\r\n\r\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\r\n1. All the visited cells of the path are 0.\r\n2. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\r\n3. The length of a clear path is the number of visited cells of this path.\r\n\r\nExample:\r\nInput: grid = [[0,1],[1,0]]\r\nOutput: 2",
      "approach": "- We can use Breadth-First Search (BFS) to find the shortest path.\r\n- Start BFS from the top-left cell (0, 0) and explore its neighboring cells in 8 directions.\r\n- Mark the visited cells and continue BFS until reaching the bottom-right cell (n - 1, n - 1).\r\n- The number of levels traversed in BFS will represent the length of the shortest clear path.\r\n- If the bottom-right cell cannot be reached or there is no clear path, return -1.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of BFS is O(n^2) as it explores all cells in the n x n matrix.\r\n- The space complexity is also O(n^2) due to the usage of the queue and the visited matrix.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isValid(int x, int y, int n, vector<vector<bool>>& vis, vector<vector<int>>& grid) {\r\n    return (x >= 0 && x < n && y >= 0 && y < n && !vis[x][y] && grid[x][y] == 0);\r\n}\r\n\r\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\r\n    int n = grid.size();\r\n    if (grid[0][0] != 0 || grid[n - 1][n - 1] != 0) return -1;\r\n    \r\n    vector<vector<bool>> vis(n, vector<bool>(n));\r\n    queue<pair<int, int>> q;\r\n    q.push({0, 0});\r\n    vis[0][0] = true;\r\n    int lvl = 1;\r\n    \r\n    while (!q.empty()) {\r\n        int siz = q.size();\r\n        while (siz--) {\r\n            auto p = q.front();\r\n            q.pop();\r\n            int x = p.first, y = p.second;\r\n            if (x == n - 1 && y == n - 1) return lvl;\r\n            \r\n            for (int i = -1; i <= 1; i++) {\r\n                for (int j = -1; j <= 1; j++) {\r\n                    int nx = x + i, ny = y + j;\r\n                    if (isValid(nx, ny, n, vis, grid)) {\r\n                        q.push({nx, ny});\r\n                        vis[nx][ny] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        lvl++;\r\n    }\r\n    return -1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs"
      ],
      "fingerprint": [
        "vector<vector<bool>",
        "vector<vector<int>",
        "vector<vector<int>",
        "queue<pair<int, int>",
        "for (int i = -1; i <= 1; i++)",
        "for (int j = -1; j <= 1; j++)",
        "while (!q.empty()",
        "while (siz--)",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\04. Shortest Path in binary matrix.cpp",
      "verified": false,
      "needsReview": true
    },
    "path-with-minimum-effort": {
      "id": "path-with-minimum-effort",
      "title": "Path with minimum effort",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\r\n\r\nA route's effort is the maximum absolute difference in heights between two consecutive cells of the route.\r\n\r\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\r\n\r\nExample:\r\n\r\nInput: heights = [[1,2,2],[3,8,2],[5,3,5]]\r\nOutput: 2\r\nExplanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\r\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.",
      "approach": "- We can use Dijkstra's algorithm to find the minimum effort path from the top-left cell to the bottom-right cell.\r\n- We will maintain a priority queue to keep track of cells with the minimum effort needed.\r\n- Start from the top-left cell with effort 0 and explore neighboring cells in all four directions.\r\n- Calculate the effort required to move to a neighboring cell and update the effort if it is lower than the current value.\r\n- Continue this process until we reach the bottom-right cell.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- Since we are using Dijkstra's algorithm, the time complexity is O((N*M) * log(N*M)), where N is the number of rows and M is the number of columns in the 2D array.\r\n- The space complexity is O(N*M) to store the distance values.\r\n\r\nCODE:",
      "code": "*/\r\n\r\ntypedef pair<int, pair<int, int>> tri;\r\n\r\nint minimumEffortPath(vector<vector<int>>& heights) {\r\n    int n = heights.size(), m = heights[0].size();\r\n    vector<vector<int>> dis(n, vector<int>(m, 1e9));\r\n\r\n    priority_queue<tri, vector<tri>, greater<tri>> pq;\r\n    dis[0][0] = 0;\r\n    pq.push({0, {0, 0}});\r\n\r\n    vector<int> dr = {0, 0, 1, -1};\r\n    vector<int> dc = {1, -1, 0, 0};\r\n\r\n    int ans = INT_MIN;\r\n    while (!pq.empty()) {\r\n        tri t = pq.top();\r\n        pq.pop();\r\n        int x = t.second.first, y = t.second.second;\r\n        ans = max(ans, t.first);\r\n        if (x == n - 1 && y == m - 1) return ans;\r\n        for (int i = 0; i < 4; i++) {\r\n            int nx = x + dr[i], ny = y + dc[i];\r\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && (dis[nx][ny] > abs(heights[x][y] - heights[nx][ny]))) {\r\n                dis[nx][ny] = abs(heights[x][y] - heights[nx][ny]);\r\n                pq.push({dis[nx][ny], {nx, ny}});\r\n            }\r\n        }\r\n    }\r\n    return -1; // If the bottom-right cell cannot be reached\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "heap"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "priority_queue<tri, vector<tri>",
        "queue<tri, vector<tri>",
        "for (int i = 0; i < 4; i++)",
        "while (!pq.empty()",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\05. Path with minimum effort.cpp",
      "verified": false,
      "needsReview": true
    },
    "cheapest-flights-with-k-stops": {
      "id": "cheapest-flights-with-k-stops",
      "title": "Cheapest Flights with K stops",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\r\n\r\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\r\n\r\nExample:\r\n\r\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\r\nOutput: 700\r\nExplanation:\r\nThe graph is shown above.\r\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\r\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.",
      "approach": "- We can use Breadth-First Search (BFS) to find the cheapest price from the source to the destination with at most k stops.\r\n- We will create an adjacency list to represent the graph, where each node will have a list of neighboring nodes with their corresponding prices.\r\n- We will use a queue to perform BFS starting from the source node.\r\n- During BFS, we will keep track of the distance to each node and the number of stops made so far.\r\n- If we reach the destination node and the number of stops is less than or equal to k, we will update the minimum cost to reach the destination.\r\n- Continue BFS until we have explored all possible paths with at most k stops.\r\n- Return the minimum cost to reach the destination if it is reachable, otherwise return -1.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity is O(n*k) since we can have at most k stops and for each stop, we will explore all n nodes.\r\n- The space complexity is O(n) to store the distance values.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\r\n    vector<vector<pair<int, int>>> adj(n);\r\n    for (auto flight : flights) {\r\n        adj[flight[0]].push_back({flight[1], flight[2]});\r\n    }\r\n\r\n    queue<pair<int, int>> q;\r\n    q.push({src, 0});\r\n\r\n    vector<int> dis(n, 1e9);\r\n\r\n    int stops = 0;\r\n    while (!q.empty() && stops <= k) {\r\n        int size = q.size();\r\n        while (size--) {\r\n            auto [u, uwt] = q.front();\r\n            q.pop();\r\n            for (auto& [v, vwt] : adj[u]) {\r\n                if (vwt + uwt < dis[v]) {\r\n                    dis[v] = uwt + vwt;\r\n                    q.push({v, dis[v]});\r\n                }\r\n            }\r\n        }\r\n        stops++;\r\n    }\r\n    if (dis[dst] == 1e9)\r\n        return -1;\r\n    return dis[dst];\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "bfs",
        "heap"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<pair<int, int>",
        "vector<int>",
        "queue<pair<int, int>",
        "for (auto flight : flights)",
        "for (auto& [v, vwt] : adj[u])",
        "while (!q.empty()",
        "while (size--)",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\06. Cheapest Flights with K stops.cpp",
      "verified": false,
      "needsReview": true
    },
    "network-delay-time": {
      "id": "network-delay-time",
      "title": "Network Delay Time",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\r\n\r\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\r\n\r\nExample:\r\n\r\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\r\nOutput: 2",
      "approach": "- We can use Dijkstra's algorithm to find the minimum time it takes for all the nodes to receive the signal.\r\n- We will create an adjacency list to represent the graph, where each node will have a list of neighboring nodes with their corresponding signal travel time.\r\n- We will use a priority queue to perform Dijkstra's algorithm starting from the given node k.\r\n- During Dijkstra's algorithm, we will keep track of the minimum time to reach each node from the given node k.\r\n- Continue the algorithm until we have explored all nodes in the graph.\r\n- Return the maximum time among all the nodes' signal travel times, as this represents the minimum time it takes for all the nodes to receive the signal.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of Dijkstra's algorithm is O(E*log(V)), where E is the number of edges and V is the number of vertices.\r\n- The space complexity is O(V) to store the distance values.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint networkDelayTime(vector<vector<int>>& times, int n, int k) {\r\n    vector<pair<int, int>> adj[n + 1];\r\n    for (auto time : times) {\r\n        adj[time[0]].push_back({time[1], time[2]});\r\n    }\r\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\r\n    vector<int> dis(n + 1, 1e9);\r\n    dis[k] = 0;\r\n    pq.push({0, k});\r\n    while (!pq.empty()) {\r\n        auto [uwt, u] = pq.top();\r\n        pq.pop();\r\n        for (auto [v, vwt] : adj[u]) {\r\n            if (dis[v] > uwt + vwt) {\r\n                dis[v] = uwt + vwt;\r\n                pq.push({dis[v], v});\r\n            }\r\n        }\r\n    }\r\n    int ans = INT_MIN;\r\n    for (int i = 1; i <= n; i++) {\r\n        if (dis[i] == 1e9)\r\n            return -1;\r\n        ans = max(ans, dis[i]);\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<pair<int, int>",
        "vector<pair<int, int>",
        "priority_queue<pair<int, int>",
        "queue<pair<int, int>",
        "for (auto time : times)",
        "for (auto [v, vwt] : adj[u])",
        "for (int i = 1; i <= n; i++)",
        "while (!pq.empty()",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\07. Network Delay Time.cpp",
      "verified": false,
      "needsReview": true
    },
    "bellman-ford-algorithm": {
      "id": "bellman-ford-algorithm",
      "title": "Bellman Ford Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a weighted, directed and connected graph of V vertices and E edges, Find the shortest distance of all the vertex's from the source vertex S.\r\nNote: If the Graph contains a negative cycle then return an array consisting of only -1.\r\n\r\nExample:\r\n\r\nInput: E = [[0,1,5],[1,0,3],[1,2,-1],[2,0,1]], S = 2\r\nOutput: 1 6 0\r\nExplanation:\r\nFor nodes 2 to 0, we can follow the path - 2 -> 0. This has a distance of 1.\r\nFor nodes 2 to 1, we can follow the path - 2 -> 0 -> 1, which has a distance of 1 + 5 = 6.",
      "approach": "- We can use Bellman-Ford algorithm to find the shortest distance of all the nodes from the given source vertex S.\r\n- The Bellman-Ford algorithm can handle negative edge weights and identify negative cycles.\r\n- We will initialize an array dis to store the shortest distance of each node from the source vertex. Initialize all distances to a very large value except for the source vertex, which will have a distance of 0.\r\n- Run a loop for V-1 times (V is the number of vertices), and in each iteration, relax all the edges to minimize the distance.\r\n- If there is a negative cycle, the distance will keep decreasing in the Vth iteration as well. In this case, we will return an array containing only -1.\r\n- Otherwise, we return the dis array with the shortest distances of all nodes from the source vertex.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the Bellman-Ford algorithm is O(V*E), where V is the number of vertices and E is the number of edges.\r\n- The space complexity is O(V) to store the distance values.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nvector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {\r\n    vector<pair<int, int>> adj[V];\r\n    for (auto e : edges) {\r\n        adj[e[0]].push_back({e[1], e[2]});\r\n    }\r\n    vector<int> dis(V, 1e8);\r\n    dis[S] = 0;\r\n    for (int i = 0; i < V; i++) {\r\n        for (int u = 0; u < V; u++) {\r\n            for (auto vec : adj[u]) {\r\n                int v = vec.first, wt = vec.second;\r\n                if (dis[u] != 1e8)\r\n                    dis[v] = min(dis[v], dis[u] + wt);\r\n            }\r\n        }\r\n    }\r\n    for (int u = 0; u < V; u++) {\r\n        for (auto vec : adj[u]) {\r\n            int v = vec.first, wt = vec.second;\r\n            if (dis[u] != 1e8 && dis[v] > dis[u] + wt)\r\n                return {-1};\r\n        }\r\n    }\r\n    return dis;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<pair<int, int>",
        "for (auto e : edges)",
        "for (int i = 0; i < V; i++)",
        "for (int u = 0; u < V; u++)",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\08. Bellman Ford Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "floyd-warshall-algorithm": {
      "id": "floyd-warshall-algorithm",
      "title": "Floyd Warshall Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "The problem is to find the shortest distances between every pair of vertices in a given edge-weighted directed graph.\r\nThe graph is represented as an adjacency matrix of size n*n. Matrix[i][j] denotes the weight of the edge from i to j.\r\nIf Matrix[i][j] = -1, it means there is no edge from i to j.\r\n\r\nExample:\r\n\r\nInput: matrix = {{0, 25}, {-1, 0}}\r\n\r\nOutput: {{0, 25}, {-1, 0}}\r\n\r\nExplanation: The shortest distance between every pair is already given (if it exists).",
      "approach": "- We will first replace all the \"-1\" entries in the adjacency matrix with a very large value (e.g., 1e9) to represent that there is no edge between those vertices.\r\n- Then, we will apply the Floyd-Warshall algorithm to find the shortest distances between all pairs of vertices in the graph.\r\n- In each iteration, we will consider an intermediate vertex k and update the shortest distance between each pair (i, j) if the path i -> k -> j is shorter than the current distance i -> j.\r\n- After completing the algorithm, we will replace the entries with a very large value (e.g., 1e9) with -1 in the adjacency matrix to represent that there is no path between those vertices.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the Floyd-Warshall algorithm is O(V^3), where V is the number of vertices.\r\n- The space complexity is O(1) since we are modifying the input matrix in-place.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvoid shortest_distance(vector<vector<int>>& matrix) {\r\n    int v = matrix.size();\r\n\r\n    for (int i = 0; i < v; i++) {\r\n        for (int j = 0; j < v; j++) {\r\n            if (matrix[i][j] == -1)\r\n                matrix[i][j] = 1e9;\r\n        }\r\n    }\r\n\r\n    for (int k = 0; k < v; k++) {\r\n        for (int i = 0; i < v; i++) {\r\n            for (int j = 0; j < v; j++) {\r\n                if (i == j)\r\n                    matrix[i][j] = 0;\r\n                matrix[i][j] = min(matrix[i][j], (matrix[i][k] + matrix[k][j]));\r\n            }\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < v; i++) {\r\n        for (int j = 0; j < v; j++) {\r\n            if (matrix[i][j] == 1e9)\r\n                matrix[i][j] = -1;\r\n        }\r\n    }\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "for (int i = 0; i < v; i++)",
        "for (int j = 0; j < v; j++)",
        "for (int k = 0; k < v; k++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\09. Floyd Warshall Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-city-with-smallest-number-of-neighbours": {
      "id": "find-city-with-smallest-number-of-neighbours",
      "title": "Find city with smallest number of neighbours",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\r\n\r\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold. If there are multiple such cities, return the city with the greatest number.\r\n\r\nNotice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\r\n\r\nExample:\r\n\r\nInput: n = 4, edges = [[0, 1, 3], [1, 2, 1], [1, 3, 4], [2, 3, 1]], distanceThreshold = 4\r\nOutput: 3\r\nExplanation: The figure above describes the graph.\r\nThe neighboring cities at a distanceThreshold = 4 for each city are:\r\nCity 0 -> [City 1, City 2]\r\nCity 1 -> [City 0, City 2, City 3]\r\nCity 2 -> [City 0, City 1, City 3]\r\nCity 3 -> [City 1, City 2]\r\nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.",
      "approach": "- We will use Dijkstra's algorithm to find the shortest distances from each city to all other cities in the graph.\r\n- For each city, we will find the count of cities that are reachable through some path and whose distance is at most distanceThreshold.\r\n- We will keep track of this count for each city in a map.\r\n- Finally, we will find the city with the smallest count, and if there are multiple such cities, we will return the city with the greatest number.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of Dijkstra's algorithm is O(V^2), where V is the number of cities.\r\n- Since we perform Dijkstra's algorithm for each city, the overall time complexity is O(V^3).\r\n- The space complexity is O(V) for storing the distances and the count of reachable cities for each city.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\r\n    vector<pair<int, int>> adj[n];\r\n    for (auto e : edges) {\r\n        adj[e[0]].push_back({e[1], e[2]});\r\n        adj[e[1]].push_back({e[0], e[2]});\r\n    }\r\n\r\n    vector<int> dis(n, numeric_limits<int>::max());\r\n    unordered_map<int, int> mp;\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        dis[i] = 0;\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\r\n        pq.push({0, i});\r\n\r\n        while (!pq.empty()) {\r\n            auto [uwt, u] = pq.top();\r\n            pq.pop();\r\n\r\n            for (auto [v, vwt] : adj[u]) {\r\n                if (dis[v] > uwt + vwt) {\r\n                    dis[v] = uwt + vwt;\r\n                    pq.push({dis[v], v});\r\n                }\r\n            }\r\n        }\r\n\r\n        int nbrCnt = 0;\r\n        for (int j = 0; j < n; j++) {\r\n            if (i != j && dis[j] <= distanceThreshold)\r\n                nbrCnt++;\r\n            dis[j] = numeric_limits<int>::max();\r\n        }\r\n        mp[i] = nbrCnt;\r\n    }\r\n\r\n    int mini = numeric_limits<int>::max(), ans = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (mp[i] < mini) {\r\n            mini = mp[i];\r\n            ans = i;\r\n        } else if (mp[i] == mini)\r\n            ans = max(ans, i);\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "heap"
      ],
      "fingerprint": [
        "unordered_map<int, int>",
        "vector<vector<int>",
        "vector<pair<int, int>",
        "vector<int>",
        "priority_queue<pair<int, int>",
        "queue<pair<int, int>",
        "for (auto e : edges)",
        "for (int i = 0; i < n; i++)",
        "for (auto [v, vwt] : adj[u])",
        "while (!pq.empty()",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\10. Find city with smallest number of neighbours.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-ways-to-arrive-the-destination-with-minimum-distance": {
      "id": "number-of-ways-to-arrive-the-destination-with-minimum-distance",
      "title": "Number of ways to arrive the destination with minimum distance",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection, and that there is at most one road between any two intersections.\r\n\r\nYou are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\r\n\r\nReturn the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 10^9 + 7.",
      "approach": "1. We can use Dijkstra's algorithm to find the shortest path from intersection 0 to intersection n-1 and also keep track of the number of ways to reach each intersection in the shortest time.\r\n2. We start with intersection 0 and keep track of the minimum time required to reach each intersection.\r\n3. During the process, we also keep track of the number of ways to reach each intersection in the shortest time.\r\n4. If we find a shorter path to a particular intersection, we update its minimum time and reset the number of ways to reach that intersection to the number of ways to reach the previous intersection.\r\n5. If we find an equal time path to a particular intersection, we add the number of ways to reach the previous intersection to the number of ways to reach the current intersection.\r\n\r\nComplexity Analysis:\r\n- Let n be the number of intersections and E be the number of roads in the input.\r\n- Dijkstra's algorithm has a time complexity of O((n+E)log(n)) using a priority queue.\r\n- The space complexity is O(n) to store the distance and ways arrays.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\4. Shortest Path Problems\\11. Number of ways to arrive the destination with minimum distance.cpp",
      "verified": false,
      "needsReview": true
    },
    "prim-s-algorithm": {
      "id": "prim-s-algorithm",
      "title": "Prim's Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a weighted, undirected and connected graph of V vertices and E edges, the task is to find the sum of weights of the edges of the Minimum Spanning Tree.\r\n\r\nExample:\r\n\r\nInput: \r\n3 3\r\n0 1 5\r\n1 2 3\r\n0 2 1\r\n\r\nOutput:\r\n4\r\nExplanation:\r\n\r\nThe Spanning Tree resulting in a weight\r\nof 4 is shown above.",
      "approach": "- We will use Prim's algorithm to find the Minimum Spanning Tree (MST) of the graph.\r\n- The idea is to start from any vertex (let's say vertex 0) and add it to the MST.\r\n- Then, we will add the edges connected to vertex 0 to a priority queue (min-heap), where the edges are sorted based on their weights in ascending order.\r\n- We will keep adding the edges with the minimum weight to the MST and add their connected vertices to the priority queue if they are not already in the MST.\r\n- We will repeat this process until all vertices are added to the MST.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of Prim's algorithm is O(V^2) using an adjacency matrix representation, where V is the number of vertices.\r\n- If an adjacency list representation is used, the time complexity reduces to O(E + V log V), where E is the number of edges and log V is the time complexity of priority queue operations.\r\n- The space complexity is O(V) for the priority queue and other data structures.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint minimumSpanningTree(vector<vector<int>>& edges, int n) {\r\n    vector<pair<int, int>> adj[n];\r\n    for (auto e : edges) {\r\n        adj[e[0]].push_back({e[2], e[1]});\r\n        adj[e[1]].push_back({e[2], e[0]});\r\n    }\r\n\r\n    vector<bool> mst(n);\r\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\r\n    pq.push({0, 0});\r\n    int ans = 0;\r\n\r\n    while (!pq.empty()) {\r\n        auto node = pq.top();\r\n        int u = node.second, uwt = node.first;\r\n        pq.pop();\r\n\r\n        if (!mst[u]) {\r\n            mst[u] = true;\r\n            ans += uwt;\r\n\r\n            for (auto vec : adj[u]) {\r\n                int v = vec.second, vwt = vec.first;\r\n                if (!mst[v])\r\n                    pq.push({vwt, v});\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<pair<int, int>",
        "vector<bool>",
        "priority_queue<pair<int, int>",
        "queue<pair<int, int>",
        "for (auto e : edges)",
        "for (auto vec : adj[u])",
        "while (!pq.empty()",
        ".push_back(",
        ".push_back(",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\01. Prim's Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "kruskal-s-algorithm": {
      "id": "kruskal-s-algorithm",
      "title": "Kruskal's Algorithm",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a weighted, undirected and connected graph of V vertices and E edges, the task is to find the sum of weights of the edges of the Minimum Spanning Tree.\r\n\r\nExample:\r\n\r\nInput: \r\n3 3\r\n0 1 5\r\n1 2 3\r\n0 2 1\r\n\r\nOutput:\r\n4\r\nExplanation:\r\n\r\nThe Spanning Tree resulting in a weight\r\nof 4 is shown above.",
      "approach": "- We will use Kruskal's algorithm to find the Minimum Spanning Tree (MST) of the graph.\r\n- First, we will sort all the edges in non-decreasing order based on their weights.\r\n- Then, we will initialize a Disjoint Set data structure to keep track of connected components.\r\n- We will start adding edges one by one from the sorted list of edges to the MST.\r\n- Before adding an edge (u, v) to the MST, we will check if u and v belong to the same connected component using the Disjoint Set data structure. If they do not belong to the same connected component, we will add the edge to the MST and union the connected components of u and v.\r\n- We will repeat this process until all vertices are added to the MST.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of Kruskal's algorithm is O(E log E), where E is the number of edges, due to the sorting step.\r\n- The space complexity is O(V) for the Disjoint Set data structure and other data structures.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass DisjointSet {\r\n    vector<int> parent, size;\r\n\r\npublic:\r\n    DisjointSet(int n) {\r\n        parent.resize(n);\r\n        size.resize(n, 1);\r\n        for (int i = 0; i < n; i++)\r\n            parent[i] = i;\r\n    }\r\n\r\n    int findUParent(int node) {\r\n        if (parent[node] == node)\r\n            return node;\r\n        return parent[node] = findUParent(parent[node]);\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int uP = findUParent(u), vP = findUParent(v);\r\n        if (uP == vP)\r\n            return;\r\n        if (size[uP] > size[vP]) {\r\n            parent[vP] = uP;\r\n            size[uP] += size[vP];\r\n        } else {\r\n            parent[uP] = vP;\r\n            size[vP] += size[uP];\r\n        }\r\n    }\r\n};\r\n\r\nint minimumSpanningTree(vector<vector<int>>& edges, int n) {\r\n    DisjointSet djs(n);\r\n    sort(edges.begin(), edges.end());\r\n\r\n    int ans = 0;\r\n    for (auto e : edges) {\r\n        int wt = e[0], u = e[1], v = e[2];\r\n        if (djs.findUParent(u) != djs.findUParent(v)) {\r\n            ans += wt;\r\n            djs.unionBySize(u, v);\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "union-find",
        "sorting"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (auto e : edges)",
        "sort("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\02. Kruskal's Algorithm.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-operations-to-make-network": {
      "id": "number-of-operations-to-make-network",
      "title": "Number of Operations to make Network",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.\r\n\r\nYou are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\r\n\r\nReturn the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.",
      "approach": "- We can use the Disjoint Set data structure to keep track of connected components and find the minimum number of times we need to add connections.\r\n- If the number of connections is less than n - 1 (number of computers minus one), it means the network is disconnected, and we cannot make all the computers connected. In this case, we return -1.\r\n- Otherwise, we initialize a Disjoint Set data structure with n nodes representing each computer.\r\n- We iterate through the given connections and union the connected components of each pair of computers using the Disjoint Set data structure.\r\n- After this, we count the number of disconnected components using the findUPar function of the Disjoint Set data structure.\r\n- The minimum number of times we need to add connections to make all computers connected is the number of disconnected components minus one.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(E + V), where E is the number of connections and V is the number of computers. The log V factor is due to the unionBySize operation in the Disjoint Set data structure.\r\n- The space complexity is O(V) for the Disjoint Set data structure and other data structures.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass DisjointSet {\r\n    vector<int> parent, size;\r\n\r\npublic:\r\n    DisjointSet(int n) {\r\n        parent.resize(n);\r\n        size.resize(n, 1);\r\n        for (int i = 0; i < n; i++)\r\n            parent[i] = i;\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (parent[node] == node)\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int uP = findUPar(u), vP = findUPar(v);\r\n        int uPSize = size[uP], vPSize = size[vP];\r\n        if (uPSize > vPSize) {\r\n            parent[vP] = uP;\r\n            size[uP] += vPSize;\r\n        } else {\r\n            parent[uP] = vP;\r\n            size[vP] += uPSize;\r\n        }\r\n    }\r\n\r\n    int disconnected(int n) {\r\n        int cnt = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (parent[i] == i)\r\n                cnt++;\r\n        }\r\n        return cnt;\r\n    }\r\n};\r\n\r\nint makeConnected(int n, vector<vector<int>>& connections) {\r\n    if (n - 1 > connections.size())\r\n        return -1;\r\n\r\n    DisjointSet djs(n);\r\n    for (auto c : connections) {\r\n        int u = c[0], v = c[1];\r\n        if (djs.findUPar(u) != djs.findUPar(v))\r\n            djs.unionBySize(u, v);\r\n    }\r\n\r\n    int ans = djs.disconnected(n);\r\n    return ans - 1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "union-find"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int i = 0; i < n; i++)",
        "for (auto c : connections)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\03. Number of Operations to make Network.cpp",
      "verified": false,
      "needsReview": true
    },
    "most-stones-removed": {
      "id": "most-stones-removed",
      "title": "Most stones removed",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\r\n\r\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\r\n\r\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\r\n\r\nExample 1:\r\n\r\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\r\nOutput: 5\r\nExplanation: One way to remove 5 stones is as follows:\r\n1. Remove stone [2,2] because it shares the same row as [2,1].\r\n2. Remove stone [2,1] because it shares the same column as [0,1].\r\n3. Remove stone [1,2] because it shares the same row as [1,0].\r\n4. Remove stone [1,0] because it shares the same column as [0,0].\r\n5. Remove stone [0,1] because it shares the same row as [0,0].\r\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.",
      "approach": "To solve this problem, we can use the Disjoint Set data structure to group stones that share the same row or column.\r\n- First, we find the minimum and maximum row and column values to calculate the size of the grid.\r\n- Then, we iterate through the stones and perform the union operation for stones that share the same row or column.\r\n- Finally, we count the number of disjoint sets and subtract it from the total number of stones to get the maximum number of stones that can be removed.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\nLet n be the number of stones and m be the size of the grid.\r\n\r\n- Building the Disjoint Set: O(n)\r\n- Finding the number of disjoint sets: O(n)\r\n- Overall Time Complexity: O(n)\r\n- Space Complexity: O(n) for the Disjoint Set data structure",
      "code": "*/\r\n\r\n\r\nclass DisjointSet {\r\n    vector<int> parent, size;\r\n\r\npublic:\r\n    DisjointSet(int n) {\r\n        size.resize(n, 1);\r\n        parent.resize(n);\r\n        for (int i = 0; i < n; i++)\r\n            parent[i] = i;\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (parent[node] == node)\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int uP = findUPar(u), vP = findUPar(v);\r\n        int uSize = size[uP], vSize = size[vP];\r\n        if (uP == vP)\r\n            return;\r\n        if (uSize > vSize) {\r\n            parent[vP] = uP;\r\n            size[uP] += vSize;\r\n        } else {\r\n            parent[uP] = vP;\r\n            size[vP] += uSize;\r\n        }\r\n    }\r\n\r\n    int countComponents(int n) {\r\n        int cnt = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (parent[i] == i)\r\n                cnt++;\r\n        }\r\n        return cnt;\r\n    }\r\n};\r\n\r\nint makeConnected(int n, vector<vector<int>>& connections) {\r\n    if (n - 1 > connections.size())\r\n        return -1;\r\n\r\n    DisjointSet djs(n);\r\n    for (auto c : connections) {\r\n        int u = c[0], v = c[1];\r\n        if (djs.findUPar(u) != djs.findUPar(v))\r\n            djs.unionBySize(u, v);\r\n    }\r\n\r\n    int components = djs.countComponents(n);\r\n    return components - 1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "union-find"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int i = 0; i < n; i++)",
        "for (auto c : connections)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\04. Most stones removed.cpp",
      "verified": false,
      "needsReview": true
    },
    "account-merge": {
      "id": "account-merge",
      "title": "Account Merge",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\r\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\r\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.",
      "approach": "1. We use a disjoint-set data structure to group accounts that belong to the same person based on their common emails.\r\n2. Create a disjoint-set and an unordered map to store email to account index mapping.\r\n3. Iterate through the list of accounts, for each account, iterate through its emails, and add them to the unordered map with the corresponding account index as the value.\r\n4. Iterate through the unordered map and union accounts that share common emails using the disjoint-set.\r\n5. Create a set for each group of accounts and add the emails of each account to the corresponding set.\r\n6. Iterate through the disjoint-set and create the final merged accounts list by grouping emails for each account based on their root in the disjoint-set.\r\n\r\nComplexity Analysis:\r\n- Let n be the number of accounts and m be the average number of emails per account.\r\n- The time complexity of this approach is O(n*m*α(n)), where α(n) is the inverse Ackermann function, which grows very slowly and is nearly constant.\r\n- The space complexity is O(n*m) to store the emails and their corresponding account indices in the unordered map, and O(n*m) to store the merged accounts in the final result.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\05. Account Merge.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-islands-2": {
      "id": "number-of-islands-2",
      "title": "Number of islands 2",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an n x m 2D matrix, and an array of size k denoting the number of operations. The matrix elements are 0 if there is water or 1 if there is land. Originally, the 2D matrix is all 0, which means there is no land in the matrix. The array has k operator(s) and each operator has two integers A[i][0], A[i][1], which means that you can change the cell matrix[A[i][0]][A[i][1]] from sea to an island. Return how many islands are there in the matrix after each operation. You need to return an array of size k.\r\nNote: An island means a group of 1s such that they share a common side.\r\n\r\nExample 1:\r\nInput: n = 4, m = 5, k = 4, A = {{1,1},{0,1},{3,3},{3,4}}\r\nOutput: 1 1 2 2\r\nExplanation:\r\n0.  00000\r\n    00000\r\n    00000\r\n    00000\r\n1.  00000\r\n    01000\r\n    00000\r\n    00000\r\n2.  01000\r\n    01000\r\n    00000\r\n    00000\r\n3.  01000\r\n    01000\r\n    00000\r\n    00010\r\n4.  01000\r\n    01000\r\n    00000\r\n    00011",
      "approach": "1. Create a disjoint set to represent islands.\r\n2. Initialize an empty grid to track the islands.\r\n3. For each operation (i.e., changing sea to land), do the following:\r\n   a. If the cell is not already land, mark it as land and increment the island count.\r\n   b. For the neighboring cells that are land, check if they belong to the same island or not.\r\n      - If they don't belong to the same island, union the sets and decrement the island count.\r\n4. Return the island count after each operation as the result.\r\n\r\nComplexity Analysis:\r\n- The time complexity of each operation is O(4 * alpha(n*m)) due to the union operation, where alpha(n*m) is the inverse Ackermann function.\r\n- Since there are k operations, the overall time complexity is O(k * alpha(n*m)).\r\n- The space complexity is O(n*m) for storing the grid and the disjoint set.",
      "code": "*/\r\n\r\nclass DisjointSet {\r\n    vector<int> parent, size;\r\n\r\npublic:\r\n    DisjointSet(int n) {\r\n        size.resize(n, 1);\r\n        parent.resize(n);\r\n        for (int i = 0; i < n; i++) parent[i] = i;\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (parent[node] == node) return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionSize(int u, int v) {\r\n        int up = findUPar(u), vp = findUPar(v);\r\n        int us = size[up], vs = size[vp];\r\n        if (us > vs) {\r\n            parent[vp] = up;\r\n            size[up] += vs;\r\n        } else {\r\n            parent[up] = vp;\r\n            size[vp] += us;\r\n        }\r\n    }\r\n};\r\n\r\nbool isLand(int x, int y, vector<vector<int>>& grid) {\r\n    return (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == 1);\r\n}\r\n\r\nvector<int> numOfIslands(int n, int m, vector<vector<int>>& operators) {\r\n    vector<int> ans;\r\n    int islands = 0;\r\n    DisjointSet djs(n * m);\r\n    vector<vector<int>> grid(n, vector<int>(m, 0));\r\n\r\n    vector<int> dr = { -1, 1, 0, 0 };\r\n    vector<int> dc = { 0, 0, -1, 1 };\r\n\r\n    for (auto op : operators) {\r\n        int x = op[0], y = op[1];\r\n        if (grid[x][y] != 1) {\r\n            grid[x][y] = 1;\r\n            islands++;\r\n            int id = x * m + y;\r\n            for (int i = 0; i < 4; i++) {\r\n                int nx = x + dr[i], ny = y + dc[i];\r\n                if (isLand(nx, ny, grid)) {\r\n                    int nid = nx * m + ny;\r\n                    if (djs.findUPar(id) != djs.findUPar(nid)) {\r\n                        djs.unionSize(id, nid);\r\n                        islands--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ans.push_back(islands);\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "union-find"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (auto op : operators)",
        "for (int i = 0; i < 4; i++)",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\06. Number of islands 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "making-large-island": {
      "id": "making-large-island",
      "title": "Making Large Island",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\r\nReturn the size of the largest island in grid after applying this operation.\r\nAn island is a 4-directionally connected group of 1s.",
      "approach": "1. Create a disjoint set to represent islands and initialize it with all cells.\r\n2. For each 1 cell, union it with its 4-directionally connected 1 cells in the disjoint set.\r\n3. Then, traverse the grid to find each 0 cell and count the size of connected islands that can be formed by changing this 0 to 1.\r\n4. Update the answer with the maximum island size found so far.\r\n5. Return the maximum island size.\r\n\r\nComplexity Analysis:\r\n- The time complexity of creating the disjoint set is O(n^2) as we need to initialize it with all cells.\r\n- The time complexity of the first pass (connecting 1 cells) is also O(n^2) as we traverse the entire grid once.\r\n- The time complexity of the second pass (counting island size for 0 cells) is O(n^2) as we again traverse the entire grid.\r\n- The time complexity of finding the maximum island size using the disjoint set is O(n^2) as we iterate through all cells.\r\n- Overall, the time complexity of the solution is O(n^2).\r\n- The space complexity is O(n^2) due to the disjoint set data structure.",
      "code": "*/\r\n\r\nclass DisjointSet {\r\npublic:\r\n    vector<int> parent, size;\r\n\r\n    DisjointSet(int n) {\r\n        size.resize(n, 1);\r\n        parent.resize(n);\r\n        for (int i = 0; i < n; i++)\r\n            parent[i] = i;\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (parent[node] == node)\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int uP = findUPar(u), vP = findUPar(v);\r\n        int uSize = size[uP], vSize = size[vP];\r\n        if (uSize > vSize) {\r\n            parent[vP] = uP;\r\n            size[uP] += vSize;\r\n        } else {\r\n            parent[uP] = vP;\r\n            size[vP] += uSize;\r\n        }\r\n    }\r\n};\r\n\r\nbool isLand(int i, int j, vector<vector<int>>& grid){\r\n    return (i >= 0 && i < grid.size() && j >= 0 && j < grid.size() && grid[i][j] == 1);\r\n}\r\n\r\nint largestIsland(vector<vector<int>>& grid) {\r\n    int n = grid.size();\r\n\r\n    vector<int> dr = {1, -1, 0, 0};\r\n    vector<int> dc = {0, 0, 1, -1};\r\n\r\n    DisjointSet djs(n * n);\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            if (grid[i][j] == 1) {\r\n                int id = i * n + j;\r\n                for (int d = 0; d < 4; d++) {\r\n                    int ni = i + dr[d], nj = j + dc[d];\r\n                    if (isLand(ni, nj, grid)) {\r\n                        int nid = ni * n + nj;\r\n                        if (djs.findUPar(id) != djs.findUPar(nid))\r\n                            djs.unionBySize(id, nid);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int ans = INT_MIN;\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            if (grid[i][j] == 0) {\r\n                unordered_set<int> st;\r\n                for (int d = 0; d < 4; d++) {\r\n                    int ni = i + dr[d], nj = j + dc[d];\r\n                    if (isLand(ni, nj, grid)) {\r\n                        int nid = ni * n + nj;\r\n                        st.insert(djs.findUPar(nid));\r\n                    }\r\n                }\r\n                int siz = 0;\r\n                for (auto u : st)\r\n                    siz += djs.size[u];\r\n                ans = max(ans, siz + 1);\r\n            }\r\n        }\r\n    }\r\n    for (int cellNo = 0; cellNo < n * n; cellNo++) {\r\n        ans = max(ans, djs.size[djs.findUPar(cellNo)]);\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "union-find"
      ],
      "fingerprint": [
        "unordered_set<int>",
        "vector<int>",
        "vector<vector<int>",
        "vector<vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int i = 0; i < n; i++)",
        "for (int j = 0; j < n; j++)",
        ".insert("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\07. Making Large Island.cpp",
      "verified": false,
      "needsReview": true
    },
    "swim-in-rising-water": {
      "id": "swim-in-rising-water",
      "title": "Swim in rising water",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\r\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\r\n\r\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
      "approach": "1. We use a priority queue (min heap) to keep track of the cells in increasing order of their elevations.\r\n2. Start from the top left cell (0, 0) and add it to the priority queue with its elevation as the key.\r\n3. Mark this cell as visited.\r\n4. While the priority queue is not empty, pop the cell with the minimum elevation.\r\n5. Update the answer with the maximum of the current elevation and the answer so far.\r\n6. Check the 4-directionally adjacent cells of the current cell.\r\n7. If the adjacent cell is within the boundaries and not visited, add it to the priority queue with its elevation as the key.\r\n8. Mark the adjacent cell as visited.\r\n9. Continue the process until we reach the bottom right cell (n-1, n-1).\r\n10. The answer at this point will be the least time until we can reach the bottom right cell.\r\n\r\nComplexity Analysis:\r\n- We need to visit all cells of the grid, so the time complexity of the solution is O(n^2).\r\n- We use a priority queue to store at most n^2 cells, so the space complexity is also O(n^2).",
      "code": "*/\r\n\r\ntypedef pair<int, pair<int, int>> dup;\r\n\r\nint swimInWater(vector<vector<int>>& grid) {\r\n    int n = grid.size();\r\n\r\n    vector<vector<bool>> vis(n, vector<bool>(n));\r\n    priority_queue<dup, vector<dup>, greater<dup>> pq;\r\n    pq.push({grid[0][0], {0, 0}});\r\n    vis[0][0] = true;\r\n\r\n    vector<int> dr = {-1, 1, 0, 0};\r\n    vector<int> dc = {0, 0, -1, 1};\r\n\r\n    int ans = 0;\r\n\r\n    while (!pq.empty()) {\r\n        auto [uwt, cord] = pq.top();\r\n        pq.pop();\r\n        int x = cord.first, y = cord.second;\r\n        ans = max(ans, uwt);\r\n        if (x == n - 1 && y == n - 1) return ans;\r\n        for (int i = 0; i < 4; i++) {\r\n            int nx = x + dr[i], ny = y + dc[i];\r\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny]) {\r\n                vis[nx][ny] = true;\r\n                pq.push({grid[nx][ny], {nx, ny}});\r\n            }\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "heap"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<bool>",
        "vector<bool>",
        "priority_queue<dup, vector<dup>",
        "queue<dup, vector<dup>",
        "for (int i = 0; i < 4; i++)",
        "while (!pq.empty()",
        ".push(",
        ".push(",
        ".pop("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\5. MST Problems\\08. Swim in rising water.cpp",
      "verified": false,
      "needsReview": true
    },
    "bridges-in-graph": {
      "id": "bridges-in-graph",
      "title": "Bridges in graph",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\r\nA critical connection is a connection that, if removed, will make some servers unable to reach some other server.\r\nReturn all critical connections in the network in any order.",
      "approach": "1. We can use Tarjan's algorithm to find the critical connections in the network.\r\n2. Tarjan's algorithm is used to find bridges in an undirected graph, which are exactly the critical connections.\r\n3. We perform a depth-first search (DFS) on the graph and keep track of the timestamp (time) when each node is visited.\r\n4. We also maintain two arrays, tin and low, to store the timestamp of each node and the lowest timestamp reachable from the node using a back edge or a cross edge, respectively.\r\n5. During the DFS, if we encounter an edge (u, v) such that low[v] > tin[u], it means the edge (u, v) is a critical connection (bridge).\r\n6. We add all such critical connections to the result.\r\n\r\nComplexity Analysis:\r\n- Let n be the number of servers and m be the number of connections in the network.\r\n- The time complexity of this approach is O(n + m) since we perform a single DFS on the graph.\r\n- The space complexity is O(n + m) to store the graph adjacency list and O(n) for the auxiliary arrays.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\6. Other Algorithms\\01. Bridges in graph.cpp",
      "verified": false,
      "needsReview": true
    },
    "strongly-connected-components": {
      "id": "strongly-connected-components",
      "title": "Strongly Connected Components",
      "category": "graphs",
      "difficulty": "unknown",
      "problemStatement": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, Find the number of strongly connected components in the graph.",
      "approach": "1. We can use Kosaraju's algorithm to find the number of strongly connected components (SCCs) in a directed graph.\r\n2. Kosaraju's algorithm performs two DFS traversal on the graph to find SCCs.\r\n3. In the first DFS traversal, we find the order of vertices in which they finish their DFS traversal (topological ordering).\r\n4. In the second DFS traversal, we visit the vertices in reverse order of their finish times (based on the first DFS traversal) and mark the SCCs.\r\n5. The number of SCCs will be the number of times we perform the second DFS traversal and find a new SCC.\r\n\r\nComplexity Analysis:\r\n- Let V be the number of vertices and E be the number of edges in the directed graph.\r\n- The time complexity of Kosaraju's algorithm is O(V + E) as we perform two DFS traversals.\r\n- The space complexity is O(V + E) to store the adjacency list and O(V) for the auxiliary arrays.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dfs"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\13. Graphs\\6. Other Algorithms\\02. Strongly Connected Components.cpp",
      "verified": false,
      "needsReview": true
    },
    "find-the-nth-fibonacci-number": {
      "id": "find-the-nth-fibonacci-number",
      "title": "Find the nth fibonacci number",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Find the nth fibonacci number.",
      "approach": "1. We can use dynamic programming to calculate the nth Fibonacci number.\r\n2. We define a helper function fibo(n, dp) that calculates the nth Fibonacci number using memoization.\r\n3. The function checks if the nth Fibonacci number is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the nth Fibonacci number by recursively calling fibo(n-1, dp) and fibo(n-2, dp) and stores the result in dp.\r\n5. The base cases are when n is 0 or 1, in which case the function returns n.\r\n6. In the main function, we take the input for n and create a dp array of size n+1 initialized with -1.\r\n7. We then call the fibo function passing n and the dp array as arguments.\r\n8. Finally, we print the value of dp[n], which represents the nth Fibonacci number.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fibo function is O(n) because we are calculating and storing the Fibonacci numbers from 0 to n.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\1. Intro to DP\\01. Find the nth fibonacci number.cpp",
      "verified": false,
      "needsReview": true
    },
    "climbing-stairs": {
      "id": "climbing-stairs",
      "title": "Climbing Stairs",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are climbing a staircase. It takes n steps to reach the top.\r\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "approach": "1. We can use dynamic programming with memoization to calculate the number of distinct ways to climb the staircase.\r\n2. We define a helper function fmemo(n, dp) that calculates the number of distinct ways to climb n steps using memoization.\r\n3. The function checks if the number of ways to climb n steps is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the number of ways to climb n steps by recursively calling fmemo(n-1, dp) and fmemo(n-2, dp) and stores the result in dp.\r\n5. The base cases are when n is 1 or 2, in which case the function returns n.\r\n6. In the main function climbStairs(n), we check if n is 1 or 2. If yes, we directly return n as the number of distinct ways to climb.\r\n7. Otherwise, we create a dp array of size n+1 initialized with -1 and call the fmemo function passing n and the dp array as arguments.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n) because we are calculating and storing the number of ways to climb n steps.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\2. 1D DP\\01. Climbing Stairs.cpp",
      "verified": false,
      "needsReview": true
    },
    "frog-jump": {
      "id": "frog-jump",
      "title": "Frog Jump",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Geek wants to climb from the 0th stair to the (n-1)th stair. At a time, the Geek can climb either one or two steps.\r\nA height[N] array is also given. Whenever the geek jumps from stair i to stair j, the energy consumed in the jump is abs(height[i] - height[j]), where abs() means the absolute difference.\r\nReturn the minimum energy that can be used by the Geek to jump from stair 0 to stair N-1.",
      "approach": "1. We can use dynamic programming with memoization to find the minimum energy required to jump from the 0th stair to the (n-1)th stair.\r\n2. We define a helper function fmemo(i, h, dp) that calculates the minimum energy required to jump from the 0th stair to the ith stair using memoization.\r\n3. The function checks if the minimum energy for the ith stair is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the minimum energy by taking two possible jumps - either from (i-1)th stair or from (i-2)th stair - and stores the result in dp[i].\r\n5. The base case is when i is 0, in which case the function returns 0 as the Geek is already at the 0th stair.\r\n6. In the main function minimumEnergy(height, n), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last stair), the height array, and the dp array as arguments.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n) because we are calculating and storing the minimum energy for each stair.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\2. 1D DP\\02. Frog Jump.cpp",
      "verified": false,
      "needsReview": true
    },
    "frog-k-jumps": {
      "id": "frog-k-jumps",
      "title": "Frog K Jumps",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Geek wants to climb from the 0th stair to the (n-1)th stair. At a time, the Geek can climb k steps.\r\nA height[N] array is also given. Whenever the geek jumps from stair i to stair j, the energy consumed in the jump is abs(height[i] - height[j]), where abs() means the absolute difference.\r\nReturn the minimum energy that can be used by the Geek to jump from stair 0 to stair N-1.\r\n\r\nExample:\r\nInput:\r\n4 2\r\n10 40 30 10\r\nOutput:\r\n40\r\n\r\nExplanation:\r\nFor 'n' = 4, 'k' = 2, height = {10, 40, 30, 10}\r\n\r\nInitially, we are present at stone 1 having height 10. We can reach stone 3 as 'k' is 2. So, the cost incurred is |10 - 30| = 20.\r\n\r\nNow, we are present at stone 3, we can reach stone 4 as 'k' is 2. So, the cost incurred is |30 - 10| = 20. So, the total cost is 40. We can show any other path will lead to greater cost.",
      "approach": "1. We can use dynamic programming with memoization to find the minimum energy required to jump from the 0th stair to the (n-1)th stair.\r\n2. We define a helper function fmemo(i, k, h, dp) that calculates the minimum energy required to jump from the 0th stair to the ith stair using memoization.\r\n3. The function checks if the minimum energy for the ith stair is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the minimum energy by considering all possible jumps from i-j (where j varies from 1 to k) and stores the result in dp[i].\r\n5. The base case is when i is 0, in which case the function returns 0 as the Geek is already at the 0th stair.\r\n6. In the main function minimizeCost(n, k, height), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last stair), k, the height array, and the dp array as arguments.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n*k) because we are calculating and storing the minimum energy for each stair and considering k possible jumps at each stair.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\2. 1D DP\\03. Frog K Jumps.cpp",
      "verified": false,
      "needsReview": true
    },
    "house-robber": {
      "id": "house-robber",
      "title": "House Robber",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nExample 1:\r\nInput: nums = [1,2,3,1]\r\nOutput: 4\r\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\r\nTotal amount you can rob = 1 + 3 = 4.",
      "approach": "1. We can use dynamic programming with memoization to solve this problem.\r\n2. We define a helper function fmemo(i, nums, dp) that calculates the maximum amount of money that can be robbed from the 0th to the ith house using memoization.\r\n3. The function checks if the maximum amount for the ith house is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the maximum amount by considering two options:\r\n   a) Rob the current house and add the money with the maximum amount from the (i-2)th house (since adjacent houses cannot be robbed).\r\n   b) Skip the current house and take the maximum amount from the (i-1)th house.\r\n5. The base case is when i is less than 0, in which case the function returns 0 as there are no houses to rob.\r\n6. In the main function rob(nums), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last house), the nums array, and the dp array as arguments.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum amount for each house only once and storing it in the dp array.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\2. 1D DP\\04. House Robber.cpp",
      "verified": false,
      "needsReview": true
    },
    "house-robber-2": {
      "id": "house-robber-2",
      "title": "House Robber 2",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nExample 1:\r\nInput: nums = [2,3,2]\r\nOutput: 3\r\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.",
      "approach": "1. Since the houses are arranged in a circle, the robber cannot rob the first and last house together as they are adjacent.\r\n2. To solve this problem, we can divide it into two subproblems: one where the robber robs from the first house to the second-last house (excluding the last house), and another where the robber robs from the second house to the last house (excluding the first house).\r\n3. We can use dynamic programming with memoization to calculate the maximum amount of money that can be robbed in each subproblem.\r\n4. We define a helper function fmemo(e, i, nums, dp) that calculates the maximum amount of money that can be robbed from the e-th to the i-th house using memoization.\r\n5. The function checks if the maximum amount for the i-th house is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n6. Otherwise, it calculates the maximum amount by considering two options:\r\n   a) Rob the current house and add the money with the maximum amount from the (i-2)th house (since adjacent houses cannot be robbed).\r\n   b) Skip the current house and take the maximum amount from the (i-1)th house.\r\n7. The base case is when i is less than e, in which case the function returns 0 as there are no houses to rob.\r\n8. In the main function rob(nums), we first check if there is only one house. If yes, the robber can only rob that house, so we return the amount in that case.\r\n9. Otherwise, we create a dp array of size n initialized with -1 and call the fmemo function twice: one for robbing from the first to the second-last house and the other for robbing from the second to the last house.\r\n10. Finally, we return the maximum amount from the two subproblems, which gives the maximum amount the robber can rob without alerting the police.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum amount for each house only once and storing it in the dp array.\r\n- The space complexity is also O(n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\2. 1D DP\\05. House Robber 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "ninja-training": {
      "id": "ninja-training",
      "title": "Ninja Training",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Geek is going for n days training program, he can perform any one of these three activities Running, Fighting, and Learning Practice. Each activity has some point on each day. As Geek wants to improve all his skills, he can't do the same activity on two consecutive days. Help Geek to maximize his merit points as we were given a 2D array of n*3 points corresponding to each day and activity.\r\n\r\nExample:\r\nInput:\r\nn = 3\r\npoints = [[1,2,5],[3,1,1],[3,3,3]]\r\nOutput:\r\n11\r\nExplanation:\r\nGeek will learn a new move and earn 5 points on the first day,\r\nthen on the second day, he will do running and earn 3 points,\r\nand on the third day, he will do fighting and earn 3 points.\r\nSo, the maximum points is 11.",
      "approach": "1. To maximize the merit points, we need to find the maximum sum of points such that the Geek can't perform the same activity on two consecutive days.\r\n2. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n3. We define a helper function fmemo(n, prev, points, memo) that calculates the maximum points the Geek can earn from the nth day onwards, given that on the (n-1)th day, he performed the activity indexed by 'prev'.\r\n4. The function checks if the maximum points for the (n-1)th day and 'prev' activity is already calculated and stored in the memo array. If yes, it returns the value from memo.\r\n5. Otherwise, it calculates the maximum points for the nth day by considering all three activities except the one performed on the (n-1)th day. It then adds the points for the nth day and recursively calls the function for the (n-1)th day with the new activity and updates the maximum points.\r\n6. The base case is when n is less than 0, in which case the function returns 0 as there are no days to earn points.\r\n7. In the main function maximumPoints(points, n), we create a dp (memo) array of size n initialized with -1 and call the fmemo function for the nth day with the initial activity as -1 (since no activity is performed on the first day).\r\n8. Finally, we return the maximum points obtained for all three possible starting activities (running, fighting, learning practice) as the result.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum points for each day only once and storing it in the memo array.\r\n- The space complexity is also O(n) to store the memo array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\01. Ninja Training.cpp",
      "verified": false,
      "needsReview": true
    },
    "unique-paths": {
      "id": "unique-paths",
      "title": "Unique Paths",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\r\n\r\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\r\n\r\nExample 1:\r\nInput: m = 3, n = 7\r\nOutput: 28",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, j, dp) that calculates the number of unique paths from the top-left corner (0, 0) to the cell (i, j) on the grid.\r\n3. The function checks if the number of unique paths for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. Otherwise, it calculates the number of unique paths for the cell (i, j) by adding the number of unique paths from the cell above (i-1, j) and the cell to the left (i, j-1).\r\n5. The base case is when i or j is less than 0, in which case the function returns 0 as there are no paths to reach those cells.\r\n6. In the main function uniquePaths(m, n), we create a dp array of size m x n initialized with -1 and call the fmemo function for the bottom-right cell (m-1, n-1).\r\n7. Finally, we return the number of unique paths obtained for the bottom-right cell as the result.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(m x n) because we are calculating the number of unique paths for each cell only once and storing it in the dp array.\r\n- The space complexity is also O(m x n) to store the dp array.\r\n\r\nNote: The given test cases are generated such that the answer will be less than or equal to 2 x 10^9.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\02. Unique Paths.cpp",
      "verified": false,
      "needsReview": true
    },
    "unique-paths-2": {
      "id": "unique-paths-2",
      "title": "Unique Paths 2",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\r\n\r\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\r\n\r\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\r\n\r\nExample:\r\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\r\nOutput: 2\r\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\r\nThere are two ways to reach the bottom-right corner:\r\n1. Right -> Right -> Down -> Down\r\n2. Down -> Down -> Right -> Right",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, j, grid, dp) that calculates the number of unique paths from the top-left corner (0, 0) to the cell (i, j) on the grid.\r\n3. The function checks if the number of unique paths for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. If the cell (i, j) contains an obstacle (i.e., grid[i][j] == 1), then there is no possible path through that cell, so the function returns 0.\r\n5. Otherwise, it calculates the number of unique paths for the cell (i, j) by adding the number of unique paths from the cell above (i-1, j) and the cell to the left (i, j-1).\r\n6. The base case is when i or j is less than 0, in which case the function returns 0 as there are no paths to reach those cells.\r\n7. In the main function uniquePathsWithObstacles(obstacleGrid), we create a dp array of size m x n initialized with -1 and call the fmemo function for the bottom-right cell (m-1, n-1).\r\n8. Finally, we return the number of unique paths obtained for the bottom-right cell as the result.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(m x n) because we are calculating the number of unique paths for each cell only once and storing it in the dp array.\r\n- The space complexity is also O(m x n) to store the dp array.\r\n\r\nNote: The given test cases are generated such that the answer will be less than or equal to 2 x 10^9.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\03. Unique Paths 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-path-sum": {
      "id": "minimum-path-sum",
      "title": "Minimum Path Sum",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\r\n\r\nNote: You can only move either down or right at any point in time.\r\n\r\nExample 1:\r\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\r\nOutput: 7\r\nExplanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, j, grid, dp) that calculates the minimum sum path to reach the cell (i, j) on the grid.\r\n3. The function checks if the minimum sum path for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. If i or j is less than 0 (out of bounds), the function returns a large value (e.g., 1e9) to represent an invalid path.\r\n5. The base case is when i and j are both 0, in which case the function returns the value in the cell (0, 0) as the minimum sum path.\r\n6. Otherwise, it calculates the minimum sum path for the cell (i, j) by taking the minimum of the minimum sum paths from the cell above (i-1, j) and the cell to the left (i, j-1), and then adding the value in the current cell (grid[i][j]).\r\n7. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(m x n) because we are calculating the minimum sum path for each cell only once and storing it in the dp array.\r\n- The space complexity is also O(m x n) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\04. Minimum Path Sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-path-in-triangle": {
      "id": "minimum-path-in-triangle",
      "title": "Minimum Path in Triangle",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a triangle array, return the minimum path sum from top to bottom.\r\n\r\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\r\n\r\nExample:\r\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\r\nOutput: 11\r\nExplanation: The triangle looks like:\r\n   2\r\n  3 4\r\n 6 5 7\r\n4 1 8 3\r\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, j, n, tri, dp) that calculates the minimum path sum from the current cell (i, j) to the bottom of the triangle.\r\n3. The function checks if the minimum path sum for the current cell is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. If i is equal to n-1, it means we are at the last row of the triangle, so the minimum path sum is the value in the current cell (tri[i][j]).\r\n5. Otherwise, the function calculates the minimum path sum for the current cell by taking the minimum of the minimum path sums from the cells directly below (i+1, j) and (i+1, j+1), and then adding the value in the current cell (tri[i][j]).\r\n6. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n^2) because we are calculating the minimum path sum for each cell only once and storing it in the dp array.\r\n- The space complexity is also O(n^2) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\05. Minimum Path in Triangle.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-falling-path-sum": {
      "id": "minimum-falling-path-sum",
      "title": "Minimum Falling Path Sum",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\r\n\r\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\r\n\r\nExample:\r\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]]\r\nOutput: 13\r\nExplanation: There are two falling paths with a minimum sum as shown.",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, j, mat, dp) that calculates the minimum sum of any falling path starting from cell (i, j).\r\n3. The function checks if the minimum sum for the current cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\r\n4. If i is 0, it means we are at the first row, so the minimum sum starting from this cell is the value in the current cell (mat[i][j]).\r\n5. Otherwise, the function calculates the minimum sum for the current cell by taking the minimum of the minimum sums of the cells above it (i-1, j-1), (i-1, j), and (i-1, j+1), and then adding the value in the current cell (mat[i][j]).\r\n6. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\r\n7. Finally, we find the minimum falling path sum for all cells in the first row and return the smallest value.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n^2) since we are calculating the minimum sum for each cell only once and storing it in the dp array.\r\n- The space complexity is also O(n^2) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\3. 2D DP\\06. Minimum Falling Path Sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "subset-sum-equal-to-k": {
      "id": "subset-sum-equal-to-k",
      "title": "Subset sum equal to k",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.\r\n\r\nExample:\r\nInput:\r\nN = 6\r\narr[] = {3, 34, 4, 12, 5, 2}\r\nsum = 9\r\nOutput: 1\r\nExplanation: Here there exists a subset with sum = 9, 4+3+2 = 9.",
      "approach": "1. We can solve this problem using dynamic programming with memoization (top-down approach).\r\n2. We define a helper function fmemo(i, sum, arr, dp) that checks if there is a subset of elements up to index i whose sum is equal to the given sum.\r\n3. The function checks if the target sum is 0. If yes, it means we have found a subset with the given sum and returns true.\r\n4. If i is 0, it means we are at the first element, so the function checks if the first element is equal to the target sum.\r\n5. If the dp value for the current index and sum is already calculated, it returns the stored value.\r\n6. If the current element (arr[i]) is less than or equal to the target sum, the function recursively checks for two cases: including the current element in the subset (by reducing the sum) or excluding it (by not changing the sum).\r\n7. If any of the above cases returns true, the dp value for the current index and sum is updated to true.\r\n8. Finally, we return the dp value for the last index and the given sum.\r\n\r\nComplexity Analysis:\r\n- The time complexity of the fmemo function is O(n * sum), where n is the number of elements in the array and sum is the target sum. This is because the function calculates the result for each index and sum only once and stores it in the dp array.\r\n- The space complexity is also O(n * sum) to store the dp array.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming",
        "recursion"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\01. Subset sum equal to k.cpp",
      "verified": false,
      "needsReview": true
    },
    "partition-array-in-two-equal-sum-subsets": {
      "id": "partition-array-in-two-equal-sum-subsets",
      "title": "Partition array in two equal sum subsets",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array `nums`, return `true` if you can partition the array into two subsets such that the sum of the elements in both subsets is equal, or `false` otherwise.\r\n\r\nExample 1:\r\nInput: nums = [1,5,11,5]\r\nOutput: true\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].",
      "approach": "- To solve this problem, we can use dynamic programming.\r\n- We'll create a 2D DP array where `dp[i][j]` represents whether it's possible to select a subset from the first `i` elements of the `nums` array that sums up to `j`.\r\n- The base case is when `j` is 0, in which case it's always possible to select an empty subset.\r\n- For each element in the `nums` array, we have two choices: include it in the subset or exclude it.\r\n- So, the recurrence relation becomes:\r\n  dp[i][j] = dp[i - 1][j] (exclude nums[i]) || dp[i - 1][j - nums[i]] (include nums[i])\r\n\r\nCOMPLEXITY ANALYSIS:\r\n\r\n- The time complexity of this approach is O(n * sum), where `n` is the number of elements in the `nums` array and `sum` is the sum of all elements.\r\n\r\nCODE:",
      "code": "*/\r\n// Memoization\r\nbool fmemo(int i, int sum, vector<int>& arr, vector<vector<int>>& dp) {\r\n    if (sum == 0)\r\n        return true;\r\n\r\n    if (dp[i][sum] != -1)\r\n        return dp[i][sum];\r\n\r\n    if (i == 0)\r\n        return dp[i][sum] = (sum == arr[i]);\r\n\r\n    bool t = false;\r\n    if (arr[i] <= sum)\r\n        t = fmemo(i - 1, sum - arr[i], arr, dp);\r\n\r\n    bool nt = fmemo(i - 1, sum, arr, dp);\r\n\r\n    return dp[i][sum] = (t || nt);\r\n}\r\n\r\n// Tabulation\r\nbool ftab(int n, int tar, vector<int>& arr){\r\n    vector<vector<int>> dp(n,vector<int>(tar+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int sum=0; sum<=tar; sum++){\r\n            if(sum==0){\r\n                dp[i][sum] = true;\r\n                continue;\r\n            }\r\n            if(i==0){\r\n                dp[i][sum] = (sum==arr[i]);\r\n                continue;\r\n            }\r\n            bool t = false;\r\n            if(arr[i] <= sum) t = dp[i-1][sum-arr[i]];\r\n            bool nt = dp[i-1][sum];\r\n            dp[i][sum] = (t || nt);\r\n        }\r\n    }\r\n    return dp[n-1][tar];\r\n}\r\n\r\n// Space Optimization\r\nbool fopt(int n, int tar, vector<int>& arr){\r\n    vector<int> prev(tar+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(tar+1);\r\n        for(int sum=0; sum<=tar; sum++){\r\n            if(sum==0){\r\n                curr[sum] = true;\r\n                continue;\r\n            }\r\n            if(i==0){\r\n                curr[sum] = (sum==arr[i]);\r\n                continue;\r\n            }\r\n            bool t = false;\r\n            if(arr[i] <= sum) t = prev[sum-arr[i]];\r\n            bool nt = prev[sum];\r\n            curr[sum] = (t || nt);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[tar];\r\n}\r\n\r\nbool canPartition(vector<int>& nums) {\r\n    int sum = 0, n = nums.size();\r\n    for(auto i:nums) sum+=i;\r\n    if(sum%2!=0) return false;\r\n    int k = sum/2;\r\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\r\n    return fmemo(n-1,k,nums,dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int sum=0; sum<=tar; sum++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\02. Partition array in two equal sum subsets.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-sum-partition": {
      "id": "minimum-sum-partition",
      "title": "Minimum Sum Partition",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array arr of size n containing non-negative integers,\r\nthe task is to divide it into two sets S1 and S2 such that the absolute\r\ndifference between their sums is minimum and find the minimum difference\r\n\r\nExample 1:\r\nInput: N = 4, arr[] = {1, 6, 11, 5}\r\nOutput: 1\r\nExplanation:\r\nSubset1 = {1, 5, 6}, sum of Subset1 = 12\r\nSubset2 = {11}, sum of Subset2 = 11",
      "approach": "- Calculate the sum of all elements in the array.\r\n- Initialize a 2D dp array of size n x (sum + 1) to store if it is possible to achieve a sum 's' using the first 'i' elements.\r\n- Initialize dp[i][0] to true, since an empty subset can have a sum of 0.\r\n- For each element 'arr[i]' and each possible sum 's' from 1 to 'sum':\r\n  - Check if it's possible to achieve a sum of 's' using the first 'i-1' elements, or using 's - arr[i]' and the first 'i-1' elements.\r\n  - Update dp[i][s] accordingly.\r\n- Iterate through the dp array for the last row and find the minimum absolute difference between the sum 's' and 'totalSum - s' for which dp[n-1][s] is true.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n * sum), where 'n' is the number of elements and 'sum' is the sum of all elements.\r\n- The space complexity is O(n * sum) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nbool ftab(int n, int tar, int arr[], vector<vector<int>>& dp){\r\n    for(int i = 0; i < n; i++){\r\n        for(int sum = 0; sum <= tar; sum++){\r\n            if(sum == 0){\r\n                dp[i][sum] = true;\r\n                continue;\r\n            }\r\n            if(i == 0){\r\n                dp[i][sum] = (sum == arr[i]);\r\n                continue;\r\n            }\r\n            bool t = false;\r\n            if(arr[i] <= sum) t = dp[i-1][sum - arr[i]];\r\n            bool nt = dp[i-1][sum];\r\n            dp[i][sum] = (t || nt);\r\n        }\r\n    }\r\n    return dp[n-1][tar];\r\n}\r\n\r\nint minDifference(int arr[], int n){\r\n    int totalSum = 0;\r\n    for(int i = 0; i < n; i++) totalSum += arr[i];\r\n    vector<vector<int>> dp(n, vector<int>(totalSum + 1));\r\n    ftab(n, totalSum, arr, dp);\r\n    int ans = INT_MAX;\r\n    for(int i = 0; i <= totalSum; i++){\r\n        if(dp[n-1][i])\r\n            ans = min(ans, abs(i - (totalSum - i)));\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i = 0; i < n; i++)",
        "for(int sum = 0; sum <= tar; sum++)",
        "for(int i = 0; i < n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\03. Minimum Sum Partition.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-number-of-subsets-with-sum-k": {
      "id": "count-number-of-subsets-with-sum-k",
      "title": "Count number of subsets with sum K",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array arr[] of non-negative integers and an integer sum, \r\nthe task is to count all subsets of the given array with a sum \r\nequal to a given sum.\r\n\r\nNote: Answer can be very large, so, output answer modulo 10^9+7\r\n\r\nExample 1:\r\nInput: N = 6, arr[] = {2, 3, 5, 6, 8, 10}\r\n       sum = 10\r\nOutput: 3\r\nExplanation: {2, 3, 5}, {2, 8}, {10}",
      "approach": "- We'll use a bottom-up dynamic programming approach using a 2D dp array.\r\n- Initialize dp[i][j] as the number of subsets with sum 'j' using the first 'i' elements.\r\n- Base cases:\r\n  - dp[0][0] = 1 since an empty subset has a sum of 0.\r\n  - dp[i][0] = 1 since there's always an empty subset.\r\n- For each element 'arr[i]' and each possible sum 'j' from 1 to 'sum':\r\n  - dp[i][j] = dp[i-1][j] (not taking the current element)\r\n  - if 'arr[i]' is less than or equal to 'j', then dp[i][j] += dp[i-1][j-arr[i]] (taking the current element)\r\n- Return dp[n][sum] which represents the number of subsets with sum 'sum' using all 'n' elements.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n * sum), where 'n' is the number of elements and 'sum' is the required sum.\r\n- The space complexity is O(n * sum) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\n// Memoization\r\nint fmemo(int i, int tar, int arr[], vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(tar == 0 && arr[i] == 0) return dp[i][tar] = 2;\r\n        if(tar == 0) return dp[i][tar] = 1;\r\n        return dp[i][tar] = (arr[i] == tar);\r\n    }\r\n\r\n    if(dp[i][tar] != -1) return dp[i][tar];\r\n\r\n    int take = 0;\r\n    if(arr[i] <= tar) take = fmemo(i - 1, tar - arr[i], arr, dp);\r\n    int notake = fmemo(i - 1, tar, arr, dp);\r\n    return dp[i][tar] = (take + notake) % mod;\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int sum, int arr[]){\r\n    vector<vector<int>> dp(n,vector<int>(sum+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) dp[i][tar] = 2;\r\n                else if(tar==0) dp[i][tar] = 1;\r\n                else dp[i][tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = dp[i-1][tar-arr[i]];\r\n            int notake = dp[i-1][tar];\r\n            dp[i][tar] =  (take+notake)%mod;\r\n        }\r\n    }\r\n    return dp[n-1][sum];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int sum, int arr[]){\r\n    vector<int> prev(sum+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(sum+1);\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) curr[tar] = 2;\r\n                else if(tar==0) curr[tar] = 1;\r\n                else curr[tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = prev[tar-arr[i]];\r\n            int notake = prev[tar];\r\n            curr[tar] =  (take+notake)%mod;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[sum];\r\n}\r\n\r\nint perfectSum(int arr[], int n, int sum){\r\n    vector<vector<int>> dp(n, vector<int>(sum + 1, -1));\r\n    return fmemo(n - 1, sum, arr, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int tar=0; tar<=sum; tar++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\04. Count number of subsets with sum K.cpp",
      "verified": false,
      "needsReview": true
    },
    "partition-with-given-difference": {
      "id": "partition-with-given-difference",
      "title": "Partition with given difference",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array arr, partition it into two subsets(possibly empty) \r\nsuch that their union is the original array. Let the sum of the \r\nelements of these two subsets be S1 and S2. \r\n\r\nGiven a difference d, count the number of partitions in which S1 is \r\ngreater than or equal to S2 and the difference S1 and S2 is equal to d. \r\nSince the answer may be large, return it modulo 10^9 + 7.\r\n\r\nExample 1:\r\nInput:\r\nn = 4, d = 3\r\narr[] = {5, 2, 6, 4}\r\nOutput: 1\r\nExplanation:\r\nThere is only one possible partition of this array. \r\nPartition: {6, 4}, {5, 2}. The subset difference between subset sums is: (6 + 4) - (5 + 2) = 3.",
      "approach": "- We'll use a similar approach as used in the subset sum count problem.\r\n- Initialize dp[i][j] as the number of subsets with sum 'j' using the first 'i' elements.\r\n- Base cases:\r\n  - dp[0][0] = 1 since an empty subset has a sum of 0.\r\n  - dp[i][0] = 1 since there's always an empty subset.\r\n- For each element 'arr[i]' and each possible sum 'j' from 1 to 'sum':\r\n  - dp[i][j] = dp[i-1][j] (not taking the current element)\r\n  - if 'arr[i]' is less than or equal to 'j', then dp[i][j] += dp[i-1][j-arr[i]] (taking the current element)\r\n- Initialize 'ans' as 0.\r\n- For each possible subset sum 'i':\r\n  - Check if the difference between (i - (sum - i)) is equal to 'd'.\r\n  - If it is, add the result of fmemo(n, i, arr, dp) to 'ans'.\r\n- Return 'ans' % mod which represents the answer.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n * sum), where 'n' is the number of elements and 'sum' is the required sum.\r\n- The space complexity is O(n * sum) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\n// Memoization\r\nint fmemo(int i, int tar, int arr[], vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(tar == 0 && arr[i] == 0) return dp[i][tar] = 2;\r\n        if(tar == 0) return dp[i][tar] = 1;\r\n        return dp[i][tar] = (arr[i] == tar);\r\n    }\r\n\r\n    if(dp[i][tar] != -1) return dp[i][tar];\r\n\r\n    int take = 0;\r\n    if(arr[i] <= tar) take = fmemo(i - 1, tar - arr[i], arr, dp);\r\n    int notake = fmemo(i - 1, tar, arr, dp);\r\n    return dp[i][tar] = (take + notake) % mod;\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int sum, int arr[]){\r\n    vector<vector<int>> dp(n,vector<int>(sum+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) dp[i][tar] = 2;\r\n                else if(tar==0) dp[i][tar] = 1;\r\n                else dp[i][tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = dp[i-1][tar-arr[i]];\r\n            int notake = dp[i-1][tar];\r\n            dp[i][tar] =  (take+notake)%mod;\r\n        }\r\n    }\r\n    return dp[n-1][sum];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int sum, int arr[]){\r\n    vector<int> prev(sum+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(sum+1);\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) curr[tar] = 2;\r\n                else if(tar==0) curr[tar] = 1;\r\n                else curr[tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = prev[tar-arr[i]];\r\n            int notake = prev[tar];\r\n            curr[tar] =  (take+notake)%mod;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[sum];\r\n}\r\n\r\nint countPartitions(int n, int d, vector<int>& arr) {\r\n    int sum = 0, ans = 0;\r\n    for(auto i:arr) sum += i;\r\n    vector<vector<int>> dp(n, vector<int>(sum + 1, -1));\r\n    for(int i = 0; i <= sum; i++){\r\n        if(i - (sum - i) == d)\r\n            ans = (ans + fmemo(n - 1, i, arr, dp)) % mod;\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int tar=0; tar<=sum; tar++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\05. Partition with given difference.cpp",
      "verified": false,
      "needsReview": true
    },
    "01-knapsack": {
      "id": "01-knapsack",
      "title": "01 Knapsack",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given weights and values of 'N' items, the task is to put these \r\nitems in a knapsack of capacity 'W' to get the maximum total value \r\nin the knapsack. The constraint is that each item can either be \r\npicked completely or not at all (0-1 property).\r\n\r\nExample:\r\nInput: \r\nN = 3\r\nW = 4\r\nvalues[] = {1, 2, 3}\r\nweight[] = {4, 5, 1}\r\nOutput: 3",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the \r\n  maximum value that can be obtained using the first 'i' items \r\n  and having a knapsack capacity of 'j'.\r\n- Base cases:\r\n  - dp[0][j] = 0 for all j (no items available)\r\n  - dp[i][0] = 0 for all i (no capacity)\r\n- For each item 'i' and each possible capacity 'j':\r\n  - If the weight of the current item is less than or equal to 'j':\r\n    - dp[i][j] = max(dp[i-1][j], val[i] + dp[i-1][j-wt[i]])\r\n  - Otherwise, dp[i][j] = dp[i-1][j] (item cannot be included)\r\n- The required answer will be dp[N][W] where 'N' is the number of items \r\n  and 'W' is the knapsack capacity.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(N * W), where 'N' is the \r\n  number of items and 'W' is the knapsack capacity.\r\n- The space complexity is O(N * W) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int val[], int wt[], int W, vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(W >= wt[i]) return dp[i][W] = val[i];\r\n        else return dp[i][W] = 0;\r\n    }\r\n    \r\n    if(dp[i][W] != -1) return dp[i][W];\r\n    \r\n    int take = INT_MIN;\r\n    if(W >= wt[i]) take = val[i] + fmemo(i-1, val, wt, W - wt[i], dp);\r\n    int notake = fmemo(i-1, val, wt, W, dp);\r\n    \r\n    return dp[i][W] = max(take, notake);\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int val[], int wt[], int weight){\r\n    vector<vector<int>> dp(n,vector<int>(weight+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int W=0; W<=weight; W++){\r\n            if(i==0){\r\n                if(W >= wt[i]) dp[i][W] = val[i];\r\n                else dp[i][W] = 0;\r\n                continue;\r\n            }\r\n            int take = INT_MIN;\r\n            if(W >= wt[i]) take = val[i]+dp[i-1][W-wt[i]];\r\n            int notake = dp[i-1][W];\r\n            dp[i][W] = max(take,notake);\r\n        }\r\n    }\r\n    return dp[n-1][weight];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int val[], int wt[], int weight){\r\n    vector<int> prev(weight+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(weight+1);\r\n        for(int W=0; W<=weight; W++){\r\n            if(i==0){\r\n                if(W >= wt[i]) curr[W] = val[i];\r\n                else curr[W] = 0;\r\n                continue;\r\n            }\r\n            int take = INT_MIN;\r\n            if(W >= wt[i]) take = val[i]+prev[W-wt[i]];\r\n            int notake = prev[W];\r\n            curr[W] = max(take,notake);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return dp[n-1][weight];\r\n}\r\n\r\nint knapSack(int W, int wt[], int val[], int n) {\r\n    vector<vector<int>> dp(n, vector<int>(W + 1, -1));\r\n    return fmemo(n - 1, val, wt, W, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int W=0; W<=weight; W++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\06. 01 Knapsack.cpp",
      "verified": false,
      "needsReview": true
    },
    "coin-change": {
      "id": "coin-change",
      "title": "Coin Change",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array 'coins' representing coins of different \r\ndenominations and an integer 'amount' representing a total amount \r\nof money, the task is to return the fewest number of coins that \r\nyou need to make up that amount. If that amount of money cannot \r\nbe made up by any combination of the coins, return -1.\r\n\r\nExample:\r\nInput: coins = [1, 2, 5], amount = 11\r\nOutput: 3\r\nExplanation: 11 = 5 + 5 + 1",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the minimum \r\n  number of coins needed to make up amount 'j' using the first 'i' coins.\r\n- Base case:\r\n  - dp[i][0] = 0 for all 'i' (no coins needed to make 0 amount)\r\n  - dp[0][j] = 1e9 (no way to make up any amount using 0 coins)\r\n- For each coin 'i' and each possible amount 'j':\r\n  - dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i]] + 1)\r\n- The required answer will be dp[n][amount] where 'n' is the number \r\n  of coins and 'amount' is the given total amount.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(N * amount), where 'N' is \r\n  the number of coins and 'amount' is the given total amount.\r\n- The space complexity is O(N * amount) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int amt, vector<int>& coins, vector<vector<int>>& dp){\r\n    if(amt == 0) return 0;\r\n    if(i == 0){\r\n        if(amt % coins[i] == 0) return amt / coins[i];\r\n        else return 1e9;\r\n    }\r\n\r\n    if(dp[i][amt] != -1) return dp[i][amt];\r\n\r\n    int take = 1e9;\r\n    if(coins[i] <= amt) take = 1 + fmemo(i, amt - coins[i], coins, dp);\r\n    int notake = fmemo(i - 1, amt, coins, dp);\r\n    \r\n    return dp[i][amt] = min(take, notake);\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int amount, vector<int>& coins){\r\n    vector<vector<int>> dp(n,vector<int>(amount+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int amt=0; amt<=amount; amt++){\r\n            if(amt==0) {\r\n                dp[i][amt] = 0;\r\n                continue;\r\n            }\r\n            if(i==0){\r\n                if(amt%coins[i]==0) dp[i][amt] =  amt/coins[i];\r\n                else dp[i][amt] = 1e9;\r\n                continue;\r\n            }\r\n            int take = 1e9;\r\n            if(coins[i]<=amt) take = 1+dp[i][amt-coins[i]];\r\n            int notake = dp[i-1][amt];\r\n            dp[i][amt] = min(take,notake);\r\n        }\r\n    }\r\n    return dp[n-1][amount];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int amount, vector<int>& coins){\r\n    vector<int> prev(amount+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(amount+1);\r\n        for(int amt=0; amt<=amount; amt++){\r\n            if(amt==0) {\r\n                curr[amt] = 0;\r\n                continue;\r\n            }\r\n            if(i==0){\r\n                if(amt%coins[i]==0) curr[amt] =  amt/coins[i];\r\n                else curr[amt] = 1e9;\r\n                continue;\r\n            }\r\n            int take = 1e9;\r\n            if(coins[i]<=amt) take = 1+curr[amt-coins[i]];\r\n            int notake = prev[amt];\r\n            curr[amt] = min(take,notake);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[amount];\r\n}\r\n\r\nint coinChange(vector<int>& coins, int amount) {\r\n    int n = coins.size();\r\n    vector<vector<int>> dp(n, vector<int>(amount + 1, -1));\r\n    int ans = fmemo(n - 1, amount, coins, dp);\r\n    return (ans == 1e9) ? -1 : ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int amt=0; amt<=amount; amt++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\07. Coin Change.cpp",
      "verified": false,
      "needsReview": true
    },
    "target-sum": {
      "id": "target-sum",
      "title": "Target Sum",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array 'nums' and an integer 'target', the task is to count \r\nthe number of ways to make the sum of elements of one subset equal \r\nto 'target'.\r\n\r\nExample:\r\nInput: nums = [1, 1, 1, 1, 1], target = 3\r\nOutput: 5\r\nExplanation: There are 5 ways to achieve the target sum: \r\n{1, 1, 1}, {1, 2}, {2, 1}, {1, 2}, {3}",
      "approach": "- The problem can be reduced to finding the count of subsets with a \r\n  given sum.\r\n- Initialize dp[i][j] as the number of subsets with sum 'j' using \r\n  the first 'i' elements.\r\n- Base cases:\r\n  - dp[0][0] = 1 since an empty subset has a sum of 0.\r\n  - dp[i][0] = 1 since there's always an empty subset.\r\n- For each element 'nums[i]' and each possible sum 'j' from 1 to 'target':\r\n  - dp[i][j] = dp[i-1][j] (not taking the current element)\r\n  - if 'nums[i]' is less than or equal to 'j', then dp[i][j] += dp[i-1][j-nums[i]] (taking the current element)\r\n- The required answer will be dp[n][target] where 'n' is the number \r\n  of elements in the array.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n * target), where 'n' \r\n  is the number of elements in the array.\r\n- The space complexity is O(n * target) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\n// Memoization\r\nint fmemo(int i, int tar, int arr[], vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(tar == 0 && arr[i] == 0) return dp[i][tar] = 2;\r\n        if(tar == 0) return dp[i][tar] = 1;\r\n        return dp[i][tar] = (arr[i] == tar);\r\n    }\r\n\r\n    if(dp[i][tar] != -1) return dp[i][tar];\r\n\r\n    int take = 0;\r\n    if(arr[i] <= tar) take = fmemo(i - 1, tar - arr[i], arr, dp);\r\n    int notake = fmemo(i - 1, tar, arr, dp);\r\n    return dp[i][tar] = (take + notake);\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int sum, int arr[]){\r\n    vector<vector<int>> dp(n,vector<int>(sum+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) dp[i][tar] = 2;\r\n                else if(tar==0) dp[i][tar] = 1;\r\n                else dp[i][tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = dp[i-1][tar-arr[i]];\r\n            int notake = dp[i-1][tar];\r\n            dp[i][tar] =  (take+notake);\r\n        }\r\n    }\r\n    return dp[n-1][sum];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int sum, int arr[]){\r\n    vector<int> prev(sum+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(sum+1);\r\n        for(int tar=0; tar<=sum; tar++){\r\n            if(i==0){\r\n                if(tar==0 && arr[i]==0) curr[tar] = 2;\r\n                else if(tar==0) curr[tar] = 1;\r\n                else curr[tar] =  (arr[i]==tar);\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = prev[tar-arr[i]];\r\n            int notake = prev[tar];\r\n            curr[tar] =  (take+notake);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[sum];\r\n}\r\n\r\nint findTargetSumWays(vector<int>& nums, int target) {\r\n    int n = nums.size(), sum = 0; \r\n    for(auto i:nums) sum += i;\r\n    vector<vector<int>> dp(n, vector<int>(sum + 1, -1));\r\n    return fmemo(n - 1, target, nums, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int tar=0; tar<=sum; tar++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\08. Target Sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "coin-change-2": {
      "id": "coin-change-2",
      "title": "Coin Change 2",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array 'coins' representing coins of different \r\ndenominations and an integer 'amount' representing a total amount \r\nof money, the task is to return the number of combinations that \r\nmake up that amount using the given coins. If that amount of money \r\ncannot be made up by any combination of the coins, return 0.\r\n\r\nExample:\r\nInput: amount = 5, coins = [1, 2, 5]\r\nOutput: 4\r\nExplanation: There are four ways to make up the amount:\r\n5 = 5\r\n5 = 2 + 2 + 1\r\n5 = 2 + 1 + 1 + 1\r\n5 = 1 + 1 + 1 + 1 + 1",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the number \r\n  of combinations to make up amount 'j' using the first 'i' coins.\r\n- Base case:\r\n  - dp[i][0] = 1 for all 'i' (one way to make 0 amount with any coin)\r\n- For each coin 'i' and each possible amount 'j':\r\n  - dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]\r\n- The required answer will be dp[n][amount] where 'n' is the number \r\n  of coins and 'amount' is the given total amount.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(N * amount), where 'N' is \r\n  the number of coins and 'amount' is the given total amount.\r\n- The space complexity is O(N * amount) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int tar, vector<int>& arr, vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(tar % arr[i] != 0) return 0;\r\n        return 1;\r\n    }\r\n\r\n    if(dp[i][tar] != -1) return dp[i][tar];\r\n\r\n    int take = 0;\r\n    if(arr[i] <= tar) take = fmemo(i, tar - arr[i], arr, dp);\r\n    int notake = fmemo(i - 1, tar, arr, dp);\r\n    \r\n    return dp[i][tar] = (take + notake);\r\n}\r\n\r\n// Tabulation\r\n int ftab(int n, int amount, vector<int>& arr){\r\n    vector<vector<int>> dp(n,vector<int>(amount+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int tar=0; tar<=amount; tar++){\r\n            if(i == 0){\r\n                if(tar % arr[i]!=0) dp[i][tar] = 0;\r\n                else dp[i][tar] = 1;\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = dp[i][tar-arr[i]];\r\n            int notake = dp[i-1][tar];\r\n            dp[i][tar] = (take + notake);\r\n        }\r\n    }\r\n    return dp[n-1][amount];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int amount, vector<int>& arr){\r\n    vector<int> prev(amount+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(amount+1);\r\n        for(int tar=0; tar<=amount; tar++){\r\n            if(i == 0){\r\n                if(tar % arr[i]!=0) curr[tar] = 0;\r\n                else curr[tar] = 1;\r\n                continue;\r\n            }\r\n            int take = 0;\r\n            if(arr[i] <= tar) take = curr[tar-arr[i]];\r\n            int notake = prev[tar];\r\n            curr[tar] = (take + notake);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[amount];\r\n}\r\n\r\nint change(int amount, vector<int>& coins) {\r\n    int n = coins.size();\r\n    vector<vector<int>> dp(n, vector<int>(amount + 1, -1));\r\n    return fmemo(n - 1, amount, coins, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "backtracking"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int tar=0; tar<=amount; tar++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\09. Coin Change 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "unbounded-knapsack": {
      "id": "unbounded-knapsack",
      "title": "Unbounded Knapsack",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a set of N items, each with a weight and a value, represented \r\nby the arrays w[] and val[] respectively, and a knapsack with weight \r\nlimit 'W', the task is to fill the knapsack in such a way that we \r\ncan get the maximum profit. Return the maximum profit.\r\nNote: Each item can be taken any number of times.\r\n\r\nExample:\r\nInput: N = 2, W = 3\r\nval[] = {1, 1}\r\nwt[] = {2, 1}\r\nOutput: 3\r\nExplanation: \r\n1. Pick the 2nd element thrice.\r\n2. Total profit = 1 + 1 + 1 = 3. Also the total weight = 1 + 1 + 1 = 3 \r\n   which is <= W.",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the maximum \r\n  profit that can be obtained by using items from 0 to 'i' with a total \r\n  weight of 'j'.\r\n- Base case: dp[0][j] = j / wt[0] * val[0] (maximum profit with only \r\n  the first item)\r\n- For each item 'i' and each possible total weight 'j':\r\n  - dp[i][j] = max(dp[i-1][j], val[i] + dp[i][j - wt[i]])\r\n- The required answer will be dp[N-1][W] where 'N' is the number of items \r\n  and 'W' is the given weight limit.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(N * W), where 'N' is the number \r\n  of items and 'W' is the given weight limit.\r\n- The space complexity is O(N * W) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int val[], int wt[], int W, vector<vector<int>>& dp){\r\n    if(i == 0){\r\n        if(W >= wt[i]){\r\n            return dp[i][W] = (W / wt[i]) * val[i];\r\n        }\r\n        else return dp[i][W] = 0;\r\n    }\r\n    \r\n    if(dp[i][W] != -1) return dp[i][W];\r\n    \r\n    int take = INT_MIN;\r\n    if(W >= wt[i]) take = val[i] + fmemo(i, val, wt, W - wt[i], dp);\r\n    int notake = fmemo(i - 1, val, wt, W, dp);\r\n    \r\n    return dp[i][W] = max(take, notake);\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int val[], int wt[], int weight){\r\n    vector<vector<int>> dp(n,vector<int>(weight+1));\r\n    for(int i=0; i<n; i++){\r\n        for(int W=0; W<=weight; W++){\r\n            if(i==0){\r\n                if(W >= wt[i]) dp[i][W] = (W/wt[i])*val[i];\r\n                else dp[i][W] = 0;\r\n                continue;\r\n            }\r\n            int take = INT_MIN;\r\n            if(W >= wt[i]) take = val[i]+dp[i][W-wt[i]];\r\n            int notake = dp[i-1][W];\r\n            dp[i][W] = max(take,notake);\r\n        }\r\n    }\r\n    return dp[n-1][weight];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int val[], int wt[], int weight){\r\n    vector<int> prev(weight+1);\r\n    for(int i=0; i<n; i++){\r\n        vector<int> curr(weight+1);\r\n        for(int W=0; W<=weight; W++){\r\n            if(i==0){\r\n                if(W >= wt[i]) curr[W] = (W/wt[i])*val[i];\r\n                else curr[W] = 0;\r\n                continue;\r\n            }\r\n            int take = INT_MIN;\r\n            if(W >= wt[i]) take = val[i]+curr[W-wt[i]];\r\n            int notake = prev[W];\r\n            curr[W] = max(take,notake);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return dp[n-1][weight];\r\n}\r\n\r\n\r\nint knapSack(int N, int W, int val[], int wt[]){\r\n    vector<vector<int>> dp(N, vector<int>(W + 1, -1));\r\n    return fmemo(N - 1, val, wt, W, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=0; i<n; i++)",
        "for(int W=0; W<=weight; W++)",
        "for(int i=0; i<n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\10. Unbounded Knapsack.cpp",
      "verified": false,
      "needsReview": true
    },
    "rod-cutting-problem": {
      "id": "rod-cutting-problem",
      "title": "Rod Cutting Problem",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a rod of length 'N' inches and an array of prices 'price[]', where \r\nprice[i] denotes the value of a piece of length 'i', determine the maximum \r\nvalue obtainable by cutting up the rod and selling the pieces.\r\n\r\nExample:\r\nInput: N = 8, Price[] = {1, 5, 8, 9, 10, 17, 17, 20}\r\nOutput: 22\r\nExplanation: The maximum obtainable value is 22 by cutting in two pieces \r\n             of lengths 2 and 6, i.e., 5 + 17 = 22.",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the maximum \r\n  value obtainable by cutting a rod of length 'i' with available pieces \r\n  up to length 'j'.\r\n- Base case: dp[0][j] = 0 (no rod, so value is 0)\r\n- For each length 'i' and each possible total length 'j':\r\n  - dp[i][j] = max(dp[i-1][j], price[i] + dp[i][j - i])\r\n- The required answer will be dp[N][N] where 'N' is the given length of \r\n  the rod.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(N^2), where 'N' is the length \r\n  of the rod.\r\n- The space complexity is O(N^2) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memeoization\r\nint fmemo(int i, int val[], int W, vector<vector<int>>& dp){\r\n    if(i == 1){\r\n        return (W / i) * val[i - 1];\r\n    }\r\n    \r\n    if(dp[i][W] != -1) return dp[i][W];\r\n    \r\n    int take = INT_MIN;\r\n    if(W >= i) take = val[i - 1] + fmemo(i, val, W - i, dp);\r\n    int notake = fmemo(i - 1, val, W, dp);\r\n    \r\n    return dp[i][W] = max(take, notake);\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int val[]){\r\n    vector<vector<int>> dp(n+1,vector<int>(n+1));\r\n    for(int i=1; i<n; i++){\r\n        for(int W=0; W<=n; W++){\r\n            if(i==1){\r\n                dp[i][W] = (W / i) * val[i - 1];\r\n                continue;\r\n            }\r\n            int take = INT_MIN;\r\n            if(W >= i) take = val[i]+dp[i][W-i];\r\n            int notake = dp[i-1][W];\r\n            dp[i][W] = max(take,notake);\r\n        }\r\n    }\r\n    return dp[n][n];\r\n}\r\n\r\nint cutRod(int price[], int N) {\r\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1, -1));\r\n    return fmemo(N, price, N, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=1; i<n; i++)",
        "for(int W=0; W<=n; W++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\4. DP on Subsequences\\11. Rod Cutting Problem.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-common-subsequence": {
      "id": "longest-common-subsequence",
      "title": "Longest Common Subsequence",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given two strings 'text1' and 'text2', return the length of their longest \r\ncommon subsequence. If there is no common subsequence, return 0.\r\n\r\nA subsequence of a string is a new string generated from the original \r\nstring with some characters (can be none) deleted without changing the \r\nrelative order of the remaining characters.\r\n\r\nExample:\r\nInput: text1 = \"abcde\", text2 = \"ace\"\r\nOutput: 3\r\nExplanation: The longest common subsequence is \"ace\" and its length is 3.",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the length of \r\n  the longest common subsequence between the prefixes text1[0..i] and \r\n  text2[0..j].\r\n- Base case: dp[i][0] = 0 (empty second string) and dp[0][j] = 0 \r\n  (empty first string).\r\n- For each character at index 'i' in text1 and each character at index \r\n  'j' in text2:\r\n  - If text1[i] == text2[j], then dp[i][j] = dp[i-1][j-1] + 1\r\n  - Else, dp[i][j] = max(dp[i-1][j], dp[i][j-1])\r\n- The required answer will be dp[n-1][m-1] where 'n' is the length of \r\n  text1 and 'm' is the length of text2.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n*m), where 'n' and 'm' are \r\n  the lengths of text1 and text2 respectively.\r\n- The space complexity is O(n*m) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int j, string& s, string& r, vector<vector<int>>& dp){\r\n    if(i < 0 || j < 0) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    if(s[i] == r[j]) return dp[i][j] = fmemo(i - 1, j - 1, s, r, dp) + 1;\r\n    else return dp[i][j] = max(fmemo(i - 1, j, s, r, dp), fmemo(i, j - 1, s, r, dp));\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int m, string& s, string& r){\r\n    vector<vector<int>> dp(n+1,vector<int>(m+1,0));\r\n    for(int i=1; i<=n; i++){\r\n        for(int j=1; j<=m; j++){\r\n            if(s[i-1]==r[j-1]) dp[i][j] = dp[i-1][j-1]+1;\r\n            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\r\n        }\r\n    }\r\n    return dp[n][m];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int m, string& s, string& r){\r\n    vector<int> prev(m+1,0);\r\n    for(int i=1; i<=n; i++){\r\n        vector<int> curr(m+1,0);\r\n        for(int j=1; j<=m; j++){\r\n            if(s[i-1]==r[j-1]) curr[j] = prev[j-1]+1;\r\n            else curr[j] = max(prev[j],curr[j-1]);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[m];\r\n}\r\n\r\nint longestCommonSubsequence(string text1, string text2) {\r\n    int n = text1.size(), m = text2.size();\r\n    vector<vector<int>> dp(n, vector<int>(m, -1));\r\n    return fmemo(n - 1, m - 1, text1, text2, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=1; i<=n; i++)",
        "for(int j=1; j<=m; j++)",
        "for(int i=1; i<=n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\01. Longest Common Subsequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "print-the-lcs": {
      "id": "print-the-lcs",
      "title": "Print the LCS",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Print the Longest Common Subsequence between two strings.",
      "approach": "- We will use dynamic programming to find the longest common subsequence (LCS) between two strings.\r\n- We will create a 2D array 'dp' of size (n+1) x (m+1), where n is the length of the first string and m is the length of the second string.\r\n- dp[i][j] will store the length of LCS between the first i characters of string s1 and the first j characters of string s2.\r\n- We will iterate through the strings and fill up the dp array as follows:\r\n  - If s1[i-1] matches s2[j-1], then dp[i][j] = dp[i-1][j-1] + 1, as we are extending the LCS by one character.\r\n  - Otherwise, dp[i][j] = max(dp[i-1][j], dp[i][j-1]), taking the maximum length LCS till the previous characters.\r\n- Once the dp array is filled, we will backtrack from the bottom-right corner (dp[n][m]) to reconstruct the LCS.\r\n- We will start from dp[n][m] and go to dp[0][0], following the conditions mentioned above. If s1[i-1] matches s2[j-1], we add that character to the LCS.\r\n- Finally, we reverse the obtained LCS to get the correct order.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the dynamic programming part is O(n * m), where n is the length of the first string and m is the length of the second string.\r\n- The space complexity is also O(n * m) due to the dp array.\r\n- The space required for storing the LCS is O(min(n, m)), which is the maximum length of the LCS.\r\n- Overall, the algorithm runs in O(n * m) time and O(n * m) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nvoid ftab(int n, int m, string &s1, string &s2, vector<vector<int>> &dp) {\r\n    for (int i = 1; i <= n; i++) {\r\n        for (int j = 1; j <= m; j++) {\r\n            if (s1[i - 1] == s2[j - 1])\r\n                dp[i][j] = dp[i - 1][j - 1] + 1;\r\n            else\r\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n    }\r\n}\r\n\r\nstring findLCS(int n, int m, string &s1, string &s2) {\r\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\r\n    ftab(n, m, s1, s2, dp);\r\n    int i = n, j = m;\r\n    string lcs = \"\";\r\n    while (i > 0 && j > 0) {\r\n        if (s1[i - 1] == s2[j - 1]) {\r\n            lcs += s1[i - 1];\r\n            i = i - 1;\r\n            j = j - 1;\r\n        } else {\r\n            if (dp[i - 1][j] > dp[i][j - 1])\r\n                i = i - 1;\r\n            else\r\n                j = j - 1;\r\n        }\r\n    }\r\n    reverse(lcs.begin(), lcs.end());\r\n    return lcs;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for (int i = 1; i <= n; i++)",
        "for (int j = 1; j <= m; j++)",
        "while (i > 0 && j > 0)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\02. Print the LCS.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-common-substring": {
      "id": "longest-common-substring",
      "title": "Longest Common Substring",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given two strings. The task is to find the length of the longest common substring.\r\n\r\nExample:\r\nInput: S1 = \"ABCDGH\", S2 = \"ACDGHR\", n = 6, m = 6\r\nOutput: 4\r\nExplanation: The longest common substring is \"CDGH\" which has length 4.",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the length of \r\n  the longest common suffix of substrings S1[0..i-1] and S2[0..j-1].\r\n- Initialize a variable 'maxi' to keep track of the maximum length found.\r\n- For each character at index 'i' in S1 and each character at index 'j' \r\n  in S2:\r\n  - If S1[i] == S2[j], then dp[i][j] = dp[i-1][j-1] + 1\r\n  - Else, dp[i][j] = 0 (as no common suffix found)\r\n  - Update 'maxi' with dp[i][j]\r\n- The required answer will be 'maxi'.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n*m), where 'n' and 'm' are \r\n  the lengths of S1 and S2 respectively.\r\n- The space complexity is O(n*m) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint maxi = 0;\r\n\r\nint fmemo(int i, int j, string& s, string& r, vector<vector<int>>& dp){\r\n    if(i < 0 || j < 0) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    if(s[i] == r[j]){\r\n        dp[i][j] = fmemo(i - 1, j - 1, s, r, dp) + 1;\r\n        maxi = max(maxi, dp[i][j]);\r\n    }\r\n    else dp[i][j] = 0;\r\n\r\n    fmemo(i - 1, j, s, r, dp);\r\n    fmemo(i, j - 1, s, r, dp);\r\n\r\n    return dp[i][j];\r\n}\r\n\r\nint longestCommonSubstr(string S1, string S2, int n, int m){\r\n    vector<vector<int>> dp(n, vector<int>(m, -1));\r\n    fmemo(n - 1, m - 1, S1, S2, dp);\r\n    return maxi;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\03. Longest Common Substring.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-palindromic-subsequence": {
      "id": "longest-palindromic-subsequence",
      "title": "Longest Palindromic Subsequence",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a string s, find the longest palindromic subsequence's length in s.\r\n\r\nExample:\r\nInput: s = \"bbbab\"\r\nOutput: 4\r\nExplanation: One possible longest palindromic subsequence is \"bbbb\".",
      "approach": "- This problem can be solved using Dynamic Programming (DP).\r\n- Initialize a 2D DP array 'dp' where dp[i][j] represents the length of \r\n  the longest palindromic subsequence in the substring s[i..j].\r\n- For each character at index 'i' and each character at index 'j':\r\n  - If s[i] == s[j], then dp[i][j] = dp[i+1][j-1] + 2\r\n  - Else, dp[i][j] = max(dp[i+1][j], dp[i][j-1])\r\n- The required answer will be dp[0][n-1], where 'n' is the length of 's'.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of the solution is O(n^2), where 'n' is the length of the input string.\r\n- The space complexity is O(n^2) for the dp array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n// Memoization\r\nint fmemo(int i, int j, string& s, string& r, vector<vector<int>>& dp){\r\n    if(i < 0 || j < 0) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    if(s[i] == r[j]) return dp[i][j] = fmemo(i - 1, j - 1, s, r, dp) + 1;\r\n    else return dp[i][j] = max(fmemo(i - 1, j, s, r, dp), fmemo(i, j - 1, s, r, dp));\r\n}\r\n\r\n// Tabulation\r\nint ftab(int n, int m, string& s, string& r){\r\n    vector<vector<int>> dp(n+1,vector<int>(m+1,0));\r\n    for(int i=1; i<=n; i++){\r\n        for(int j=1; j<=m; j++){\r\n            if(s[i-1]==r[j-1]) dp[i][j] = dp[i-1][j-1]+1;\r\n            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\r\n        }\r\n    }\r\n    return dp[n][m];\r\n}\r\n\r\n// Space Optimization\r\nint fopt(int n, int m, string& s, string& r){\r\n    vector<int> prev(m+1,0);\r\n    for(int i=1; i<=n; i++){\r\n        vector<int> curr(m+1,0);\r\n        for(int j=1; j<=m; j++){\r\n            if(s[i-1]==r[j-1]) curr[j] = prev[j-1]+1;\r\n            else curr[j] = max(prev[j],curr[j-1]);\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev[m];\r\n}\r\n\r\nint longestPalindromeSubseq(string s) {\r\n    int n = s.size();\r\n    string r = s;\r\n    reverse(r.begin(),r.end());\r\n    vector<vector<int>> dp(n, vector<int>(n, -1));\r\n    return fmemo(n-1,n-1,s,r,dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=1; i<=n; i++)",
        "for(int j=1; j<=m; j++)",
        "for(int i=1; i<=n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\04. Longest Palindromic Subsequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-steps-to-make-string-palindrome": {
      "id": "minimum-steps-to-make-string-palindrome",
      "title": "Minimum steps to make string palindrome",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a string s. In one step you can insert any character at any index of the string.\r\nReturn the minimum number of steps to make s palindrome.",
      "approach": "- The problem can be reduced to finding the minimum number of insertions needed to make a string a palindrome.\r\n- We can find the Longest Common Subsequence (LCS) between the given string and its reverse.\r\n- The length of the LCS gives us the length of the longest palindromic subsequence in the string.\r\n- The minimum number of insertions required to make the string a palindrome is equal to the difference between the length of the string and the length of the LCS.\r\n- Return this difference as the answer.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of finding the LCS is O(n^2), where n is the length of the string.\r\n- The space complexity is O(n^2) due to the dp array.\r\n- Overall, the algorithm runs in O(n^2) time and O(n^2) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nint fmemo(int i, int j, string &s, string &r, vector<vector<int>> &dp) {\r\n    if (i < 0 || j < 0)\r\n        return 0;\r\n\r\n    if (dp[i][j] != -1)\r\n        return dp[i][j];\r\n\r\n    if (s[i] == r[j])\r\n        return dp[i][j] = fmemo(i - 1, j - 1, s, r, dp) + 1;\r\n    else\r\n        return dp[i][j] = max(fmemo(i - 1, j, s, r, dp), fmemo(i, j - 1, s, r, dp));\r\n}\r\n\r\nint minInsertions(string s) {\r\n    int n = s.size();\r\n    string r = s;\r\n    reverse(r.begin(), r.end());\r\n    vector<vector<int>> dp(n, vector<int>(n, -1));\r\n    int lcs = fmemo(n - 1, n - 1, s, r, dp);\r\n    return n - lcs;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\05. Minimum steps to make string palindrome.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-steps-to-make-other-string": {
      "id": "minimum-steps-to-make-other-string",
      "title": "Minimum steps to make other string",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\r\nIn one step, you can delete exactly one character in either string.",
      "approach": "- The problem can be reduced to finding the length of the Longest Common Subsequence (LCS) between the two strings.\r\n- The idea is to find the length of the LCS and then subtracting it from the sum of the lengths of the two strings.\r\n- The reason is that the characters not present in the LCS need to be deleted from both strings to make them the same.\r\n- Therefore, the minimum number of steps required is equal to the sum of the lengths of the strings minus twice the length of the LCS.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of finding the LCS is O(n*m), where n and m are the lengths of the two strings.\r\n- The space complexity is O(n*m) due to the dp array.\r\n- Overall, the algorithm runs in O(n*m) time and O(n*m) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\n\r\nint fmemo(int i, int j, string &s, string &r, vector<vector<int>> &dp) {\r\n    if (i < 0 || j < 0)\r\n        return 0;\r\n\r\n    if (dp[i][j] != -1)\r\n        return dp[i][j];\r\n\r\n    if (s[i] == r[j])\r\n        return dp[i][j] = fmemo(i - 1, j - 1, s, r, dp) + 1;\r\n    else\r\n        return dp[i][j] = max(fmemo(i - 1, j, s, r, dp), fmemo(i, j - 1, s, r, dp));\r\n}\r\n\r\nint minDistance(string word1, string word2) {\r\n    int n = word1.size(), m = word2.size();\r\n    vector<vector<int>> dp(n, vector<int>(m, -1));\r\n    int lcs = fmemo(n - 1, m - 1, word1, word2, dp);\r\n    return (n + m) - 2 * lcs;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\06. Minimum steps to make other string.cpp",
      "verified": false,
      "needsReview": true
    },
    "shortest-common-supersequence": {
      "id": "shortest-common-supersequence",
      "title": "Shortest Common Supersequence",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. \r\nIf there are multiple valid strings, return any of them.",
      "approach": "- This problem can be solved using dynamic programming to find the length of the shortest common supersequence (SCS).\r\n- The SCS is the shortest string that contains both str1 and str2 as subsequences.\r\n- The idea is to first find the length of the SCS using a dynamic programming approach.\r\n- Once the length is found, we can construct the SCS using the dp array and backtracking.\r\n- We start from the last cell of the dp array and move either diagonally (when characters match) or towards the direction with the greater value.\r\n- During backtracking, we append the characters from str1 or str2 to the SCS string based on the movement direction.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of finding the length of the SCS is O(n*m), where n and m are the lengths of the two strings.\r\n- The space complexity is O(n*m) due to the dp array.\r\n- The backtracking process takes O(n + m) time.\r\n- Overall, the algorithm runs in O(n*m) time and O(n*m) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nstring shortestCommonSupersequence(string str1, string str2) {\r\n    int n = str1.size(), m = str2.size();\r\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\r\n\r\n    for (int i = 1; i <= n; i++) {\r\n        for (int j = 1; j <= m; j++) {\r\n            if (str1[i - 1] == str2[j - 1])\r\n                dp[i][j] = dp[i - 1][j - 1] + 1;\r\n            else\r\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n    }\r\n\r\n    int i = n, j = m;\r\n    string scs = \"\";\r\n    while (i > 0 && j > 0) {\r\n        if (str1[i - 1] == str2[j - 1]) {\r\n            scs = str1[i - 1] + scs;\r\n            i--;\r\n            j--;\r\n        } else {\r\n            if (dp[i - 1][j] > dp[i][j - 1]) {\r\n                scs = str1[i - 1] + scs;\r\n                i--;\r\n            } else {\r\n                scs = str2[j - 1] + scs;\r\n                j--;\r\n            }\r\n        }\r\n    }\r\n    while (i > 0) {\r\n        scs = str1[i - 1] + scs;\r\n        i--;\r\n    }\r\n    while (j > 0) {\r\n        scs = str2[j - 1] + scs;\r\n        j--;\r\n    }\r\n    return scs;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming",
        "recursion",
        "backtracking"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<int>",
        "for (int i = 1; i <= n; i++)",
        "for (int j = 1; j <= m; j++)",
        "while (i > 0 && j > 0)",
        "while (i > 0)",
        "while (j > 0)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\07. Shortest Common Supersequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "distinct-subsequences": {
      "id": "distinct-subsequences",
      "title": "Distinct Subsequences",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given two strings s and t, return the number of distinct subsequences of s which equals t.",
      "approach": "- The problem can be solved using dynamic programming.\r\n- Let dp[i][j] represent the number of distinct subsequences of the first i characters of string s that match the first j characters of string t.\r\n- If s[i] equals t[j], we have two choices: we can either include the current character (s[i]) in the subsequence, in which case we add dp[i-1][j-1] to our count, or we can exclude it and move on, so we add dp[i-1][j] to our count.\r\n- If s[i] doesn't match t[j], we have no choice but to exclude s[i], so we add dp[i-1][j] to our count.\r\n- Base cases: When j equals -1 (meaning we've matched all characters of t), return 1. When i equals -1 (meaning we've exhausted all characters of s), return 0.\r\n- Return dp[n-1][m-1], where n is the length of s and m is the length of t.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n * m), where n is the length of string s and m is the length of string t.\r\n- The space complexity is O(n * m) due to the dp array.\r\n- Overall, the algorithm runs in O(n * m) time and O(n * m) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int j, string& s, string& t, vector<vector<int>>& dp) {\r\n    if (j < 0) return 1;\r\n    if (i < 0) return 0;\r\n    if (dp[i][j] != -1) return dp[i][j];\r\n    if (s[i] == t[j])\r\n        return dp[i][j] = fmemo(i - 1, j - 1, s, t, dp) + fmemo(i - 1, j, s, t, dp);\r\n    else\r\n        return dp[i][j] = fmemo(i - 1, j, s, t, dp);\r\n}\r\n\r\nint ftab(int n, int m, string& s, string& t){\r\n    vector<vector<int>> dp(n+1,vector<int>(m+1));\r\n    for(int i=1; i<=n; i++){\r\n        for(int j=1; j<=m; j++){\r\n            if(s[i-1]==t[j-1]) dp[i][j] = dp[i-1][j-1]+dp[i-1][j];\r\n            else dp[i][j] = dp[i-1][j];\r\n        }\r\n    }\r\n    return dp[n-1][m-1];\r\n}\r\n\r\nint numDistinct(string s, string t) {\r\n    int n = s.size(), m = t.size();\r\n    vector<vector<int>> dp(n, vector<int>(m, -1));\r\n    return fmemo(n - 1, m - 1, s, t, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i=1; i<=n; i++)",
        "for(int j=1; j<=m; j++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\08. Distinct Subsequences.cpp",
      "verified": false,
      "needsReview": true
    },
    "wildcard-matching": {
      "id": "wildcard-matching",
      "title": "Wildcard Matching",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\r\n- '?' Matches any single character.\r\n- '*' Matches any sequence of characters (including the empty sequence).\r\nThe matching should cover the entire input string (not partial).",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Let dp[i][j] represent whether the substring of s up to index i can be matched with the substring of p up to index j.\r\n- If s[i] equals p[j] or p[j] is '?', the characters match and we move diagonally to check the next characters.\r\n- If p[j] is '*', we have two options:\r\n  1. Move vertically up (skip the '*').\r\n  2. Move horizontally left (count '*' as matching zero characters).\r\n- Base cases: When both i and j are -1, return true. When only j is -1, check if the remaining characters in p are all '*'.\r\n- Return dp[n-1][m-1], where n is the length of s and m is the length of p.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n * m), where n is the length of string s and m is the length of string p.\r\n- The space complexity is O(n * m) due to the dp array.\r\n- Overall, the algorithm runs in O(n * m) time and O(n * m) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool allStars(int i, string& p) {\r\n    for (int j = i; j >= 0; j--) {\r\n        if (p[j] != '*') return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nint fmemo(int i, int j, string& s, string& p, vector<vector<int>>& dp) {\r\n    if (i < 0 && j < 0) return true;\r\n    if (j < 0 && i >= 0) return false;\r\n    if (i < 0 && j >= 0) {\r\n        if (allStars(j, p)) return true;\r\n        return false;\r\n    }\r\n    \r\n    if (dp[i][j] != -1) return dp[i][j];\r\n\r\n    if (s[i] == p[j] || p[j] == '?')\r\n        return dp[i][j] = fmemo(i - 1, j - 1, s, p, dp);\r\n    else {\r\n        if (p[j] == '*')\r\n            return dp[i][j] = (fmemo(i - 1, j, s, p, dp) || fmemo(i, j - 1, s, p, dp));\r\n        return dp[i][j] = false;\r\n    }\r\n}\r\n\r\nbool isMatch(string s, string p) {\r\n    int n = s.size(), m = p.size();\r\n    vector<vector<int>> dp(n, vector<int>(m, -1));\r\n    return fmemo(n - 1, m - 1, s, p, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for (int j = i; j >= 0; j--)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\5. DP on Strings\\09. Wildcard Matching.cpp",
      "verified": false,
      "needsReview": true
    },
    "best-time-to-buy-and-sell-stocks": {
      "id": "best-time-to-buy-and-sell-stocks",
      "title": "Best time to buy and sell stocks",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\r\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\r\n\r\nExample:\r\nInput: prices = [7, 1, 5, 3, 6, 4]\r\nOutput: 5\r\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5.\r\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.",
      "approach": "- Initialize a variable minprice with the price on the first day and initialize ans to 0.\r\n- Iterate through the array from the second day to the last day.\r\n- Update ans with the maximum of its current value and the difference between the current price and minprice.\r\n- Update minprice with the minimum of its current value and the current price.\r\n- Return the final value of ans.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n), where n is the length of the prices array.\r\n- The space complexity is O(1) as we are using constant extra space.\r\n- Overall, the algorithm runs in O(n) time and O(1) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint maxProfit(vector<int>& prices) {\r\n    int minprice = prices[0];\r\n    int ans = 0;\r\n    for(int i = 1; i < prices.size(); i++){\r\n        ans = max(ans, prices[i] - minprice);\r\n        minprice = min(minprice, prices[i]);\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "for(int i = 1; i < prices.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\01. Best time to buy and sell stocks.cpp",
      "verified": false,
      "needsReview": true
    },
    "best-time-to-buy-and-sell-stock-2": {
      "id": "best-time-to-buy-and-sell-stock-2",
      "title": "Best time to buy and sell stock 2",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\r\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time.\r\nHowever, you can buy it then immediately sell it on the same day.\r\nFind and return the maximum profit you can achieve.\r\n\r\nExample:\r\nInput: prices = [7, 1, 5, 3, 6, 4]\r\nOutput: 7\r\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4.\r\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3.\r\nTotal profit is 4 + 3 = 7.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to keep track of whether we are holding a stock or not on each day.\r\n- Define a 2D DP array `dp` where dp[i][hold] represents the maximum profit achievable starting from day i while holding or not holding a stock.\r\n- The base case is dp[n][0] = dp[n][1] = 0, where n is the number of days.\r\n- Iterate through each day i in reverse order.\r\n- If holding a stock, we can either sell the stock or continue holding.\r\n- If not holding a stock, we can either buy the stock or continue not holding.\r\n- Return dp[0][0], which represents the maximum profit achievable starting from day 0 while not holding a stock.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n), where n is the number of days.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int hold, vector<int>& prices, vector<vector<int>>& dp){\r\n    if(i == prices.size()) return 0;\r\n\r\n    if(dp[i][hold] != -1) return dp[i][hold];\r\n\r\n    if(hold){\r\n        // sell \r\n        int a = prices[i] + fmemo(i + 1, 0, prices, dp);\r\n        // not sell\r\n        int b = fmemo(i + 1, 1, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n    else{\r\n        // buy\r\n        int a = -prices[i] + fmemo(i + 1, 1, prices, dp);\r\n        // not buy\r\n        int b = fmemo(i + 1, 0, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n}\r\n\r\nint maxProfit(vector<int>& prices) {\r\n    int n = prices.size();\r\n    vector<vector<int>> dp(n, vector<int>(2, -1));\r\n    return fmemo(0, 0, prices, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\02. Best time to buy and sell stock 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "best-time-to-buy-and-sell-stock-upto-2-transaction": {
      "id": "best-time-to-buy-and-sell-stock-upto-2-transaction",
      "title": "Best time to buy and sell stock upto 2 transaction",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\nFind the maximum profit you can achieve. You may complete at most two transactions.\r\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\r\n\r\nExample:\r\nInput: prices = [3, 3, 5, 0, 0, 3, 1, 4]\r\nOutput: 6\r\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3.\r\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4 - 1 = 3.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to keep track of the number of transactions completed so far (cap) and whether we are holding a stock or not on each day.\r\n- Define a 3D DP array `dp` where dp[i][hold][cap] represents the maximum profit achievable starting from day i while holding or not holding a stock and having completed cap transactions.\r\n- The base case is dp[n][0][0] = dp[n][0][1] = dp[n][0][2] = dp[n][1][0] = dp[n][1][1] = dp[n][1][2] = 0, where n is the number of days.\r\n- Iterate through each day i in reverse order.\r\n- If holding a stock, we can either sell the stock or continue holding.\r\n- If not holding a stock, we can either buy the stock or continue not holding.\r\n- Return dp[0][0][0], which represents the maximum profit achievable starting from day 0 while not holding a stock and having completed 0 transactions.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n), where n is the number of days.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int hold, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp){\r\n    if(i == prices.size()) return 0;\r\n    if(cap == 3) return 0;\r\n\r\n    if(dp[i][hold][cap] != -1) return dp[i][hold][cap];\r\n\r\n    if(hold){\r\n        // sell \r\n        int a = prices[i] + fmemo(i + 1, 0, cap, prices, dp);\r\n        // not sell\r\n        int b = fmemo(i + 1, 1, cap, prices, dp);\r\n        return dp[i][hold][cap] = max(a, b);\r\n    }\r\n    else{\r\n        // buy\r\n        int a = -prices[i] + fmemo(i + 1, 1, cap + 1, prices, dp);\r\n        // not buy\r\n        int b = fmemo(i + 1, 0, cap, prices, dp);\r\n        return dp[i][hold][cap] = max(a, b);\r\n    }\r\n}\r\n\r\nint maxProfit(vector<int>& prices) {\r\n    int n = prices.size();\r\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));\r\n    return fmemo(0, 0, 0, prices, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\03. Best time to buy and sell stock upto 2 transaction.cpp",
      "verified": false,
      "needsReview": true
    },
    "best-time-to-buy-and-sell-stock-uoto-k-transaction": {
      "id": "best-time-to-buy-and-sell-stock-uoto-k-transaction",
      "title": "Best time to buy and sell stock uoto k transaction",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\r\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\r\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\r\n\r\nExample:\r\nInput: k = 2, prices = [2, 4, 1]\r\nOutput: 2\r\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4 - 2 = 2.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to keep track of the number of transactions completed so far (cap) and whether we are holding a stock or not on each day.\r\n- Define a 3D DP array `dp` where dp[i][hold][cap] represents the maximum profit achievable starting from day i while holding or not holding a stock and having completed cap transactions.\r\n- The base case is dp[n][0][0] = dp[n][0][1] = ... = dp[n][0][k] = dp[n][1][0] = ... = dp[n][1][k] = 0, where n is the number of days and k is the given limit of transactions.\r\n- Iterate through each day i in reverse order.\r\n- If holding a stock, we can either sell the stock or continue holding.\r\n- If not holding a stock, we can either buy the stock or continue not holding.\r\n- Return dp[0][0][0], which represents the maximum profit achievable starting from day 0 while not holding a stock and having completed 0 transactions.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n * k), where n is the number of days and k is the given limit of transactions.\r\n- The space complexity is O(n * k) due to the dp array.\r\n- Overall, the algorithm runs in O(n * k) time and O(n * k) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint maxi;\r\nint fmemo(int i, int hold, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp){\r\n    if(i == prices.size()) return 0;\r\n    if(cap == maxi + 1) return 0;\r\n\r\n    if(dp[i][hold][cap] != -1) return dp[i][hold][cap];\r\n\r\n    if(hold){\r\n        // sell \r\n        int a = prices[i] + fmemo(i + 1, 0, cap, prices, dp);\r\n        // not sell\r\n        int b = fmemo(i + 1, 1, cap, prices, dp);\r\n        return dp[i][hold][cap] = max(a, b);\r\n    }\r\n    else{\r\n        // buy\r\n        int a = -prices[i] + fmemo(i + 1, 1, cap + 1, prices, dp);\r\n        // not buy\r\n        int b = fmemo(i + 1, 0, cap, prices, dp);\r\n        return dp[i][hold][cap] = max(a, b);\r\n    }\r\n}\r\n\r\nint maxProfit(int k, vector<int>& prices) {\r\n    int n = prices.size();\r\n    maxi = k;\r\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(k + 1, -1)));\r\n    return fmemo(0, 0, 0, prices, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\04. Best time to buy and sell stock uoto k transaction.cpp",
      "verified": false,
      "needsReview": true
    },
    "buy-and-sell-stocks-with-cooldown": {
      "id": "buy-and-sell-stocks-with-cooldown",
      "title": "Buy and sell stocks with cooldown",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\r\n- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\r\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\r\n\r\nExample:\r\nInput: prices = [1, 2, 3, 0, 2]\r\nOutput: 3\r\nExplanation: transactions = [buy, sell, cooldown, buy, sell]",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to keep track of whether we are holding a stock or not on each day.\r\n- Define a 2D DP array `dp` where dp[i][hold] represents the maximum profit achievable starting from day i while holding or not holding a stock.\r\n- The base case is dp[n][0] = dp[n][1] = 0, where n is the number of days.\r\n- Iterate through each day i in reverse order.\r\n- If holding a stock, we can either sell the stock or continue holding.\r\n- If not holding a stock, we can either buy the stock or continue not holding.\r\n- Return dp[0][0], which represents the maximum profit achievable starting from day 0 while not holding a stock.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n), where n is the number of days.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int hold, vector<int>& prices, vector<vector<int>>& dp){\r\n    if(i >= prices.size()) return 0;\r\n\r\n    if(dp[i][hold] != -1) return dp[i][hold];\r\n\r\n    if(hold){\r\n        // sell \r\n        int a = prices[i] + fmemo(i + 2, 0, prices, dp);\r\n        // not sell\r\n        int b = fmemo(i + 1, 1, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n    else{\r\n        // buy\r\n        int a = -prices[i] + fmemo(i + 1, 1, prices, dp);\r\n        // not buy\r\n        int b = fmemo(i + 1, 0, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n}\r\n\r\nint maxProfit(vector<int>& prices) {\r\n    int n = prices.size();\r\n    vector<vector<int>> dp(n, vector<int>(2, -1));\r\n    return fmemo(0, 0, prices, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\05. Buy and sell stocks with cooldown.cpp",
      "verified": false,
      "needsReview": true
    },
    "buy-and-sell-stocks-with-transaction-fee": {
      "id": "buy-and-sell-stocks-with-transaction-fee",
      "title": "Buy and sell stocks with transaction fee",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\r\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\r\nNote:\r\n- You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\r\n- The transaction fee is only charged once for each stock purchase and sale.\r\n\r\nExample:\r\nInput: prices = [1, 3, 2, 8, 4, 9], fee = 2\r\nOutput: 8\r\nExplanation: The maximum profit can be achieved by:\r\n- Buying at prices[0] = 1\r\n- Selling at prices[3] = 8\r\n- Buying at prices[4] = 4\r\n- Selling at prices[5] = 9\r\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to keep track of whether we are holding a stock or not on each day.\r\n- Define a 2D DP array `dp` where dp[i][hold] represents the maximum profit achievable starting from day i while holding or not holding a stock.\r\n- The base case is dp[n][0] = dp[n][1] = 0, where n is the number of days.\r\n- Iterate through each day i.\r\n- If holding a stock, we can either sell the stock or continue holding.\r\n- If not holding a stock, we can either buy the stock or continue not holding.\r\n- Return dp[0][0], which represents the maximum profit achievable starting from day 0 while not holding a stock.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n), where n is the number of days.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint f;\r\nint fmemo(int i, int hold, vector<int>& prices, vector<vector<int>>& dp){\r\n    if(i == prices.size()) return 0;\r\n\r\n    if(dp[i][hold] != -1) return dp[i][hold];\r\n\r\n    if(hold){\r\n        // sell \r\n        int a = prices[i] - f + fmemo(i + 1, 0, prices, dp);\r\n        // not sell\r\n        int b = fmemo(i + 1, 1, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n    else{\r\n        // buy\r\n        int a = -prices[i] + fmemo(i + 1, 1, prices, dp);\r\n        // not buy\r\n        int b = fmemo(i + 1, 0, prices, dp);\r\n        return dp[i][hold] = max(a, b);\r\n    }\r\n}\r\n\r\nint maxProfit(vector<int>& prices, int fee) {\r\n    int n = prices.size();\r\n    f = fee;\r\n    vector<vector<int>> dp(n, vector<int>(2, -1));\r\n    return fmemo(0, 0, prices, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\6. DP on Stocks\\06. Buy and sell stocks with transaction fee.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-increasing-subsequence": {
      "id": "longest-increasing-subsequence",
      "title": "Longest Increasing Subsequence",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Let dp[i] represent the length of the longest increasing subsequence ending at index i.\r\n- For each element at index i, we iterate through all the previous indices (prev) from 0 to i-1.\r\n- If nums[prev] is smaller than nums[i], it means we can extend the increasing subsequence ending at prev by including nums[i].\r\n- We update dp[i] as max(dp[prev] + 1, dp[i]).\r\n- Initialize a variable ans to keep track of the maximum value in dp.\r\n- Return ans as the length of the longest increasing subsequence.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the input array nums.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint ftab(int n, vector<int>& nums) {\r\n    vector<int> dp(n, 1);\r\n    for (int i = 0; i < n; i++) {\r\n        for (int prev = 0; prev < i; prev++) {\r\n            if (nums[prev] < nums[i]) {\r\n                dp[i] = max(dp[prev] + 1, dp[i]);\r\n            }\r\n        }\r\n    }\r\n    int ans = -1;\r\n    for (auto i : dp) ans = max(ans, i);\r\n    return ans;\r\n}\r\n\r\nint lengthOfLIS(vector<int>& nums) {\r\n    int n = nums.size();\r\n    return ftab(n, nums);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int prev = 0; prev < i; prev++)",
        "for (auto i : dp)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\7. DP on LIS\\01. Longest Increasing Subsequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "print-lis": {
      "id": "print-lis",
      "title": "Print LIS",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer n and an array of integers, return the Longest Increasing Subsequence which is lexicographically smallest corresponding to the indices of the elements.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Let dp[i] represent the length of the longest increasing subsequence ending at index i.\r\n- Additionally, maintain a prevmap to track the previous index in the increasing subsequence.\r\n- Iterate through the array and for each index i, iterate through all previous indices (prev) from 0 to i-1.\r\n- If arr[prev] < arr[i] and dp[i] < dp[prev] + 1, update dp[i] and prevmap[i].\r\n- Find the index i where dp has the maximum value.\r\n- Construct the Longest Increasing Subsequence using the prevmap and the found index i.\r\n- Return the LIS in reverse order to get the lexicographically smallest sequence.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the input array arr.\r\n- The space complexity is O(n) due to the dp and prevmap arrays, as well as the lis vector.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> ftab(int n, vector<int>& arr) {\r\n    vector<int> dp(n, 1);\r\n    vector<int> prevmap(n, -1);\r\n    \r\n    for (int i = 0; i < n; i++) {\r\n        for (int prev = 0; prev < i; prev++) {\r\n            if (arr[prev] < arr[i] && dp[i] < dp[prev] + 1) {\r\n                dp[i] = dp[prev] + 1;\r\n                prevmap[i] = prev;\r\n            }\r\n        }\r\n    }\r\n    \r\n    int i = max_element(dp.begin(), dp.end()) - dp.begin();\r\n    vector<int> lis;\r\n    \r\n    while (i >= 0) {\r\n        lis.push_back(arr[i]);\r\n        i = prevmap[i];\r\n    }\r\n    \r\n    reverse(lis.begin(), lis.end());\r\n    return lis;\r\n}\r\n\r\nvector<int> longestIncreasingSubsequence(int n, vector<int>& arr) {\r\n    return ftab(n, arr);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int prev = 0; prev < i; prev++)",
        "while (i >= 0)",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\7. DP on LIS\\02. Print LIS.cpp",
      "verified": false,
      "needsReview": true
    },
    "largest-divisible-subset": {
      "id": "largest-divisible-subset",
      "title": "Largest Divisible Subset",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\r\n- answer[i] % answer[j] == 0, or\r\n- answer[j] % answer[i] == 0\r\nIf there are multiple solutions, return any of them.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Sort the input array nums in ascending order.\r\n- Let dp[i] represent the size of the largest divisible subset ending at index i.\r\n- Additionally, maintain a prevmap to track the previous index in the subset.\r\n- Iterate through the sorted array and for each index i, iterate through all previous indices (prev) from 0 to i-1.\r\n- If nums[i] is divisible by nums[prev] and dp[i] < dp[prev] + 1, update dp[i] and prevmap[i].\r\n- Find the index i where dp has the maximum value.\r\n- Construct the largest divisible subset using the prevmap and the found index i.\r\n- Return the subset.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the input array nums.\r\n- The space complexity is O(n) due to the dp and prevmap arrays, as well as the lis vector.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> ftab(int n, vector<int>& nums) {\r\n    vector<int> dp(n, 1);\r\n    vector<int> prevmap(n, -1);\r\n    \r\n    for (int i = 0; i < n; i++) {\r\n        for (int prev = 0; prev < i; prev++) {\r\n            if (nums[i] % nums[prev] == 0 && dp[i] < dp[prev] + 1) {\r\n                dp[i] = dp[prev] + 1;\r\n                prevmap[i] = prev;\r\n            }\r\n        }\r\n    }\r\n    \r\n    int i = max_element(dp.begin(), dp.end()) - dp.begin();\r\n    vector<int> lis;\r\n    \r\n    while (i >= 0) {\r\n        lis.push_back(nums[i]);\r\n        i = prevmap[i];\r\n    }\r\n    \r\n    return lis;\r\n}\r\n\r\nvector<int> largestDivisibleSubset(vector<int>& nums) {\r\n    int n = nums.size();\r\n    sort(nums.begin(), nums.end());\r\n    return ftab(n, nums);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-map",
        "hash-set",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int prev = 0; prev < i; prev++)",
        "while (i >= 0)",
        "sort(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\7. DP on LIS\\03. Largest Divisible Subset.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-bitonic-subsequence": {
      "id": "longest-bitonic-subsequence",
      "title": "Longest Bitonic Subsequence",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an array of positive integers, find the maximum length of a Bitonic subsequence.\r\nA subsequence of an array is called Bitonic if it is first strictly increasing and then strictly decreasing.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Compute two DP arrays: one from the left and another from the right.\r\n- The left DP array, `left`, represents the length of the longest increasing subsequence ending at index i.\r\n- The right DP array, `right`, represents the length of the longest decreasing subsequence starting at index i.\r\n- Iterate through the array and compute the `left` DP array, considering elements from the left to the right.\r\n- Iterate through the array again and compute the `right` DP array, considering elements from the right to the left.\r\n- The maximum length of the Bitonic subsequence is the maximum sum of the corresponding elements from the `left` and `right` DP arrays minus 1 (to avoid double counting the element at the peak).\r\n- Return the maximum length.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the input array nums.\r\n- The space complexity is O(n) due to the left and right DP arrays.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> fromLeft(int n, vector<int>& nums) {\r\n    vector<int> dp(n, 1);\r\n    for (int i = 0; i < n; i++) {\r\n        for (int prev = 0; prev < i; prev++) {\r\n            if (nums[prev] < nums[i]) {\r\n                dp[i] = max(dp[prev] + 1, dp[i]);\r\n            }\r\n        }\r\n    }\r\n    return dp;\r\n}\r\n\r\nvector<int> fromRight(int n, vector<int>& nums) {\r\n    vector<int> dp(n, 1);\r\n    for (int i = n - 1; i >= 0; i--) {\r\n        for (int prev = i + 1; prev < n; prev++) {\r\n            if (nums[prev] < nums[i]) {\r\n                dp[i] = max(dp[prev] + 1, dp[i]);\r\n            }\r\n        }\r\n    }\r\n    return dp;\r\n}\r\n\r\nint LongestBitonicSequence(vector<int> nums) {\r\n    int n = nums.size();\r\n    vector<int> left = fromLeft(n, nums);\r\n    vector<int> right = fromRight(n, nums);\r\n    \r\n    int ans = -1;\r\n    for (int i = 0; i < n; i++) {\r\n        ans = max(ans, left[i] + right[i] - 1);\r\n    }\r\n    \r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers",
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int prev = 0; prev < i; prev++)",
        "for (int i = n - 1; i >= 0; i--)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\7. DP on LIS\\04. Longest Bitonic Subsequence.cpp",
      "verified": false,
      "needsReview": true
    },
    "number-of-lis": {
      "id": "number-of-lis",
      "title": "Number of LIS",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums, return the number of longest increasing subsequences.\r\nNotice that the sequence has to be strictly increasing.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Compute two DP arrays: one for the length of the longest increasing subsequence ending at index i (`dp`) and another for the count of such subsequences (`cnt`).\r\n- Iterate through the array and for each index i, iterate through all previous indices (prev) from 0 to i-1.\r\n- If nums[prev] < nums[i], update the `dp` and `cnt` arrays accordingly.\r\n- Find the maximum value in the `dp` array to get the length of the longest increasing subsequence (`lis`).\r\n- Iterate through the `dp` array again and count the number of subsequences that have the length equal to `lis`.\r\n- Return the total count of such subsequences.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the input array nums.\r\n- The space complexity is O(n) due to the dp and cnt arrays.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint ftab(int n, vector<int>& nums) {\r\n    vector<int> dp(n, 1);\r\n    vector<int> cnt(n, 1);\r\n    \r\n    for (int i = 0; i < n; i++) {\r\n        for (int prev = 0; prev < i; prev++) {\r\n            if (nums[prev] < nums[i]) {\r\n                if (dp[i] == dp[prev] + 1) {\r\n                    cnt[i] += cnt[prev];\r\n                } else if (dp[prev] + 1 > dp[i]) {\r\n                    dp[i] = dp[prev] + 1;\r\n                    cnt[i] = cnt[prev];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    int lis = *max_element(dp.begin(), dp.end());\r\n    int ans = 0;\r\n    \r\n    for (int i = 0; i < n; i++) {\r\n        if (dp[i] == lis) {\r\n            ans += cnt[i];\r\n        }\r\n    }\r\n    \r\n    return ans;\r\n}\r\n\r\nint findNumberOfLIS(vector<int>& nums) {\r\n    int n = nums.size();\r\n    return ftab(n, nums);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for (int i = 0; i < n; i++)",
        "for (int prev = 0; prev < i; prev++)",
        "for (int i = 0; i < n; i++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\7. DP on LIS\\05. Number of LIS.cpp",
      "verified": false,
      "needsReview": true
    },
    "mcm": {
      "id": "mcm",
      "title": "MCM",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a sequence of matrices, find the most efficient way to multiply these matrices together. The efficient way is the one that involves the least number of multiplications.\r\nThe dimensions of the matrices are given in an array arr[] of size N (such that N = number of matrices + 1) where the ith matrix has the dimensions (arr[i-1] x arr[i]).\r\n\r\nExample 1:\r\nInput: N = 5\r\narr = {40, 20, 30, 10, 30}\r\nOutput: 26000\r\nExplanation: There are 4 matrices of dimension \r\n40x20, 20x30, 30x10, 10x30. Say the matrices are \r\nnamed as A, B, C, D. Out of all possible combinations,\r\nthe most efficient way is (A*(B*C))*D. \r\nThe number of operations are -\r\n20*30*10 + 40*20*10 + 40*10*30 = 26000.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- The dp[i][j] represents the minimum number of scalar multiplications required to compute the matrix chain multiplication of matrices from i to j.\r\n- Iterate through the chain lengths from 2 to N (chain length of 2 means considering two matrices at a time).\r\n- For each chain length, iterate through all possible starting matrices (i).\r\n- For each starting matrix, calculate the cost of multiplying the matrices and update dp[i][j].\r\n- Finally, return dp[1][N-1], which represents the minimum number of scalar multiplications needed for the entire matrix chain multiplication.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^3), where n is the length of the array arr.\r\n- The space complexity is O(n^2) due to the dp array.\r\n- Overall, the algorithm runs in O(n^3) time and O(n^2) space.",
      "code": "*/\r\n\r\nint fmemo(int i, int j, int arr[], vector<vector<int>>& dp){\r\n    if(i==j) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    int mini = INT_MAX;\r\n    for(int k=i; k<j; k++){\r\n        int cost = arr[i-1]*arr[k]*arr[j] + fmemo(i,k,arr,dp) + fmemo(k+1,j,arr,dp);\r\n        mini = min(cost,mini);\r\n    }\r\n    return dp[i][j] = mini;\r\n}\r\n\r\nint matrixMultiplication(int N, int arr[]){\r\n    int i=1, j = N-1;\r\n    vector<vector<int>> dp(N,vector<int>(N,-1));\r\n    return fmemo(i,j,arr,dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int k=i; k<j; k++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\8. DP on Partition\\01. MCM.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-cost-to-cut-stick": {
      "id": "minimum-cost-to-cut-stick",
      "title": "Minimum cost to cut stick",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a wooden stick of length n units. The stick is labelled from 0 to n.\r\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\r\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\r\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts.\r\nReturn the minimum total cost of the cuts.\r\n\r\nExample:\r\nInput: n = 7, cuts = [1,3,4,5]\r\nOutput: 16\r\nExplanation: Using cuts [1, 3, 4, 5] as the order, the total cost is 1 + 3 + 3 + 4 + 5 = 16.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Define a 2D DP array `dp` where dp[i][j] represents the minimum total cost to cut the stick between cuts[i] and cuts[j].\r\n- Initialize dp[i][i] to 0 because there is no cost for a single cut.\r\n- Iterate over the stick lengths from length 2 to the length of cuts + 1.\r\n- For each stick length, iterate through all possible cut starting points (i).\r\n- Calculate the cost for cutting the stick between cuts[i] and cuts[i + len - 1] and update the dp array.\r\n- Finally, return dp[0][cuts.size() - 1], which represents the minimum total cost of the cuts.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^3), where n is the length of the cuts array.\r\n- The space complexity is O(n^2) due to the dp array.\r\n- Overall, the algorithm runs in O(n^3) time and O(n^2) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int j, vector<int>& cuts, vector<vector<int>>& dp){\r\n    if(i > j) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    int mini = 1e9;\r\n    for(int k = i; k <= j; k++){\r\n        int cost = (cuts[j + 1] - cuts[i - 1]) + fmemo(i, k - 1, cuts, dp) + fmemo(k + 1, j, cuts, dp);\r\n        mini = min(cost, mini);\r\n    }\r\n    return dp[i][j] = mini;\r\n}\r\n\r\nint minCost(int n, vector<int>& cuts) {\r\n    vector<int> cut;\r\n    cut.push_back(0);\r\n    for(auto i : cuts)\r\n        cut.push_back(i);\r\n    cut.push_back(n);\r\n    sort(cut.begin(), cut.end());\r\n    int s = cut.size();\r\n    vector<vector<int>> dp(s, vector<int>(s, -1));\r\n    int i = 1, j = cuts.size();\r\n    return fmemo(i, j, cut, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int k = i; k <= j; k++)",
        "for(auto i : cuts)",
        "sort(",
        ".push_back(",
        ".push_back(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\8. DP on Partition\\02. Minimum cost to cut stick.cpp",
      "verified": false,
      "needsReview": true
    },
    "burst-ballons": {
      "id": "burst-ballons",
      "title": "Burst Ballons",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums.\r\nYou are asked to burst all the balloons.\r\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins.\r\nIf i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\r\nReturn the maximum coins you can collect by bursting the balloons wisely.\r\n\r\nExample:\r\nInput: nums = [3, 1, 5, 8]\r\nOutput: 167\r\nExplanation:\r\nnums = [3, 1, 5, 8] --> [3, 5, 8] --> [3, 8] --> [8] --> []\r\ncoins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Define a 2D DP array `dp` where dp[i][j] represents the maximum coins collected by bursting balloons between indices i and j.\r\n- Iterate over the stick lengths from length 2 to the length of nums - 1.\r\n- For each subarray length, iterate through all possible starting indices (i).\r\n- Calculate the maximum coins collected by bursting balloons in the subarray between i and j, and update the dp array.\r\n- Finally, return dp[1][n - 2], which represents the maximum coins collected by bursting all the balloons.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^3), where n is the length of the nums array.\r\n- The space complexity is O(n^2) due to the dp array.\r\n- Overall, the algorithm runs in O(n^3) time and O(n^2) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int j, vector<int>& nums, vector<vector<int>>& dp){\r\n    if(j < i) return 0;\r\n\r\n    if(dp[i][j] != -1) return dp[i][j];\r\n\r\n    int ans = -1e9;\r\n    // the main curx is we are finding the last ballon remaining instead of the one bursting so that both sub problems remain independent\r\n    for(int k = i; k <= j; k++){\r\n        int coins = (nums[i - 1] * nums[k] * nums[j + 1]) + fmemo(i, k - 1, nums, dp) + fmemo(k + 1, j, nums, dp);\r\n        ans = max(ans, coins);\r\n    }\r\n    return dp[i][j] = ans;\r\n}\r\n\r\nint maxCoins(vector<int>& nums) {\r\n    nums.insert(nums.begin(), 1);\r\n    nums.push_back(1);\r\n    int n = nums.size();\r\n    int i = 1, j = n - 2;\r\n    vector<vector<int>> dp(n, vector<int>(n, -1));\r\n    return fmemo(i, j, nums, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int k = i; k <= j; k++)",
        ".insert(",
        ".push_back("
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\8. DP on Partition\\03. Burst Ballons.cpp",
      "verified": false,
      "needsReview": true
    },
    "palindorme-partionting-2": {
      "id": "palindorme-partionting-2",
      "title": "Palindorme Partionting 2",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a string s, partition s such that every substring of the partition is a palindrome.\r\nReturn the minimum cuts needed for a palindrome partitioning of s.\r\n\r\nExample:\r\nInput: s = \"aab\"\r\nOutput: 1\r\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Define a 1D DP array `dp` where dp[i] represents the minimum cuts needed for a palindrome partitioning of s starting from index i.\r\n- Iterate through each index i of the string.\r\n- For each index i, iterate through all possible ending indices j such that j is in the range [i, n).\r\n- Check if the substring from index i to j is a palindrome. If yes, update the dp[i] value by taking the minimum of its current value and dp[j + 1] + 1.\r\n- Finally, return dp[0] - 1, which represents the minimum cuts needed for a palindrome partitioning of the entire string.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n^2), where n is the length of the string.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n^2) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nbool isPalindrome(int i, int j, string& s){\r\n    while(i < j){\r\n        if(s[i] != s[j]) return false;\r\n        i++; j--;\r\n    }\r\n    return true;\r\n}\r\n\r\nint fmemo(int i, string& s, vector<int>& dp){\r\n    if(i == s.size()) return 0;\r\n\r\n    if(dp[i] != -1) return dp[i];\r\n\r\n    int ans = 1e9;\r\n    for(int j = i; j < s.size(); j++){\r\n        if(isPalindrome(i, j, s)){\r\n            int cost = 1 + fmemo(j + 1, s, dp);\r\n            ans = min(ans, cost);\r\n        }\r\n    }\r\n    return dp[i] = ans;\r\n}\r\n\r\nint minCut(string s) {\r\n    int n = s.size();\r\n    vector<int> dp(n, -1);\r\n    return fmemo(0, s, dp) - 1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "for(int j = i; j < s.size()",
        "while(i < j)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\8. DP on Partition\\05. Palindorme Partionting 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "partition-array-for-maximum-sum": {
      "id": "partition-array-for-maximum-sum",
      "title": "Partition array for maximum sum",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k.\r\nAfter partitioning, each subarray has their values changed to become the maximum value of that subarray.\r\nReturn the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.\r\n\r\nExample:\r\nInput: arr = [1, 15, 7, 9, 2, 5, 10], k = 3\r\nOutput: 84\r\nExplanation: arr becomes [15, 15, 15, 9, 10, 10, 10]",
      "approach": "- This problem can be solved using dynamic programming.\r\n- Define a 1D DP array `dp` where dp[i] represents the largest sum of the array after partitioning from index i to the end.\r\n- Iterate through each index i of the array in reverse order.\r\n- For each index i, iterate through all possible partition lengths from 1 to k.\r\n- Calculate the maximum sum for the current partition, which is the maximum element within the partition multiplied by the length of the partition.\r\n- Update dp[i] with the maximum value among all possible partition scenarios.\r\n- Finally, return dp[0], which represents the largest sum of the array after partitioning.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(n * k), where n is the length of the array.\r\n- The space complexity is O(n) due to the dp array.\r\n- Overall, the algorithm runs in O(n * k) time and O(n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint fmemo(int i, int k, vector<int>& arr, vector<int>& dp){\r\n    if(i == arr.size()) return 0;\r\n\r\n    if(dp[i] != -1) return dp[i];\r\n\r\n    int n = arr.size();\r\n    int maxi = 0, ans = 0;\r\n    for(int j = i; j < min(i + k, n); j++){\r\n        maxi = max(maxi, arr[j]);\r\n        int maxSum = maxi * (j - i + 1) + fmemo(j + 1, k, arr, dp);\r\n        ans = max(ans, maxSum);\r\n    }\r\n    return dp[i] = ans;\r\n}\r\n\r\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\r\n    int n = arr.size();\r\n    vector<int> dp(n, -1);\r\n    return fmemo(0, k, arr, dp);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for(int j = i; j < min(i + k, n)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\8. DP on Partition\\06. Partition array for maximum sum.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximal-square": {
      "id": "maximal-square",
      "title": "Maximal Square",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n\r\nExample:\r\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\r\nOutput: 4",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to find the largest square containing only 1's.\r\n- Define a 2D DP array `dp` where dp[i][j] represents the side length of the largest square ending at (i, j).\r\n- The base case is dp[i][0] = matrix[i][0] and dp[0][j] = matrix[0][j].\r\n- Iterate through each cell (i, j) in the matrix starting from (1, 1).\r\n- If matrix[i][j] is '1', update dp[i][j] as the minimum of (dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1.\r\n- Update the maximum side length `maxSide` accordingly.\r\n- Return `maxSide * maxSide`, which is the area of the largest square containing only 1's.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(m * n), where m is the number of rows and n is the number of columns in the matrix.\r\n- The space complexity is O(m * n) due to the dp array.\r\n- Overall, the algorithm runs in O(m * n) time and O(m * n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint ftab(int m, int n, vector<vector<char>>& matrix){\r\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\r\n    int maxSide = 0;\r\n    for(int i = 1; i <= m; i++){\r\n        for(int j = 1; j <= n; j++){\r\n            if(matrix[i-1][j-1] == '1'){\r\n                int temp = min(dp[i-1][j], dp[i-1][j-1]);\r\n                dp[i][j] = min(dp[i][j-1], temp) + 1;\r\n                maxSide = max(maxSide, dp[i][j]);\r\n            }\r\n        }\r\n    }\r\n    return maxSide * maxSide;\r\n}\r\n\r\nint maximalSquare(vector<vector<char>>& matrix) {\r\n    int m = matrix.size(), n = matrix[0].size();\r\n    return ftab(m, n, matrix);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<char>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i = 1; i <= m; i++)",
        "for(int j = 1; j <= n; j++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\9. DP on Squares\\01. Maximal Square.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-square-submatrices": {
      "id": "count-square-submatrices",
      "title": "Count square submatrices",
      "category": "dynamic-programming",
      "difficulty": "unknown",
      "problemStatement": "Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.\r\n\r\nExample:\r\nInput: matrix =\r\n[\r\n  [0,1,1,1],\r\n  [1,1,1,1],\r\n  [0,1,1,1]\r\n]\r\nOutput: 15\r\nExplanation: \r\nThere are 10 squares of side 1.\r\nThere are 4 squares of side 2.\r\nThere is  1 square of side 3.\r\nTotal number of squares = 10 + 4 + 1 = 15.",
      "approach": "- This problem can be solved using dynamic programming.\r\n- We need to find the count of square submatrices with all ones.\r\n- Define a 2D DP array `dp` where dp[i][j] represents the side length of the largest square ending at (i, j).\r\n- The base case is dp[i][0] = matrix[i][0] and dp[0][j] = matrix[0][j].\r\n- Iterate through each cell (i, j) in the matrix starting from (1, 1).\r\n- If matrix[i][j] is 1, update dp[i][j] as the minimum of (dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1.\r\n- Add dp[i][j] to the `ans` variable to keep track of the total count of squares.\r\n- Return the `ans`.\r\n\r\nCOMPLEXITY ANALYSIS:\r\n- The time complexity of this approach is O(m * n), where m is the number of rows and n is the number of columns in the matrix.\r\n- The space complexity is O(m * n) due to the dp array.\r\n- Overall, the algorithm runs in O(m * n) time and O(m * n) space.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint ftab(int m, int n, vector<vector<int>>& matrix){\r\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\r\n    int ans = 0;\r\n    for(int i = 1; i <= m; i++){\r\n        for(int j = 1; j <= n; j++){\r\n            if(matrix[i-1][j-1] == 1){\r\n                int temp = min(dp[i-1][j], dp[i-1][j-1]);\r\n                dp[i][j] = min(dp[i][j-1], temp) + 1;\r\n                ans += dp[i][j];\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint countSquares(vector<vector<int>>& matrix) {\r\n    int m = matrix.size(), n = matrix[0].size();\r\n    return ftab(m, n, matrix);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "dynamic-programming"
      ],
      "fingerprint": [
        "vector<vector<int>",
        "vector<vector<int>",
        "vector<int>",
        "for(int i = 1; i <= m; i++)",
        "for(int j = 1; j <= n; j++)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\14. Dynamic Programming\\9. DP on Squares\\02. Count square submatrices.cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-trie-prefix-tree": {
      "id": "implement-trie-prefix-tree",
      "title": "Implement Trie (Prefix Tree)",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "Implement the Trie class, which supports insertion, search, and startsWith operations.",
      "approach": "- Create a TrieNode class with an array of child nodes, each representing a letter.\r\n- The Trie class maintains a root TrieNode.\r\n- For insertion, traverse the trie, creating new nodes as necessary for each character.\r\n- For search, traverse the trie, checking if nodes exist for each character and if the final node is marked as a complete word.\r\n- For startsWith, traverse the trie similarly to search, but don't require the final node to be marked as a complete word.\r\n\r\nComplexity Analysis:\r\n- Insertion, search, and startsWith operations take O(L) time, where L is the length of the word or prefix.\r\n- Space complexity is O(N * M), where N is the number of words and M is the average length of the words.",
      "code": "*/\r\n\r\nclass TrieNode{\r\npublic:\r\n    TrieNode* child[26];\r\n    bool isWord;\r\n\r\n    TrieNode(){\r\n        this->isWord = false;\r\n        for(int i=0; i<26; i++){\r\n            this->child[i] = NULL;\r\n        }\r\n    }\r\n};\r\n\r\nclass Trie {\r\npublic:\r\n    TrieNode* root;\r\n\r\n    Trie() {\r\n        root = new TrieNode();\r\n    }\r\n    \r\n    void insert(string word) {\r\n        TrieNode* curr = root;\r\n        for(int i=0; i<word.size(); i++){\r\n            int ltr = word[i] - 'a';\r\n            if(!curr->child[ltr])\r\n                curr->child[ltr] = new TrieNode();\r\n            curr = curr->child[ltr];\r\n        }\r\n        curr->isWord = true;\r\n    }\r\n    \r\n    bool search(string word) {\r\n        TrieNode* curr = root;\r\n        for(int i=0; i<word.size(); i++){\r\n            int ltr = word[i]-'a';\r\n            if(!curr->child[ltr]) return false;\r\n            curr = curr->child[ltr];\r\n        }\r\n        return curr && curr->isWord;\r\n    }\r\n    \r\n    bool startsWith(string prefix) {\r\n        TrieNode* curr = root;\r\n        for(int i=0; i<prefix.size(); i++){\r\n            int ltr = prefix[i]-'a';\r\n            if(!curr->child[ltr]) return false;\r\n            curr = curr->child[ltr];\r\n        }\r\n        return curr;\r\n    }\r\n};",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [
        "for(int i=0; i<26; i++)",
        "for(int i=0; i<word.size()",
        "for(int i=0; i<word.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\1. Theory\\01. Implement Trie (Prefix Tree).cpp",
      "verified": false,
      "needsReview": true
    },
    "implement-trie-2": {
      "id": "implement-trie-2",
      "title": "Implement Trie 2",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "Ninja has to implement a data structure \"TRIE\" from scratch. Implement the functions as follows:\r\n1) Trie(): Initializes the trie object.\r\n2) insert(\"WORD\"): Inserts the string \"WORD\" into the trie.\r\n3) countWordsEqualTo(\"WORD\"): Returns how many times the string \"WORD\" is present in the trie.\r\n4) countWordsStartingWith(\"PREFIX\"): Returns how many words in the trie have the string \"PREFIX\" as a prefix.\r\n5) erase(\"WORD\"): Deletes one occurrence of the string \"WORD\" from the trie.",
      "approach": "- Create a TrieNode class with an array of child nodes, each representing a letter.\r\n- Maintain the count of words with a specific prefix (cntPre) and the count of words (cntWord) at each node.\r\n- Implement insert, countWordsEqualTo, countWordsStartingWith, and erase functions using TrieNode operations.\r\n\r\nComplexity Analysis:\r\n- All operations take O(L) time, where L is the length of the word or prefix.\r\n- Space complexity is O(N * M), where N is the number of words and M is the average length of the words.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\2. Problems\\01. Implement Trie 2.cpp",
      "verified": false,
      "needsReview": true
    },
    "complete-string": {
      "id": "complete-string",
      "title": "Complete String",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "Ninja developed a fascination for arrays and strings, so this time his teacher gave him an array of strings 'A' of size 'N'. Each element of this array is a string. A string is called a complete string if every prefix of this string is also present in the array 'A'. Ninja is challenged to find the longest complete string in the array 'A'. If there are multiple strings with the same length, return the lexicographically smallest one, and if no string exists, return \"None\".\r\n\r\nExample:\r\nN = 4\r\nA = [\"ab\", \"abc\", \"a\", \"bp\"]\r\nExplanation:\r\n- Only prefix of the string \"a\" is \"a\", which is present in array 'A'. So, it is one of the possible strings.\r\n- Prefixes of the string \"ab\" are \"a\" and \"ab\", both of which are present in array 'A'. So, it is one of the possible strings.\r\n- Prefixes of the string \"bp\" are \"b\" and \"bp\". \"b\" is not present in array 'A'. So, it cannot be a valid string.\r\n- Prefixes of the string \"abc\" are \"a\", \"ab\", and \"abc\", all of which are present in array 'A'. So, it is one of the possible strings.\r\n- We need to find the maximum length string, so \"abc\" is the required string.",
      "approach": "- Create a Trie data structure to store the strings in the array 'A'.\r\n- Insert all the strings into the Trie.\r\n- Iterate through each string in array 'A':\r\n  - Check if the string is a valid complete string using the Trie.\r\n  - If it is valid, update the answer string based on the length and lexicographical order.\r\n\r\nComplexity Analysis:\r\n- Inserting each string into the Trie takes O(N*K) time and space, where N is the number of strings and K is the average length of strings.\r\n- Validating each string takes O(K) time.\r\n- The overall time complexity is O(N*K) and the space complexity is O(N*K), where N is the number of strings and K is the average length of strings.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\2. Problems\\02. Complete String.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-distinct-subsitrings": {
      "id": "count-distinct-subsitrings",
      "title": "Count distinct subsitrings",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "Given a string of length N of lowercase alphabet characters. Implement the function countDistinctSubstring() to return the count of total distinct substrings of the given string.",
      "approach": "- Create a Trie data structure to efficiently store and count distinct substrings.\r\n- For each character in the string, insert its suffixes into the Trie, and each insertion increases the count of distinct substrings.\r\n- Return the total count of distinct substrings.\r\n\r\nComplexity Analysis:\r\n- Inserting each substring into the Trie takes O(N) time and O(N) space.\r\n- Overall time complexity is O(N^2) since there are O(N^2) substrings in total.\r\n- Space complexity is O(N) to store the Trie.",
      "code": "",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "trie"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\2. Problems\\03. Count distinct subsitrings.cpp",
      "verified": false,
      "needsReview": true
    },
    "bitwise-basic-operations": {
      "id": "bitwise-basic-operations",
      "title": "Bitwise basic operations",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "You are given six positive integers: 'a', 'b', 'c', 'd', 'e', and 'f'.\r\nYou will be given three functions: 'getXOR', 'getBit', and 'setBit'.\r\nYour task is to do the following:\r\n1. In the function 'getXOR', you will be given two parameters, 'a', and 'b'. Your task is to return the XOR of 'a' and 'b'.\r\n2. In the function 'getBit', you will be given two parameters, 'c' and 'd'. Your task is to return 1 if the 'c'th bit of 'd' is set. Otherwise, return 0.\r\n3. In the function 'setBit', you will be given two parameters, 'e' and 'f'. Your task is to set the 'e'th bit in 'f' if it is not set. At last, return the integer 'f'. The expected time complexity is 'O(1)', and the expected space complexity is 'O(1').\r\n\r\nCODE:",
      "approach": "1. For the 'getXOR' function, simply use the XOR (^) operator to get the XOR of 'a' and 'b'.\r\n2. For the 'getBit' function, use the right shift (>>) and bitwise AND (&) operators to check if the 'c'th bit of 'd' is set or not.\r\n3. For the 'setBit' function, use the bitwise OR (|) operator and left shift (<<) to set the 'e'th bit in 'f'.\r\n\r\nComplexity Analysis:\r\n- All three functions have a time complexity of O(1) as they involve simple bitwise operations.\r\n- All three functions have a space complexity of O(1) as they do not require additional memory allocation.",
      "code": "Approach:\r\n1. For the 'getXOR' function, simply use the XOR (^) operator to get the XOR of 'a' and 'b'.\r\n2. For the 'getBit' function, use the right shift (>>) and bitwise AND (&) operators to check if the 'c'th bit of 'd' is set or not.\r\n3. For the 'setBit' function, use the bitwise OR (|) operator and left shift (<<) to set the 'e'th bit in 'f'.\r\n\r\nComplexity Analysis:\r\n- All three functions have a time complexity of O(1) as they involve simple bitwise operations.\r\n- All three functions have a space complexity of O(1) as they do not require additional memory allocation.\r\n*/\r\n\r\nint getXOR(int a, int b) {\r\n    return a ^ b;\r\n}\r\n\r\nint getBit(int c, int d) {\r\n    return (d >> c) & 1;\r\n}\r\n\r\nint setBit(int e, int f) {\r\n    return f | (1 << e);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set"
      ],
      "fingerprint": [],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\2. Problems\\04. Bitwise basic operations.cpp",
      "verified": false,
      "needsReview": true
    },
    "maximum-xor-of-two-numbers": {
      "id": "maximum-xor-of-two-numbers",
      "title": "Maximum XOR of two numbers",
      "category": "tries",
      "difficulty": "unknown",
      "problemStatement": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.\r\n\r\nExample:\r\n\r\nInput: nums = [3,10,5,25,2,8]\r\nOutput: 28\r\nExplanation: The maximum result is 5 XOR 25 = 28.",
      "approach": "1. Create a Trie data structure that stores binary representations of the given numbers.\r\n2. For each number, insert its binary representation into the Trie.\r\n3. For each number, find the maximum XOR that can be obtained with any other number using the Trie.\r\n   - Traverse the Trie for each bit of the number and try to find a bit in the other number's binary representation that gives the maximum XOR.\r\n   - If a complementary bit is found, set the corresponding bit in the result.\r\n4. Return the maximum XOR found.\r\n\r\nComplexity Analysis:\r\n- The Trie insertion and search operations both take O(32) time since we are dealing with 32 bits (maximum). Therefore, the time complexity of the solution is O(n * 32), which simplifies to O(n).\r\n- The space complexity is also O(n) since we are storing the Trie.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nclass TrieNode {\r\npublic:\r\n    TrieNode* child[2];\r\n    \r\n    TrieNode() {\r\n        for(int i = 0; i < 2; i++) {\r\n            this->child[i] = NULL;\r\n        }\r\n    }\r\n};\r\n\r\nclass Trie {\r\npublic:\r\n    TrieNode* root;\r\n    \r\n    Trie() {\r\n        root = new TrieNode();\r\n    }\r\n    \r\n    void insert(int num) {\r\n        TrieNode* curr = root;\r\n        for(int i = 31; i >= 0; i--) {\r\n            int bit = (num >> i) & 1;\r\n            if(!curr->child[bit]) {\r\n                curr->child[bit] = new TrieNode();\r\n            }\r\n            curr = curr->child[bit];\r\n        }\r\n    }\r\n    \r\n    int findMax(int num) {\r\n        TrieNode* curr = root;\r\n        int maxNum = 0;\r\n        for(int i = 31; i >= 0; i--) {\r\n            int bit = (num >> i) & 1;\r\n            if(curr->child[1 - bit]) {\r\n                maxNum = maxNum | (1 << i);\r\n                curr = curr->child[1 - bit];\r\n            } else {\r\n                curr = curr->child[bit];\r\n            }\r\n        }\r\n        return maxNum;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int findMaximumXOR(vector<int>& nums) {\r\n        Trie* tr = new Trie();\r\n        for(auto i : nums) {\r\n            tr->insert(i);\r\n        }\r\n        int ans = 0;\r\n        for(auto i : nums) {\r\n            int temp = tr->findMax(i);\r\n            ans = max(ans, temp);\r\n        }\r\n        return ans;\r\n    }\r\n};",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "hash-set",
        "trie"
      ],
      "fingerprint": [
        "vector<int>",
        "for(int i = 0; i < 2; i++)",
        "for(int i = 31; i >= 0; i--)",
        "for(int i = 31; i >= 0; i--)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\15. Tries\\2. Problems\\05. Maximum XOR of two numbers.cpp",
      "verified": false,
      "needsReview": true
    },
    "minimum-number-of-insertions-to-make-parenthesis-valid": {
      "id": "minimum-number-of-insertions-to-make-parenthesis-valid",
      "title": "Minimum number of insertions to make parenthesis valid",
      "category": "strings-hard",
      "difficulty": "hard",
      "problemStatement": "A parentheses string is valid if and only if:\r\n- It is the empty string,\r\n- It can be written as AB (A concatenated with B), where A and B are valid strings, or\r\n- It can be written as (A), where A is a valid string.\r\nYou are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\r\nReturn the minimum number of moves required to make s valid.\r\n\r\nExample:\r\n\r\nInput: s = \"())\"\r\nOutput: 1",
      "approach": "- We can keep track of the balance of parentheses using two variables: open and close.\r\n- Traverse through the string, and for each character:\r\n  - If it's an opening parenthesis '(', increment the open count.\r\n  - If it's a closing parenthesis ')':\r\n    - If there are open parentheses available (open > 0), decrement the open count.\r\n    - Otherwise, increment the close count.\r\n- The total number of moves required to make the string valid would be equal to open + close.\r\n\r\nComplexity Analysis:\r\n- The solution traverses the input string once, so the time complexity is O(n), where n is the length of the string.\r\n- The space complexity is O(1) as we are using only two extra variables.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nint minAddToMakeValid(string s) {\r\n    int open = 0, close = 0;\r\n    for(char c : s) {\r\n        if(c == '(') {\r\n            open++;\r\n        } else {\r\n            if(open > 0) {\r\n                open--; // balance it with an open parenthesis\r\n            } else {\r\n                close++;\r\n            }\r\n        }\r\n    }\r\n    return open + close; // total moves required\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "for(char c : s)"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\16. Strings (Hard)\\Hard\\01. Minimum number of insertions to make parenthesis valid.cpp",
      "verified": false,
      "needsReview": true
    },
    "count-and-say": {
      "id": "count-and-say",
      "title": "Count and Say",
      "category": "strings-hard",
      "difficulty": "hard",
      "problemStatement": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\r\n\r\ncountAndSay(1) = \"1\"\r\ncountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\r\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\r\n\r\nInput: n = 4\r\nOutput: \"1211\"\r\nExplanation:\r\ncountAndSay(1) = \"1\"\r\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\r\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\r\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
      "approach": "- We can solve this problem using recursion.\r\n- The base case is when n = 1, in which case we return \"1\".\r\n- Otherwise, we calculate the count-and-say string for n-1 using recursion.\r\n- Then, we iterate through the previous string and build the new string based on the count of consecutive characters.\r\n\r\nComplexity Analysis:\r\n- Since we are using recursion to generate the count-and-say sequence, the time complexity is O(2^n), where n is the given input.\r\n- The space complexity is O(1) as we are using a constant amount of extra space for each recursion level.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nstring countAndSay(int n) {\r\n    if(n == 1) {\r\n        return \"1\";\r\n    }\r\n    string prev = countAndSay(n - 1);\r\n    string ans = \"\";\r\n    for(int i = 0; i < prev.size(); i++) {\r\n        int j = i + 1;\r\n        while(j < prev.size() && prev[j - 1] == prev[j]) {\r\n            j++;\r\n        }\r\n        ans += to_string(j - i) + prev[i];\r\n        i = j - 1;\r\n    }\r\n    return ans;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "recursion"
      ],
      "fingerprint": [
        "for(int i = 0; i < prev.size()",
        "while(j < prev.size()"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\16. Strings (Hard)\\Hard\\02. Count and Say.cpp",
      "verified": false,
      "needsReview": true
    },
    "kmp-or-z-string-matching-algo": {
      "id": "kmp-or-z-string-matching-algo",
      "title": "KMP or Z string matching algo",
      "category": "strings-hard",
      "difficulty": "hard",
      "problemStatement": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\r\n\r\nExample 1:\r\nInput: haystack = \"sadbutsad\", needle = \"sad\"\r\nOutput: 0\r\nExplanation: \"sad\" occurs at index 0 and 6.\r\nThe first occurrence is at index 0, so we return 0.",
      "approach": "- We can solve this problem using the KMP (Knuth-Morris-Pratt) string matching algorithm.\r\n- First, we calculate the LPS (Longest Prefix Suffix) array for the needle string.\r\n- Then, we create a new string by concatenating needle, a special character (not present in either needle or haystack), and haystack.\r\n- We iterate through the new string and compare characters using the LPS array to determine if there is a match.\r\n- If the LPS value becomes equal to the length of the needle, it means we have found a match, and we return the starting index of the match in the haystack string.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this solution is O(m + n), where m is the length of the needle and n is the length of the haystack.\r\n- The space complexity is O(m + n) but can be reduced to O(n), where m is the length of the needle.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> lps(string& s){\r\n    int n = s.size();\r\n    vector<int> pi(n);\r\n    for(int i = 1; i < n; i++){\r\n        int j = pi[i - 1];\r\n        while(j > 0 && s[j] != s[i]) {\r\n            j = pi[j - 1];\r\n        }\r\n        if(s[j] == s[i]) {\r\n            j++;\r\n        }\r\n        pi[i] = j;\r\n    }\r\n    return pi;\r\n}\r\n\r\nint strStr(string haystack, string needle) {\r\n    if(needle.empty()) {\r\n        return 0;\r\n    }\r\n    string temp = needle + '$' + haystack;\r\n    vector<int> lpsArray = lps(temp);\r\n    for(int i = 0; i < lpsArray.size(); i++) {\r\n        if(lpsArray[i] == needle.size()) {\r\n            return i - 2 * needle.size();\r\n        }\r\n    }\r\n    return -1;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for(int i = 1; i < n; i++)",
        "for(int i = 0; i < lpsArray.size()",
        "while(j > 0 && s[j] != s[i])"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\16. Strings (Hard)\\Hard\\03. KMP or Z string matching algo.cpp",
      "verified": false,
      "needsReview": true
    },
    "longest-happy-prefix": {
      "id": "longest-happy-prefix",
      "title": "Longest Happy Prefix",
      "category": "strings-hard",
      "difficulty": "hard",
      "problemStatement": "A string is called a happy prefix if it is a non-empty prefix that is also a suffix (excluding itself).\r\n\r\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.\r\n\r\nExample 1:\r\nInput: s = \"level\"\r\nOutput: \"l\"\r\nExplanation: s contains 4 prefixes excluding itself (\"l\", \"le\", \"lev\", \"leve\") and suffixes (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix that is also a suffix is \"l\".",
      "approach": "- We can solve this problem using the KMP (Knuth-Morris-Pratt) algorithm.\r\n- First, we calculate the LPS (Longest Prefix Suffix) array for the given string s.\r\n- The last value in the LPS array, lps[n-1], represents the length of the longest prefix that is also a suffix.\r\n- We extract the corresponding substring from s and return it as the longest happy prefix.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this solution is O(n), where n is the length of the string s.\r\n- The space complexity is O(n) to store the LPS array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> kmp(string& s){\r\n    int n = s.size();\r\n    vector<int> pi(n);\r\n    for(int i = 1; i < n; i++){\r\n        int j = pi[i - 1];\r\n        while(j > 0 && s[i] != s[j]) {\r\n            j = pi[j - 1];\r\n        }\r\n        if(s[i] == s[j]) {\r\n            j++;\r\n        }\r\n        pi[i] = j;\r\n    }\r\n    return pi;\r\n}\r\n\r\nstring longestPrefix(string s) {\r\n    int n = s.size();\r\n    vector<int> lps = kmp(s);\r\n    int length = lps[n - 1]; // Length of the longest prefix that is also a suffix\r\n    return s.substr(0, length);\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for(int i = 1; i < n; i++)",
        "while(j > 0 && s[i] != s[j])"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\16. Strings (Hard)\\Hard\\04. Longest Happy Prefix.cpp",
      "verified": false,
      "needsReview": true
    },
    "shortest-palindrome": {
      "id": "shortest-palindrome",
      "title": "Shortest Palindrome",
      "category": "strings-hard",
      "difficulty": "hard",
      "problemStatement": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\r\nReturn the shortest palindrome you can find by performing this transformation.\r\n\r\nExample 1:\r\nInput: s = \"aacecaaa\"\r\nOutput: \"aaacecaaa\"",
      "approach": "1. We can solve this problem using the KMP (Knuth-Morris-Pratt) algorithm.\r\n2. First, we reverse the string s and store it in the string rev.\r\n3. We concatenate s and rev with a special character '$' in between, creating the string temp.\r\n4. We calculate the LPS (Longest Prefix Suffix) array for the string temp using KMP.\r\n5. The last value in the LPS array, lps.back(), represents the length of the longest prefix of temp that is also a suffix.\r\n6. We extract the substring of s starting from index lps.back() to the end and reverse it.\r\n7. Finally, we concatenate the reversed substring with s and return the result as the shortest palindrome.\r\n\r\nComplexity Analysis:\r\n- The time complexity of this solution is O(n), where n is the length of the string s.\r\n- The space complexity is O(n) to store the LPS array.\r\n\r\nCODE:",
      "code": "*/\r\n\r\nvector<int> kmp(string& s) {\r\n    int n = s.size();\r\n    vector<int> pi(n);\r\n    for(int i = 1; i < n; i++) {\r\n        int j = pi[i - 1];\r\n        while(j > 0 && s[i] != s[j]) {\r\n            j = pi[j - 1];\r\n        }\r\n        if(s[i] == s[j]) {\r\n            j++;\r\n        }\r\n        pi[i] = j;\r\n    }\r\n    return pi;\r\n}\r\n\r\nstring shortestPalindrome(string s) {\r\n    string rev = s;\r\n    reverse(rev.begin(), rev.end());\r\n    string temp = s + \"$\" + rev;\r\n    vector<int> lps = kmp(temp);\r\n    string toAdd = s.substr(lps.back());\r\n    reverse(toAdd.begin(), toAdd.end());\r\n    return toAdd + s;\r\n}",
      "complexity": {
        "time": {
          "average": null,
          "worst": null
        },
        "space": {
          "average": null,
          "worst": null
        }
      },
      "patterns": [
        "two-pointers"
      ],
      "fingerprint": [
        "vector<int>",
        "vector<int>",
        "vector<int>",
        "for(int i = 1; i < n; i++)",
        "while(j > 0 && s[i] != s[j])"
      ],
      "source": "D:\\VIBE CODING PROJECTS\\ReCode Backup\\ReCode\\Strivers-A2Z-DSA-Sheet\\16. Strings (Hard)\\Hard\\05. Shortest Palindrome.cpp",
      "verified": false,
      "needsReview": true
    }
  }
}